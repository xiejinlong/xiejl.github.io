<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/xiejl.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/xiejl.github.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/xiejl.github.io/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="一个被裁的菜鸟程序员">
<meta property="og:url" content="https://xiejinlong.github.io/xiejl.github.io/index.html">
<meta property="og:site_name" content="一个被裁的菜鸟程序员">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个被裁的菜鸟程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/xiejl.github.io/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiejinlong.github.io/xiejl.github.io/"/>





  <title> 一个被裁的菜鸟程序员 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/xiejl.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个被裁的菜鸟程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我会笑着迎接每一天</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/xiejl.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/xiejl.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/xiejl.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个被裁的菜鸟程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/xiejl.github.io/2017/04/17/0417recyclerView源码解析/" itemprop="url">
                  recyclerView源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T13:14:52+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/xiejl.github.io/2017/04/17/0417recyclerView源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/17/0417recyclerView源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="recyclerView简介"><a href="#recyclerView简介" class="headerlink" title="recyclerView简介"></a>recyclerView简介</h1><p>自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A flexible view for providing a limited window into a large data set。</div></pre></td></tr></table></figure><br>即，在一个有限的窗口显示大量的数据集的一个复杂的View，简单的说，就是可以通过这个RecyclerView以列表的形式将大量的数据显示出来。</p>
<h1 id="recyclerView简单相关"><a href="#recyclerView简单相关" class="headerlink" title="recyclerView简单相关"></a>recyclerView简单相关</h1><h1 id="recyclerView的简单用法"><a href="#recyclerView的简单用法" class="headerlink" title="recyclerView的简单用法"></a>recyclerView的简单用法</h1><p>其实recylerview使用起来也很方便，主要分成了以下几个组件：</p>
<ul>
<li>Adapter：对于数据集的处理都是在adapter中去完成。</li>
<li>ViewHolder：对于每一个列表项的表现形式，利用viewHolder来减少findViewById的次数，是recyclerView操作的基本单位</li>
<li>LayoutManager：recyclerView对于每一个Item的排列，显示，回收大部分都是通过layoutmanager来处理的。</li>
</ul>
<ol>
<li>在代码中设置布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//recyclerView布局</div><div class="line">&lt;android.support.v7.widget.RecyclerView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:id=&quot;@+id/recycler_id&quot;&gt;</div><div class="line"></div><div class="line">    &lt;/android.support.v7.widget.RecyclerView&gt;</div><div class="line"></div><div class="line">//RecyclerView的每一项的布局</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;xiexie&quot;</div><div class="line">        android:id=&quot;@+id/test_item&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></li>
<li>自定义adapter，里面必须包含ViewHolder实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class AdapterTest extends RecyclerView.Adapter&lt;AdapterTest.Holds&gt; &#123;</div><div class="line"></div><div class="line">    private LayoutInflater layoutInflater;</div><div class="line">    private List&lt;String&gt; userNames = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public AdapterTest(LayoutInflater layoutInflater, List&lt;String&gt; userNames) &#123;</div><div class="line">        this.layoutInflater = layoutInflater;</div><div class="line">        this.userNames = userNames;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public AdapterTest.Holds onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        return new Holds(layoutInflater.inflate(R.layout.username_list, null));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(Holds holder, int position) &#123;</div><div class="line">        holder.textView.setText(userNames.get(position));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return userNames.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class Holds extends RecyclerView.ViewHolder &#123;</div><div class="line">        public TextView textView;</div><div class="line"></div><div class="line">        public Holds(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            textView = (TextView) itemView.findViewById(R.id.test_item);</div><div class="line">            textView.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(View v) &#123;</div><div class="line">                    Log.d(&quot;XJL&quot;, &quot;hahaha&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>最后，只要在初始化recyclerView的地方相应的设置adapter和layoutManager就可以了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">     recyclerView = (RecyclerView)findViewById(R.id.recycler_id);</div><div class="line">        layoutManager = new LinearLayoutManager(this);</div><div class="line">        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);</div><div class="line">        initData();</div><div class="line">        recyclerView.setAdapter(new AdapterTest(getLayoutInflater(), userNames));</div><div class="line">        recyclerView.setLayoutManager(layoutManager);</div><div class="line">        </div><div class="line">        </div><div class="line">private void initData() &#123;</div><div class="line">        userNames = new ArrayList&lt;&gt;();</div><div class="line">        userNames.add(&quot;xiexie1&quot;);</div><div class="line">        userNames.add(&quot;xiexie2&quot;);</div><div class="line">        userNames.add(&quot;xiexie3&quot;);</div><div class="line">        userNames.add(&quot;xiexie4&quot;);</div><div class="line">        userNames.add(&quot;xiexie5&quot;);</div></pre></td></tr></table></figure>
这样，一个可见的列表就构建出来了。</li>
</ol>
<h2 id="recylerView简单流程"><a href="#recylerView简单流程" class="headerlink" title="recylerView简单流程"></a>recylerView简单流程</h2><p>对于一个recyclerView的显示过程，在不通过源码时，我们应该也要有一个直观的认识，也就是对于我们的adapter，我们需要实现哪几个方法？为什么我们需要实现那几个方法？<br>我们下面来看看这几个方法以及相应的流程。</p>
<p>当一个RecyclerView显示时，其中的每一个Item项，也就是ViewHolder，在有多个不同的item类型时，几个方法调用的顺序是这样的:<br>getItemViewType()—–&gt;onCreateViewHolder()——&gt;onBindViewHolder()—-&gt;<br>首先，在getItemViewType中会通过position来获取这个item的类型，然后会通过onCreateViewHolder，来创建相应的ViewHolder，这里仅仅只是创建出这个ViewHolder，里面的数据仍然是空的。最后在onBindViewHolder中进行position数据绑定。对于一个已经创建过的Viewholder，这个类型会被缓存，用来下次的复用。所以，在我们的滑动过程中，基本上每个类型的ViewHolder只会相应的调用一次，在滑动时只需要调用onBindViewHolder。</p>
<h2 id="recyclerView源码入口"><a href="#recyclerView源码入口" class="headerlink" title="recyclerView源码入口:"></a>recyclerView源码入口:</h2><p>我们先来看看recyclerView的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class RecyclerView </div><div class="line">extends ViewGroup implements ScrollingView, NestedScrollingChild</div></pre></td></tr></table></figure><br>通过这个类的定义，我们可以知道对于recyclerView来说，我们并不需要自己去处理滑动冲突，recyclerView已经为我们处理好了。</p>
<h3 id="一些recyclerView的相关定义"><a href="#一些recyclerView的相关定义" class="headerlink" title="一些recyclerView的相关定义"></a>一些recyclerView的相关定义</h3><ul>
<li>Adapter：是RecyclerView.Adapter的子类，用来放置显示的数据集，必须实现。</li>
<li>Position：数据项在Adapter中的位置</li>
<li>Index：可见的子View的位置项</li>
<li>Bingding：用来处理正在准备显示的子View的数据对应于adapter的位置</li>
<li>Recycler：是recyclerview的一个缓冲区，这个缓冲区里面缓存的view加入需要重用的话，必须要利用adapter重新绑定数据。</li>
<li>scrap：是recyclerview的一个缓存区，是指里面缓存的view是接下来需要用到的，里面绑定的数据无需更改，可以直接拿过来使用。是一个轻量级的缓存集合。</li>
<li>dirty：一个被认为是脏的视图，即数据进行修改过，之后如果需要显示必须重新绑定数据。</li>
</ul>
<p>我们直接从调用的过程来阅读,也就是recyclerView的创建和setAdapter这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void setAdapter(Adapter adapter) &#123;</div><div class="line">        // bail out if layout is frozen</div><div class="line">        setLayoutFrozen(false);</div><div class="line">        setAdapterInternal(adapter, false, true);</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在这个方法里面，首先会调用setLayoutFrozen(false)，setLayoutFrozen这个方法主要是layout和scroll滑动的使能开关，一旦设置为true之后，layout将不能更新也不能滑动，同样也不能响应点击事件。置为false，开启使能开关。<br>然后调用setAdapterInternal方法区进行adapter替换，同时开启监听。<br>然后调用setAdapterInternal():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</div><div class="line">           boolean removeAndRecycleViews) &#123;</div><div class="line">       if (mAdapter != null) &#123;</div><div class="line">           mAdapter.unregisterAdapterDataObserver(mObserver);</div><div class="line">           mAdapter.onDetachedFromRecyclerView(this);</div><div class="line">       &#125;</div><div class="line">       if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</div><div class="line">           if (mItemAnimator != null) &#123;</div><div class="line">               mItemAnimator.endAnimations();</div><div class="line">           &#125;</div><div class="line">           if (mLayout != null) &#123;</div><div class="line">               mLayout.removeAndRecycleAllViews(mRecycler);</div><div class="line">               mLayout.removeAndRecycleScrapInt(mRecycler);</div><div class="line">           &#125;</div><div class="line">           // we should clear it here before adapters are swapped to ensure correct callbacks.</div><div class="line">           mRecycler.clear();</div><div class="line">       &#125;</div><div class="line">       mAdapterHelper.reset();</div><div class="line">       final Adapter oldAdapter = mAdapter;</div><div class="line">       mAdapter = adapter;</div><div class="line">       if (adapter != null) &#123;</div><div class="line">           adapter.registerAdapterDataObserver(mObserver);</div><div class="line">           adapter.onAttachedToRecyclerView(this);</div><div class="line">       &#125;</div><div class="line">       if (mLayout != null) &#123;</div><div class="line">           mLayout.onAdapterChanged(oldAdapter, mAdapter);</div><div class="line">       &#125;</div><div class="line">       mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</div><div class="line">       mState.mStructureChanged = true;</div><div class="line">       markKnownViewsInvalid();</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在这个方法里面，首先会进行一系列的清空操作。然后重置adapterHelper，再进行一系列的初始化绑定操作。onAdapterChange这个方法这个会清除缓冲区，重新绘制数据和view类型。<br>后面调用mReycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious)方法，会创建出一个新的recyclerPool并且绑定上新的adapter。我们在这里可以看看里面做的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> void onAdapterChanged(Adapter oldAdapter, Adapter newAdapter,</div><div class="line">                boolean compatibleWithPrevious) &#123;</div><div class="line">            clear();</div><div class="line">            getRecycledViewPool().onAdapterChanged(oldAdapter, newAdapter, compatibleWithPrevious);</div><div class="line">        &#125;</div><div class="line">====&gt;clear()</div><div class="line">public void clear() &#123;</div><div class="line">	    //清空当前屏幕显示的view</div><div class="line">            mAttachedScrap.clear();</div><div class="line">	   //回收缓存的ViewHolder</div><div class="line">            recycleAndClearCachedViews();</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>所以，这里做了一系列的缓存清空操作。那么这些缓存都是什么呢？在这里，我们先来看看这些缓存的结构定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;ViewHolder&gt;();</div><div class="line">private ArrayList&lt;ViewHolder&gt; mChangedScrap = null;</div><div class="line">final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();</div><div class="line">private RecycledViewPool mRecyclerPool；</div></pre></td></tr></table></figure></p>
<ul>
<li>mAttachedScrap：用于屏幕内itemview的快速重用，即该ViewHolder列表仍未与RecyclerView分离,仍然处于显示的状态</li>
<li>mChangedScrap：与RecyclerView分离的ViewHolder列表，表示这个Viewholder仍然处于显示状态，但是已经被标记为需要重新绑定数据了</li>
<li>mCachedViews： 用于缓存屏幕外的两个itemview，最近刚被抛弃的两个Viewholder，即刚不显示的ViewHolder，默认缓存个数，上下各一个。</li>
<li>mRecyclerPool:提供复用的ViewHolder池，默认上限为5个</li>
<li>mViewCacheExtension：让开发者自主控制ViewHolder缓存。</li>
</ul>
<p>我们先来了解下这几个缓存的区别，<br>如果这个ViewHolder仍然在RecyclerView的可视范围内，而且是可以重用的，合法的，没有被移除的，那么这个ViewHolder会被加入到mAttachedScrap这个列表中。<br>如果这个ViewHolder项已经被标记更新过了，比如说我们在代码中notifyItem()，而且这个item是在屏幕内的，那么这个ViewHolder就被标记了需要被更新。<br>如果一个ViewHolder刚刚被移除出可见范围，那么将会被添加到mCacheView中，这个默认会缓存屏幕之外的两个ViewHolder。<br>如果mCacheView已经满了，当再添加一个新的移除的ViewHolder，那么会以lru的方式，将最早添加到这个列表的ViewHolder移除，并添加到RecyclerPool缓存。<br>mViewCacheExtension是recycler提供给我们们的自定义缓存机制，这个是第三级缓存，在recyclerPool之前，在mcacheView之后，默认的是空实现。</p>
<p>在recyclerView中，所谓的大部分的复用机制，几乎都是通过ViewHolder的type复用，然后在再次显示的时候重新绑定数据，最简单的说，就是跳过了onCreateViewHolder这一个步骤，只调用了onBindViewHolder。</p>
<p>我们再来看看另外一个基本可以调用到的方法，setLayoutManager:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void setLayoutManager(LayoutManager layout) &#123;</div><div class="line">        if (layout == mLayout) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">	//做一系列的清空操作，如果之前有layoutManager，则移除，然后更新为当前的layoutManager</div><div class="line">        if (mLayout != null) &#123;</div><div class="line">            if (mIsAttached) &#123;</div><div class="line">                mLayout.dispatchDetachedFromWindow(this, mRecycler);</div><div class="line">            &#125;</div><div class="line">            mLayout.setRecyclerView(null);</div><div class="line">        &#125;</div><div class="line">        mRecycler.clear();</div><div class="line">        mChildHelper.removeAllViewsUnfiltered();</div><div class="line">        mLayout = layout;</div><div class="line">        if (layout != null) &#123;</div><div class="line">            if (layout.mRecyclerView != null) &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +</div><div class="line">                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);</div><div class="line">            &#125;</div><div class="line">            mLayout.setRecyclerView(this);</div><div class="line">            if (mIsAttached) &#123;</div><div class="line">                mLayout.dispatchAttachedToWindow(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>虽然这个方法也没做什么实质性的东西，但是我们必须先有一个清楚的认识，recyclerView对于子item的排列管理，显示回收都是通过layoutManager来处理的。</p>
<h2 id="RecyclerView源码2"><a href="#RecyclerView源码2" class="headerlink" title="RecyclerView源码2"></a>RecyclerView源码2</h2><p>在这里，我们再通过recyclerView的构造函数入手：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public RecyclerView(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RecyclerView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>我们先看下这个三个构造函数，最早接触自定义view的时候，我并不知道为什么每个自定义view都要实现3个构造函数，你是不是也不清楚呢？其实吧，自定义view的每个构造函数都对应一个创建这个view的方式。</p>
<ul>
<li>RecyclerView(Context context): 这种方式以context作为参数，主要是用在代码中初始化的。像我们在代码中以new的方式创建出一个view对象时，只需要传入一个context。</li>
<li>RecyclerView(Context context, @Nullable AttributeSet attrs)：这种方式主要是用来在xml文件中初始化的，attrs参数便是我们在xml所设置的一些属性参数。</li>
<li>RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) : 同样也是在xml里面使用，不过多了一个style设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</div><div class="line">       super(context, attrs, defStyle);</div><div class="line">       setScrollContainer(true);</div><div class="line">       setFocusableInTouchMode(true);</div><div class="line">       final int version = Build.VERSION.SDK_INT;</div><div class="line">       mPostUpdatesOnAnimation = version &gt;= 16;</div><div class="line"></div><div class="line">       final ViewConfiguration vc = ViewConfiguration.get(context);</div><div class="line">       mTouchSlop = vc.getScaledTouchSlop();</div><div class="line">       mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();</div><div class="line">       mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();</div><div class="line">       setWillNotDraw(ViewCompat.getOverScrollMode(this) == ViewCompat.OVER_SCROLL_NEVER);</div><div class="line"></div><div class="line">       mItemAnimator.setListener(mItemAnimatorListener);</div><div class="line">       initAdapterManager();</div><div class="line">       initChildrenHelper();</div><div class="line">       // If not explicitly specified this view is important for accessibility.</div><div class="line">       if (ViewCompat.getImportantForAccessibility(this)</div><div class="line">               == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</div><div class="line">           ViewCompat.setImportantForAccessibility(this,</div><div class="line">                   ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</div><div class="line">       &#125;</div><div class="line">       mAccessibilityManager = (AccessibilityManager) getContext()</div><div class="line">               .getSystemService(Context.ACCESSIBILITY_SERVICE);</div><div class="line">       setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));</div><div class="line">       // Create the layoutManager if specified.</div><div class="line">       if (attrs != null) &#123;</div><div class="line">           int defStyleRes = 0;</div><div class="line">           TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</div><div class="line">                   defStyle, defStyleRes);</div><div class="line">           String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);</div><div class="line">           a.recycle();</div><div class="line">           createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       mScrollingChildHelper = new NestedScrollingChildHelper(this);</div><div class="line">       setNestedScrollingEnabled(true);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
在这个构造函数里面，recyclerView也只是做了一些基本的设置，并没有做实际的操作，recyclerView就相当于一个自定义View，它的实际的操作正是在自定义View的三大步骤中去做的，也就是onMeasure-&gt;onLayout-&gt;onDraw，下面我们就通过这个三个函数来了解recyclerView<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</div><div class="line">        //如果在measure时更新了Adapter</div><div class="line">	if (mAdapterUpdateDuringMeasure) &#123;</div><div class="line">            eatRequestLayout();</div><div class="line">            processAdapterUpdatesAndSetAnimationFlags();</div><div class="line"></div><div class="line">            if (mState.mRunPredictiveAnimations) &#123;</div><div class="line">                mState.mInPreLayout = true;</div><div class="line">            &#125; else &#123;</div><div class="line">                mAdapterHelper.consumeUpdatesInOnePass();</div><div class="line">                mState.mInPreLayout = false;</div><div class="line">            &#125;</div><div class="line">            mAdapterUpdateDuringMeasure = false;</div><div class="line">            resumeRequestLayout(false);</div><div class="line">        &#125;</div><div class="line">        if (mAdapter != null) &#123;</div><div class="line">            mState.mItemCount = mAdapter.getItemCount();</div><div class="line">        &#125; else &#123;</div><div class="line">            mState.mItemCount = 0;</div><div class="line">        &#125;</div><div class="line">        if (mLayout == null) &#123;</div><div class="line">            defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">        &#125; else &#123;</div><div class="line">	    //对于onmeasure托管给了LayoutManager去计算</div><div class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mState.mInPreLayout = false; // clear</div><div class="line">    &#125;</div><div class="line">====&gt;mlayout.onMeasure</div><div class="line"> public void onMeasure(Recycler recycler, State state, int widthSpec, int heightSpec) &#123;</div><div class="line">            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">        &#125;</div><div class="line">=====&gt;mRecyclerView.defaultOnmeasure</div><div class="line"> private void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</div><div class="line">        final int widthMode = MeasureSpec.getMode(widthSpec);</div><div class="line">        final int heightMode = MeasureSpec.getMode(heightSpec);</div><div class="line">        final int widthSize = MeasureSpec.getSize(widthSpec);</div><div class="line">        final int heightSize = MeasureSpec.getSize(heightSpec);</div><div class="line"></div><div class="line">        int width = 0;</div><div class="line">        int height = 0;</div><div class="line">	//对宽高的模式进行计算</div><div class="line">        switch (widthMode) &#123;</div><div class="line">            case MeasureSpec.EXACTLY:</div><div class="line">            case MeasureSpec.AT_MOST:</div><div class="line">                width = widthSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.UNSPECIFIED:</div><div class="line">            default:</div><div class="line">                width = ViewCompat.getMinimumWidth(this);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (heightMode) &#123;</div><div class="line">            case MeasureSpec.EXACTLY:</div><div class="line">            case MeasureSpec.AT_MOST:</div><div class="line">                height = heightSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.UNSPECIFIED:</div><div class="line">            default:</div><div class="line">                height = ViewCompat.getMinimumHeight(this);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line">====&gt;</div><div class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        //计算实际的宽高，通过set的宽高和marging</div><div class="line">	boolean optical = isLayoutModeOptical(this);</div><div class="line">        if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            int opticalWidth  = insets.left + insets.right;</div><div class="line">            int opticalHeight = insets.top  + insets.bottom;</div><div class="line"></div><div class="line">            measuredWidth  += optical ? opticalWidth  : -opticalWidth;</div><div class="line">            measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class="line">        &#125;</div><div class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line"> private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        mMeasuredWidth = measuredWidth;</div><div class="line">        mMeasuredHeight = measuredHeight;</div><div class="line"></div><div class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
上面就是onMeasure的整个计算过程，现在我们来看看onLayout这个方法的处理，这个方法会比较复杂，因为onLayout的计算不仅仅只是要计算整个RecyclerView的位置，而且需要去计算每个子item的位置。我们详细的看看这段代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"> protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        eatRequestLayout();</div><div class="line">	//traceCompat是用来跟踪系统性能的，beginsection和endsection需要成对出现</div><div class="line">        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</div><div class="line">        dispatchLayout();</div><div class="line">        TraceCompat.endSection();</div><div class="line">        resumeRequestLayout(false);</div><div class="line">        mFirstLayoutComplete = true;</div><div class="line">    &#125;</div><div class="line">====&gt;下面来看看dispatchLayout，这个是最主要的方法</div><div class="line">void dispatchLayout() &#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    //获取当前layout计算时，item的最小和最大的position</div><div class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</div><div class="line">    step0:寻找所有的未移除的item</div><div class="line">    int count = mChildHelper.getChildCount();</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</div><div class="line">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</div><div class="line">                	//如果这个item需要被忽略或者是不合法的，则直接跳过   </div><div class="line">			 continue;</div><div class="line">                &#125;</div><div class="line">                final ItemHolderInfo animationInfo = mItemAnimator</div><div class="line">                        .recordPreLayoutInformation(mState, holder,</div><div class="line">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</div><div class="line">                                holder.getUnmodifiedPayloads());</div><div class="line">                mViewInfoStore.addToPreLayout(holder, animationInfo);</div><div class="line">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</div><div class="line">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</div><div class="line">                    long key = getChangedHolderKey(holder);</div><div class="line">                    //满足下面条件的holder将会被添加到oldChangeHoder里面</div><div class="line">                    //1.处于隐藏状态但是仍未删除的vh</div><div class="line">                    //2.隐藏的vh但是数据已经修改过了</div><div class="line">                    //3.layoutmanager想在pre-layout中进行layout计算的item</div><div class="line">                    mViewInfoStore.addToOldChangeHolders(key, holder);</div><div class="line">                    </div><div class="line">    step1:执行预布局，利用先前position所对应的item，layoutmanager想要布局所有东西，甚至是已经移除的item。会返回pre-layout位置所对应的APPEARING view，这种标记的view是相当于真正的layout的一部分。</div><div class="line">	    //保存这个ViewHolder之前的位置</div><div class="line">            saveOldPositions();</div><div class="line">            final boolean didStructureChange = mState.mStructureChanged;</div><div class="line">            mState.mStructureChanged = false;</div><div class="line">            //在这里对子元素去进行预布局的计算，这里就需要依据LayoutManager的具体实现类来进行计算，因为是预布局，我们需要将mStructureChanged设置为false</div><div class="line">	    mLayout.onLayoutChildren(mRecycler, mState);</div><div class="line">            mState.mStructureChanged = didStructureChange;</div><div class="line">		</div><div class="line">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</div><div class="line">                final View child = mChildHelper.getChildAt(i);</div><div class="line">                final ViewHolder viewHolder = getChildViewHolderInt(child);</div><div class="line">                if (viewHolder.shouldIgnore()) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</div><div class="line">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</div><div class="line">                    boolean wasHidden = viewHolder</div><div class="line">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</div><div class="line">                    if (!wasHidden) &#123;</div><div class="line">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</div><div class="line">                    &#125;</div><div class="line">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</div><div class="line">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</div><div class="line">                    if (wasHidden) &#123;</div><div class="line">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            clearOldPositions();</div><div class="line">            mAdapterHelper.consumePostponedUpdates();</div><div class="line">        &#125; else &#123;</div><div class="line">            clearOldPositions();</div><div class="line">        &#125;</div><div class="line">        mState.mItemCount = mAdapter.getItemCount();</div><div class="line">        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</div><div class="line"> 	//step2:pre-layout计算已经执行完毕,真正的进行layout计算</div><div class="line">	mState.mInPreLayout = false;</div><div class="line">        mLayout.onLayoutChildren(mRecycler, mState);</div><div class="line"></div><div class="line">        mState.mStructureChanged = false;</div><div class="line">        mPendingSavedState = null;</div><div class="line"></div><div class="line">        if (mState.mRunSimpleAnimations) &#123;</div><div class="line">            // Step 3: 计算viewHolder所在的位置</div><div class="line">            int count = mChildHelper.getChildCount();</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</div><div class="line">                if (holder.shouldIgnore()) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">		//获取当前这个holder的position</div><div class="line">                long key = getChangedHolderKey(holder);</div><div class="line">                //获取当前viewHolder所对应的animation</div><div class="line">		final ItemHolderInfo animationInfo = mItemAnimator</div><div class="line">                        .recordPostLayoutInformation(mState, holder);</div><div class="line">		//获取这个position之前对应的viewholder</div><div class="line">                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</div><div class="line">                if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</div><div class="line">                    //执行切换动画</div><div class="line">                    final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</div><div class="line">                            oldChangeViewHolder);</div><div class="line">                    animateChange(oldChangeViewHolder, holder, preInfo, animationInfo);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Step 4: 执行Viewinfo和监听animation</div><div class="line">            mViewInfoStore.process(mViewInfoProcessCallback);</div><div class="line">        &#125;</div><div class="line">        resumeRequestLayout(false);</div><div class="line">	//对mRecycler做一次清空操作</div><div class="line">        mLayout.removeAndRecycleScrapInt(mRecycler);</div><div class="line">        mState.mPreviousLayoutItemCount = mState.mItemCount;</div><div class="line">        mDataSetHasChangedAfterLayout = false;</div><div class="line">        mState.mRunSimpleAnimations = false;</div><div class="line"></div><div class="line">        mState.mRunPredictiveAnimations = false;</div><div class="line">        onExitLayoutOrScroll();</div><div class="line">        mLayout.mRequestedSimpleAnimations = false;</div><div class="line">        if (mRecycler.mChangedScrap != null) &#123;</div><div class="line">            mRecycler.mChangedScrap.clear();</div><div class="line">        &#125;</div><div class="line">        mViewInfoStore.clear();</div><div class="line">        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</div><div class="line">           //如果这个recyclerView的position区间是正确的，那么移动到当前的第一个位置 </div><div class="line">	   dispatchOnScrolled(0, 0);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
recyclerView的onLayout仅仅只是做了部分计算，对于其子item的计算托管给了layoutManager，下面我们来看看这个LayoutManager的计算，我们必须先了解一下这个layoutManager，它是一个抽象类，对于不同的实现类会有不同的实现，对于LinearLayoutManager和GridLayoutManager的实现就有很多不一样了。这里我们查看的是linearLayoutManager的源码，在看这个源码时我们先了解下其中的layout计算算法。这个源码中给我们标注出来的：</li>
</ul>
<ol>
<li>检查子item和其他变量，找到其中的anchor，anchor算是一个计算的锚点，指定的从哪个一个position开始进行计算。</li>
<li>从start方向开始填充，item从bottom开始出栈</li>
<li>从end方向开始填充，item从start开始出栈</li>
<li>通过滑动去满足要求。<br>下面我们来看看下面这张图的表示，这个图并非原创，在网上看到了，感觉画得还行<br><img src="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt=""><br>下面就是这个算法所对应的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"> public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">       //确认Layout方向，即orientation设置的方向</div><div class="line">ensureLayoutState();</div><div class="line">       mLayoutState.mRecycle = false;</div><div class="line">       // 真正的加载方向，因为linearLayoutManager有一个setReverse方法，这个会让整个recyclerView反向加载，所以需要通过设置的方向和这个方法值共同来判断</div><div class="line">       resolveShouldLayoutReverse();</div><div class="line">//初始化Anchor信息</div><div class="line">       mAnchorInfo.reset();</div><div class="line">//anchor方向</div><div class="line">       mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</div><div class="line">       // 计算anchor位置</div><div class="line">       updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</div><div class="line">       //LLM会有一个extra空间用来缓存item，可以用来进行预加载</div><div class="line">int extraForStart;</div><div class="line">       int extraForEnd;</div><div class="line">//我们可以重写getExtraLayoutSpac这个方法用来进行额外的显示空间，默认为0</div><div class="line">       final int extra = getExtraLayoutSpace(state);</div><div class="line">       //最近一次滑动的距离，大于0，表示向下滑动</div><div class="line">if (mLayoutState.mLastScrollDelta &gt;= 0) &#123;</div><div class="line">           extraForEnd = extra;</div><div class="line">           extraForStart = 0;</div><div class="line">       &#125; else &#123;</div><div class="line">           extraForStart = extra;</div><div class="line">           extraForEnd = 0;</div><div class="line">       &#125;</div><div class="line">       extraForStart += mOrientationHelper.getStartAfterPadding();</div><div class="line">       extraForEnd += mOrientationHelper.getEndPadding();</div><div class="line">       if (state.isPreLayout() &amp;&amp; mPendingScrollPosition != NO_POSITION &amp;&amp;</div><div class="line">               mPendingScrollPositionOffset != INVALID_OFFSET) &#123;</div><div class="line">    //如果是在预布局中，需要执行下面</div><div class="line">           final View existing = findViewByPosition(mPendingScrollPosition);</div><div class="line">           if (existing != null) &#123;</div><div class="line">               final int current;</div><div class="line">               final int upcomingOffset;</div><div class="line">               if (mShouldReverseLayout) &#123;</div><div class="line">                   current = mOrientationHelper.getEndAfterPadding() -</div><div class="line">                           mOrientationHelper.getDecoratedEnd(existing);</div><div class="line">                   upcomingOffset = current - mPendingScrollPositionOffset;</div><div class="line">               &#125; else &#123;</div><div class="line">                   current = mOrientationHelper.getDecoratedStart(existing)</div><div class="line">                           - mOrientationHelper.getStartAfterPadding();</div><div class="line">                   upcomingOffset = mPendingScrollPositionOffset - current;</div><div class="line">               &#125;</div><div class="line">               if (upcomingOffset &gt; 0) &#123;</div><div class="line">	    //额外滑动距离大于0，额外的空间需要加上计算之后的滑动距离</div><div class="line">                   extraForStart += upcomingOffset;</div><div class="line">               &#125; else &#123;</div><div class="line">                   extraForEnd -= upcomingOffset;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       int startOffset;</div><div class="line">       int endOffset;</div><div class="line">//判断这个锚点是否已经准备完毕。默认为空实现，只有在gridLayoutManager才需要复写</div><div class="line">       onAnchorReady(recycler, state, mAnchorInfo);</div><div class="line">//这个是关于layout的过程中缓存的计算，我们后面会详细的讲解这个函数</div><div class="line">       detachAndScrapAttachedViews(recycler);</div><div class="line">       mLayoutState.mIsPreLayout = state.isPreLayout();</div><div class="line">       if (mAnchorInfo.mLayoutFromEnd) &#123;</div><div class="line">    //如果是从start方向开始填充，更新LayoutState信息，这个是一个辅助layoutManager来管理滑动的类</div><div class="line">           updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForStart;</div><div class="line">    //在这个方法里面填充item</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           startOffset = mLayoutState.mOffset;</div><div class="line">           final int firstElement = mLayoutState.mCurrentPosition;</div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForEnd += mLayoutState.mAvailable;</div><div class="line">           &#125;</div><div class="line">           // 从end方向开始填充</div><div class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForEnd;</div><div class="line">           mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">           //在这个方法里面填充item</div><div class="line">    fill(recycler, mLayoutState, state, false);</div><div class="line">           endOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">	//底部没有足够的item用于填充满整个布局，此时再从顶部添加item进行填充	</div><div class="line">               extraForStart = mLayoutState.mAvailable;</div><div class="line">               updateLayoutStateToFillStart(firstElement, startOffset);</div><div class="line">               mLayoutState.mExtra = extraForStart;</div><div class="line">	fill(recycler, mLayoutState, state, false);</div><div class="line">               startOffset = mLayoutState.mOffset;</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">    //与上面的基本一致，只是因为start和end方向反了而已</div><div class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForEnd;</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           endOffset = mLayoutState.mOffset;</div><div class="line">           final int lastElement = mLayoutState.mCurrentPosition;</div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForStart += mLayoutState.mAvailable;</div><div class="line">           &#125;</div><div class="line">           // fill towards start</div><div class="line">           updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForStart;</div><div class="line">           mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           startOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForEnd = mLayoutState.mAvailable;</div><div class="line">               updateLayoutStateToFillEnd(lastElement, endOffset);</div><div class="line">               mLayoutState.mExtra = extraForEnd;</div><div class="line">               fill(recycler, mLayoutState, state, false);</div><div class="line">               endOffset = mLayoutState.mOffset;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (getChildCount() &gt; 0) &#123;</div><div class="line">    //对于不同的加载方向，计算偏移量</div><div class="line">           if (mShouldReverseLayout ^ mStackFromEnd) &#123;</div><div class="line">	startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">               fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">           &#125; else &#123;</div><div class="line">               int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">               fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</div><div class="line">       if (!state.isPreLayout()) &#123;</div><div class="line">           mPendingScrollPosition = NO_POSITION;</div><div class="line">           mPendingScrollPositionOffset = INVALID_OFFSET;</div><div class="line">           mOrientationHelper.onLayoutComplete();</div><div class="line">       &#125;</div><div class="line">       mLastStackFromEnd = mStackFromEnd;</div><div class="line">       mPendingSavedState = null;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
上面就是LinearLayoutManager的layout计算，我们来看看这个填充函数fill的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</div><div class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</div><div class="line">	 final int start = layoutState.mAvailable;</div><div class="line">	//最大偏移量就是scroll距离加上可达的距离</div><div class="line">        if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">            if (layoutState.mAvailable &lt; 0) &#123;</div><div class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</div><div class="line">            &#125;</div><div class="line">	    //在这里回收缓存不可见的item</div><div class="line">            recycleByLayoutState(recycler, layoutState);</div><div class="line">        &#125;</div><div class="line">	//剩余空间计算，可见的加上设置的extra空间再加上滑动所生成offset</div><div class="line">        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;</div><div class="line">        LayoutChunkResult layoutChunkResult = new LayoutChunkResult();</div><div class="line">        while (remainingSpace &gt; 0 &amp;&amp; layoutState.hasMore(state)) &#123;</div><div class="line">            layoutChunkResult.resetInternal();</div><div class="line">	    //通过layoutChunk计算大小距离，下面我们会简单的看下这个函数</div><div class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</div><div class="line">            if (layoutChunkResult.mFinished) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</div><div class="line">            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null</div><div class="line">                    || !state.isPreLayout()) &#123;</div><div class="line">               	//计算剩下的可用空间， </div><div class="line">		layoutState.mAvailable -= layoutChunkResult.mConsumed;</div><div class="line">                remainingSpace -= layoutChunkResult.mConsumed;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</div><div class="line">                if (layoutState.mAvailable &lt; 0) &#123;</div><div class="line">                    layoutState.mScrollingOffset += layoutState.mAvailable;</div><div class="line">                &#125;</div><div class="line">                recycleByLayoutState(recycler, layoutState);</div><div class="line">            &#125;</div><div class="line">            if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return start - layoutState.mAvailable;</div></pre></td></tr></table></figure>
我们可以看到在这个fill函数中，它将计算又交给了layoutChunk，我们现在看看layoutChunk这个函数的具体计算<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</div><div class="line">            LayoutState layoutState, LayoutChunkResult result) &#123;</div><div class="line">        //首先会尝试从scraplist里面获取view，如果这个position与我们当前需要显示的position一致，那么直接返回,否则，将会从几个缓存区中获取，获取缓存的view我们后面讲解</div><div class="line">	View view = layoutState.next(recycler);</div><div class="line">        if (view == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        LayoutParams params = (LayoutParams) view.getLayoutParams();</div><div class="line">        if (layoutState.mScrapList == null) &#123;</div><div class="line">	    //如果这个scraplist为空，那么这个view是需要显示的</div><div class="line">            if (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">                    == LayoutState.LAYOUT_START)) &#123;</div><div class="line">                addView(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                addView(view, 0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">	    //这个view是标记为invisible的</div><div class="line">            if (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">                    == LayoutState.LAYOUT_START)) &#123;</div><div class="line">                addDisappearingView(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                addDisappearingView(view, 0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	//计算margin值，用来进行排列</div><div class="line">        measureChildWithMargins(view, 0, 0);</div><div class="line">	//这个会计算当前view的decoration占用的位置和margin总值</div><div class="line">        result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</div><div class="line">        int left, top, right, bottom;</div><div class="line">        if (mOrientation == VERTICAL) &#123;</div><div class="line">            if (isLayoutRTL()) &#123;</div><div class="line">                right = getWidth() - getPaddingRight();</div><div class="line">                left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                left = getPaddingLeft();</div><div class="line">                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">            &#125;</div><div class="line">            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">	        bottom = layoutState.mOffset;</div><div class="line">                top = layoutState.mOffset - result.mConsumed;</div><div class="line">            &#125; else &#123;</div><div class="line">		//我们只分析垂直摆放，而且方向是初始从上至下的，那么top高度为当前的offset，bottom值为当前的offset加上前面计算的占用大小</div><div class="line">                top = layoutState.mOffset;</div><div class="line">                bottom = layoutState.mOffset + result.mConsumed;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            top = getPaddingTop();</div><div class="line">            bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line"></div><div class="line">            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">                right = layoutState.mOffset;</div><div class="line">                left = layoutState.mOffset - result.mConsumed;</div><div class="line">            &#125; else &#123;</div><div class="line">                left = layoutState.mOffset;</div><div class="line">                right = layoutState.mOffset + result.mConsumed;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	//为了能够正确的计算，我们还需要对子view进行layout计算。</div><div class="line">        layoutDecorated(view, left + params.leftMargin, top + params.topMargin,</div><div class="line">                right - params.rightMargin, bottom - params.bottomMargin);</div><div class="line">        &#125;</div><div class="line">        result.mFocusable = view.isFocusable();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
这就完成layout计算。</li>
</ol>
<h2 id="recyclerView滑动处理"><a href="#recyclerView滑动处理" class="headerlink" title="recyclerView滑动处理"></a>recyclerView滑动处理</h2><p>对于recyclerView的滑动，肯定是从我们的屏幕滑动去进行处理的。首先我们必须了解一下滑动事件的分发机制，对于这个分发机制，首先是从onDispatchTouchEvent传递，然后通过onInterceptTouchEvent判断是否拦截，如果拦截，这个事件就不会向下传递，而会传递的给自身的onTouchEvent去进行处理，如果想要了解详细的分发过程，google上有很多这个blog。我们直接通过其onInterceptTouchEvent阅读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">public boolean onInterceptTouchEvent(MotionEvent e) &#123;</div><div class="line">       if (mLayoutFrozen) &#123;</div><div class="line">           	//如果layout处于frozen状态，那么这个recyclerView是不会拦截处理事件的。</div><div class="line">	return false;</div><div class="line">       &#125;</div><div class="line">       if (dispatchOnItemTouchIntercept(e)) &#123;</div><div class="line">           //这里会判断是否有子item监听这个事件，如果有，则直接将事件让子item去进行处理</div><div class="line">    cancelTouch();</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (mLayout == null) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       final boolean canScrollHorizontally = mLayout.canScrollHorizontally();</div><div class="line">       final boolean canScrollVertically = mLayout.canScrollVertically();</div><div class="line"></div><div class="line">       if (mVelocityTracker == null) &#123;</div><div class="line">          //初始化速度检测器 </div><div class="line">   mVelocityTracker = VelocityTracker.obtain();</div><div class="line">       &#125;</div><div class="line">       mVelocityTracker.addMovement(e);</div><div class="line"></div><div class="line">       final int action = MotionEventCompat.getActionMasked(e);</div><div class="line">       final int actionIndex = MotionEventCompat.getActionIndex(e);</div><div class="line"></div><div class="line">       switch (action) &#123;</div><div class="line">           case MotionEvent.ACTION_DOWN:</div><div class="line">               if (mIgnoreMotionEventTillDown) &#123;</div><div class="line">                   mIgnoreMotionEventTillDown = false;</div><div class="line">               &#125;</div><div class="line">               mScrollPointerId = e.getPointerId(0);</div><div class="line">               mInitialTouchX = mLastTouchX = (int) (e.getX() + 0.5f);</div><div class="line">               mInitialTouchY = mLastTouchY = (int) (e.getY() + 0.5f);</div><div class="line">	</div><div class="line">	//SCROLL_STATE_SETTLING是处于自动滚动的状态</div><div class="line">               if (mScrollState == SCROLL_STATE_SETTLING) &#123;</div><div class="line">	   //下面这个方法是解决滑动冲突最经常用的一个方法，也就是requestDisallowInterceptTouchEvent，这个方法可以禁止父控件去拦截这个方法</div><div class="line">                   getParent().requestDisallowInterceptTouchEvent(true);</div><div class="line">	    //因为现在是actionDown事件，所以，scroll状态要开始变为dragging事件</div><div class="line">                   setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               //mark: 清空nested的偏移量</div><div class="line">               mNestedOffsets[0] = mNestedOffsets[1] = 0;</div><div class="line"></div><div class="line">	//初始化nestScroll方向</div><div class="line">               int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</div><div class="line">               if (canScrollHorizontally) &#123;</div><div class="line">                   nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</div><div class="line">               &#125;</div><div class="line">               if (canScrollVertically) &#123;</div><div class="line">                   nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</div><div class="line">               &#125;</div><div class="line">	//在这里开启nest滑动</div><div class="line">               startNestedScroll(nestedScrollAxis);</div><div class="line">               break;</div><div class="line"></div><div class="line">           case MotionEventCompat.ACTION_POINTER_DOWN:</div><div class="line">               mScrollPointerId = e.getPointerId(actionIndex);</div><div class="line">               mInitialTouchX = mLastTouchX = (int) (e.getX(actionIndex) + 0.5f);</div><div class="line">               mInitialTouchY = mLastTouchY = (int) (e.getY(actionIndex) + 0.5f);</div><div class="line">               break;</div><div class="line"></div><div class="line">          case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">               final int index = e.findPointerIndex(mScrollPointerId);</div><div class="line">	//获取滑动的point</div><div class="line">               if (index &lt; 0) &#123;</div><div class="line">                   Log.e(TAG, &quot;Error processing scroll; pointer index for id &quot; +</div><div class="line">                           mScrollPointerId + &quot; not found. Did any MotionEvents get skipped?&quot;);</div><div class="line">                   return false;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               final int x = (int) (e.getX(index) + 0.5f);</div><div class="line">               final int y = (int) (e.getY(index) + 0.5f);</div><div class="line">               if (mScrollState != SCROLL_STATE_DRAGGING) &#123;</div><div class="line">    		    //如果Move事件不是Dragging状态，那么down时一定处于idle状态</div><div class="line">                   final int dx = x - mInitialTouchX;</div><div class="line">                   final int dy = y - mInitialTouchY;</div><div class="line">                   boolean startScroll = false;</div><div class="line">                   if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</div><div class="line">                       mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1);</div><div class="line">                       startScroll = true;</div><div class="line">                   &#125;</div><div class="line">                   if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">                       mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1);</div><div class="line">                       startScroll = true;</div><div class="line">                   &#125;</div><div class="line">                   if (startScroll) &#123;</div><div class="line">                       setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; break;</div><div class="line"></div><div class="line">           case MotionEventCompat.ACTION_POINTER_UP: &#123;</div><div class="line">               onPointerUp(e);</div><div class="line">           &#125; break;</div><div class="line"></div><div class="line">           case MotionEvent.ACTION_UP: &#123;</div><div class="line">               mVelocityTracker.clear();</div><div class="line">	//关掉nestScroll</div><div class="line">               stopNestedScroll();</div><div class="line">           &#125; break;</div><div class="line"></div><div class="line">           case MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">               cancelTouch();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return mScrollState == SCROLL_STATE_DRAGGING;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>从上面的代码段中，我们可以看到，在InterceptTouchEvent中只是做了一些Scroll状态的切换，真正的事件处理是在onTouchEvent中处理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public boolean onTouchEvent(MotionEvent e) &#123;</div><div class="line">	...</div><div class="line">        final boolean canScrollHorizontally = mLayout.canScrollHorizontally();</div><div class="line">        final boolean canScrollVertically = mLayout.canScrollVertically();</div><div class="line"></div><div class="line">        if (mVelocityTracker == null) &#123;</div><div class="line">            mVelocityTracker = VelocityTracker.obtain();</div><div class="line">        &#125;</div><div class="line">        boolean eventAddedToVelocityTracker = false;</div><div class="line">	//复制一个事件，用于处理速度的处理</div><div class="line">        final MotionEvent vtev = MotionEvent.obtain(e);</div><div class="line">        final int action = MotionEventCompat.getActionMasked(e);</div><div class="line">        final int actionIndex = MotionEventCompat.getActionIndex(e);</div><div class="line"></div><div class="line">        if (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">             如果是Down事件，则将nest偏移量清空</div><div class="line">	     mNestedOffsets[0] = mNestedOffsets[1] = 0;</div><div class="line">        &#125;</div><div class="line">	/／对速度相关的处理事件进行设置起始位置</div><div class="line">        vtev.offsetLocation(mNestedOffsets[0], mNestedOffsets[1]);</div><div class="line"></div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                //这一部分操作基本和onInterceptTouchEvent中的一致</div><div class="line">		mScrollPointerId = e.getPointerId(0);</div><div class="line">                mInitialTouchX = mLastTouchX = (int) (e.getX() + 0.5f);</div><div class="line">                mInitialTouchY = mLastTouchY = (int) (e.getY() + 0.5f);</div><div class="line"></div><div class="line">                int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</div><div class="line">                if (canScrollHorizontally) &#123;</div><div class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</div><div class="line">                &#125;</div><div class="line">                if (canScrollVertically) &#123;</div><div class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</div><div class="line">                &#125;</div><div class="line">                startNestedScroll(nestedScrollAxis);</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEventCompat.ACTION_POINTER_DOWN: &#123;</div><div class="line">                mScrollPointerId = e.getPointerId(actionIndex);</div><div class="line">                mInitialTouchX = mLastTouchX = (int) (e.getX(actionIndex) + 0.5f);</div><div class="line">                mInitialTouchY = mLastTouchY = (int) (e.getY(actionIndex) + 0.5f);</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                final int index = e.findPointerIndex(mScrollPointerId);</div><div class="line">                if (index &lt; 0) &#123;</div><div class="line">                    Log.e(TAG, &quot;Error processing scroll; pointer index for id &quot; +</div><div class="line">                            mScrollPointerId + &quot; not found. Did any MotionEvents get skipped?&quot;);</div><div class="line">                    return false;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                final int x = (int) (e.getX(index) + 0.5f);</div><div class="line">                final int y = (int) (e.getY(index) + 0.5f);</div><div class="line">                //dy和dy就是我们计算的move事件的偏移量</div><div class="line">	        int dx = mLastTouchX - x;</div><div class="line">                int dy = mLastTouchY - y;</div><div class="line">		//dispatchNestedPreScroll，这个方法会计算parent，也就是这个recycler是否在nest滑动中需也要消费空间,也就是recyclerView也会移动，为true表示需要消费空间，消费值存放在mScrollConsumed和mScroollOffset中</div><div class="line">                if (dispatchNestedPreScroll(dx, dy, mScrollConsumed, mScrollOffset)) &#123;</div><div class="line">                    dx -= mScrollConsumed[0];</div><div class="line">                    dy -= mScrollConsumed[1];</div><div class="line">                    vtev.offsetLocation(mScrollOffset[0], mScrollOffset[1]);</div><div class="line">                    // 更新nest滑动的offset</div><div class="line">                    mNestedOffsets[0] += mScrollOffset[0];</div><div class="line">                    mNestedOffsets[1] += mScrollOffset[1];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (mScrollState != SCROLL_STATE_DRAGGING) &#123;</div><div class="line">                    //如果滑动状态不是Dragging，那么down时的状态一定是idle</div><div class="line">		    boolean startScroll = false;</div><div class="line">		    //计算真实的偏移量</div><div class="line">                    if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</div><div class="line">                        if (dx &gt; 0) &#123;</div><div class="line">                            dx -= mTouchSlop;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            dx += mTouchSlop;</div><div class="line">                        &#125;</div><div class="line">                        startScroll = true;</div><div class="line">                    &#125;</div><div class="line">                    if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">                        if (dy &gt; 0) &#123;</div><div class="line">                            dy -= mTouchSlop;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            dy += mTouchSlop;</div><div class="line">                        &#125;</div><div class="line">                        startScroll = true;</div><div class="line">                    &#125;</div><div class="line">                    if (startScroll) &#123;</div><div class="line">                        setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//如果此时已经是拖动状态</div><div class="line">                if (mScrollState == SCROLL_STATE_DRAGGING) &#123;</div><div class="line">                    //标记最后一次点击坐标为当前坐标减去nest滑动的偏移量</div><div class="line">		    mLastTouchX = x - mScrollOffset[0];</div><div class="line">                    mLastTouchY = y - mScrollOffset[1];</div><div class="line">		    //在这里进行内部item的滑动处理，这个方法后面我们会详细的阅读</div><div class="line">                    if (scrollByInternal(</div><div class="line">                            canScrollHorizontally ? dx : 0,</div><div class="line">                            canScrollVertically ? dy : 0,</div><div class="line">                            vtev)) &#123;</div><div class="line">                        getParent().requestDisallowInterceptTouchEvent(true);</div><div class="line">                    &#125;</div><div class="line">                    if (mGapWorker != null &amp;&amp; (dx != 0 || dy != 0)) &#123;</div><div class="line">                        mGapWorker.postFromTraversal(this, dx, dy);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEventCompat.ACTION_POINTER_UP: &#123;</div><div class="line">                onPointerUp(e);</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_UP: &#123;</div><div class="line">		//手指离开屏幕时，触发这个事件，</div><div class="line">                mVelocityTracker.addMovement(vtev);</div><div class="line">                eventAddedToVelocityTracker = true;</div><div class="line">		//计算当前的速度，1000速度的单位，mMaxFlingVelocity是速度的最大值</div><div class="line">                mVelocityTracker.computeCurrentVelocity(1000, mMaxFlingVelocity);</div><div class="line">                final float xvel = canScrollHorizontally ?</div><div class="line">                        -VelocityTrackerCompat.getXVelocity(mVelocityTracker, mScrollPointerId) : 0;</div><div class="line">                final float yvel = canScrollVertically ?</div><div class="line">                        -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : 0;</div><div class="line">        	//如果存在自滑动的速度，就进行fling操作，否则直接设置当前状态为idle状态，这个fling方法后面我们也会详细的阅读。       </div><div class="line">        	 if (!((xvel != 0 || yvel != 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</div><div class="line">                    setScrollState(SCROLL_STATE_IDLE);</div><div class="line">                &#125;</div><div class="line">                resetTouch();</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">                cancelTouch();</div><div class="line">            &#125; break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!eventAddedToVelocityTracker) &#123;</div><div class="line">            mVelocityTracker.addMovement(vtev);</div><div class="line">        &#125;</div><div class="line">        vtev.recycle();</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>实际上，在这个onTouchEvent里面滑动处理主要就做了两件事情，也就是scrollByInternal和fling这两个操作，scrollByInternal是在我们的move事件去实时处理的，而fling事件是在我们的up事件时，如果存在自滑动的速度，那么就会执行这个方法。下面我们先看看scrollByInternal这个item的滑动处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">boolean scrollByInternal(int x, int y, MotionEvent ev) &#123;</div><div class="line">       int unconsumedX = 0, unconsumedY = 0;</div><div class="line">       int consumedX = 0, consumedY = 0;</div><div class="line">//在这里会判断layout操作是否执行完毕，否则需要等待。</div><div class="line">       consumePendingUpdateOperations();</div><div class="line">//adapter不为空，在里面真正的执行滑动</div><div class="line">       if (mAdapter != null) &#123;</div><div class="line">           eatRequestLayout();</div><div class="line">           onEnterLayoutOrScroll();</div><div class="line">           TraceCompat.beginSection(TRACE_SCROLL_TAG);</div><div class="line">    //内部实际上调用了mLayout的滑动方法，会返回滑动消耗的距离</div><div class="line">           if (x != 0) &#123;</div><div class="line">               consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</div><div class="line">               unconsumedX = x - consumedX;</div><div class="line">           &#125;</div><div class="line">           if (y != 0) &#123;</div><div class="line">               consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</div><div class="line">               unconsumedY = y - consumedY;</div><div class="line">           &#125;</div><div class="line">           TraceCompat.endSection();</div><div class="line">           repositionShadowingViews();</div><div class="line">           onExitLayoutOrScroll();</div><div class="line">           resumeRequestLayout(false);</div><div class="line">       &#125;</div><div class="line">       if (!mItemDecorations.isEmpty()) &#123;</div><div class="line">           invalidate();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</div><div class="line">           // 通过滑动消耗的距离和未消耗完的距离进行更新最后一次点击的位置</div><div class="line">           mLastTouchX -= mScrollOffset[0];</div><div class="line">           mLastTouchY -= mScrollOffset[1];</div><div class="line">           if (ev != null) &#123;</div><div class="line">               ev.offsetLocation(mScrollOffset[0], mScrollOffset[1]);</div><div class="line">           &#125;</div><div class="line">           mNestedOffsets[0] += mScrollOffset[0];</div><div class="line">           mNestedOffsets[1] += mScrollOffset[1];</div><div class="line">       &#125; else if (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</div><div class="line">           if (ev != null) &#123;</div><div class="line">               pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);</div><div class="line">           &#125;</div><div class="line">           considerReleasingGlowsOnScroll(x, y);</div><div class="line">       &#125;</div><div class="line">       if (consumedX != 0 || consumedY != 0) &#123;</div><div class="line">            //通知滑动事件，也就是我们所监听的onscrollChangeListener</div><div class="line">     dispatchOnScrolled(consumedX, consumedY);</div><div class="line">       &#125;</div><div class="line">//在这里进行重新绘制</div><div class="line">       if (!awakenScrollBars()) &#123;</div><div class="line">           invalidate();</div><div class="line">       &#125;</div><div class="line">       return consumedX != 0 || consumedY != 0;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在这里，我们又要重申一句话，recyclerView并不负责子item的摆放，这也就是为什么在滑动处理事件里面又将滑动处理交给了对应的layoutManager去计算，我们来看看LinearLayoutManager的scrollVerticalBy方法的调用链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,</div><div class="line">            RecyclerView.State state) &#123;</div><div class="line">        if (mOrientation == HORIZONTAL) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        return scrollBy(dy, recycler, state);</div><div class="line">    &#125;</div><div class="line">=======&gt;调用到了scrollBy</div><div class="line">int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">        if (getChildCount() == 0 || dy == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mRecycle = true;</div><div class="line">	//确保LayoutSate存在，不存在就新建一个</div><div class="line">        ensureLayoutState();</div><div class="line">	//在这里计算填充方向</div><div class="line">        final int layoutDirection = dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</div><div class="line">        final int absDy = Math.abs(dy);</div><div class="line">	//更新layoutState的状态，这个实际上就是进行计算滑动距离	</div><div class="line">        updateLayoutState(layoutDirection, absDy, true, state);</div><div class="line">	//计算消费的空间</div><div class="line">        final int consumed = mLayoutState.mScrollingOffset</div><div class="line">                + fill(recycler, mLayoutState, state, false);</div><div class="line">        if (consumed &lt; 0) &#123;</div><div class="line">            if (DEBUG) &#123;</div><div class="line">                Log.d(TAG, &quot;Don&apos;t have any more elements to scroll&quot;);</div><div class="line">            &#125;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">	//计算真正的滑动距离</div><div class="line">        final int scrolled = absDy &gt; consumed ? layoutDirection * consumed : dy;</div><div class="line">        mOrientationHelper.offsetChildren(-scrolled);</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            Log.d(TAG, &quot;scroll req: &quot; + dy + &quot; scrolled: &quot; + scrolled);</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mLastScrollDelta = scrolled;</div><div class="line">        return scrolled;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>真正的填充函数fill我们之前已经介绍过了，忘记的可以往前翻。我们在看看updateLayoutState这个函数，这个函数用于更新当前的layoutState状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">private void updateLayoutState(int layoutDirection, int requiredSpace,</div><div class="line">            boolean canUseExistingSpace, RecyclerView.State state) &#123;</div><div class="line">        mLayoutState.mInfinite = resolveIsInfinite();</div><div class="line">	//计算额外的缓存空间</div><div class="line">        mLayoutState.mExtra = getExtraLayoutSpace(state);</div><div class="line">        mLayoutState.mLayoutDirection = layoutDirection;</div><div class="line">        int scrollingOffset;</div><div class="line">	//下面是重点计算的scroll偏移量</div><div class="line">        if (layoutDirection == LayoutState.LAYOUT_END) &#123;</div><div class="line">            //如果是向上滑动，则要从底部填充</div><div class="line">	    //额外的缓存空间也要加上padding值</div><div class="line">	    mLayoutState.mExtra += mOrientationHelper.getEndPadding();</div><div class="line">	    //获取当前最靠近底部的一个子item</div><div class="line">            final View child = getChildClosestToEnd();</div><div class="line">	    //这里计算当前的添加方向，如果没有设置reverseLayout的话，默认添加到Tail，也就是尾部，值为1</div><div class="line">            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD</div><div class="line">                    : LayoutState.ITEM_DIRECTION_TAIL;</div><div class="line">	    //计算当前要显示的位置，也就是前面最靠近底部的item加上前面的itemDirection，也就是当前position了。</div><div class="line">            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;</div><div class="line">            //计算最后一个item的距离底部的偏移量</div><div class="line">	    mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);</div><div class="line">            //计算在没有添加子item的时候，我们可以滑动的偏移量</div><div class="line">	    scrollingOffset = mOrientationHelper.getDecoratedEnd(child)</div><div class="line">                    - mOrientationHelper.getEndAfterPadding();</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line">	    //这个计算和上面的类似</div><div class="line">            final View child = getChildClosestToStart();</div><div class="line">            mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();</div><div class="line">            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL</div><div class="line">                    : LayoutState.ITEM_DIRECTION_HEAD;</div><div class="line">            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;</div><div class="line">            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);</div><div class="line">            scrollingOffset = -mOrientationHelper.getDecoratedStart(child)</div><div class="line">                    + mOrientationHelper.getStartAfterPadding();</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mAvailable = requiredSpace;</div><div class="line">        if (canUseExistingSpace) &#123;</div><div class="line">     	      //计算生剩余的可用空间</div><div class="line">	      mLayoutState.mAvailable -= scrollingOffset;</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mScrollingOffset = scrollingOffset;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>通过这个方法计算了大部分需要的值之后，然后通过fill函数去进行填充新view和回收旧的view，这样，一个move操作就完成啦。下面看看另外一个处理自滑动的fling函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">public boolean fling(int velocityX, int velocityY) &#123;</div><div class="line">	...</div><div class="line">        if (velocityX == 0 &amp;&amp; velocityY == 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (!dispatchNestedPreFling(velocityX, velocityY)) &#123;</div><div class="line">	    //如果parent不消费这个fling事件，那么就需要子item来处理</div><div class="line">            final boolean canScroll = canScrollHorizontal || canScrollVertical;</div><div class="line">            dispatchNestedFling(velocityX, velocityY, canScroll);</div><div class="line">	    //onFlingListener是24.2版本添加的</div><div class="line">            if (mOnFlingListener != null &amp;&amp; mOnFlingListener.onFling(velocityX, velocityY)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (canScroll) &#123;</div><div class="line">		//如果可以滑动，进行滑动处理</div><div class="line">                velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity));</div><div class="line">                velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity));</div><div class="line">                mViewFlinger.fling(velocityX, velocityY);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=====》mViewFLinger.fling</div><div class="line">public void fling(int velocityX, int velocityY) &#123;</div><div class="line">	    //标记为settling状态，也就是自动滚动状态</div><div class="line">            setScrollState(SCROLL_STATE_SETTLING);</div><div class="line">            mLastFlingX = mLastFlingY = 0;</div><div class="line">            mScroller.fling(0, 0, velocityX, velocityY,</div><div class="line">                    Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);</div><div class="line">	  //计算完自滑动距离之后，通过post方法去执行移动。  </div><div class="line">          postOnAnimation();</div><div class="line">&#125;</div><div class="line">=====&gt; mScroller.fling</div><div class="line">public void fling(int startX, int startY, int velocityX, int velocityY,</div><div class="line">            int minX, int maxX, int minY, int maxY) &#123;</div><div class="line">        mScroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY);</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line">public void fling(int startX, int startY, int velocityX, int velocityY,</div><div class="line">            int minX, int maxX, int minY, int maxY) &#123;</div><div class="line">        fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, 0, 0);</div><div class="line">    &#125;</div><div class="line">====&gt;</div><div class="line">public void fling(int startX, int startY, int velocityX, int velocityY,</div><div class="line">            int minX, int maxX, int minY, int maxY, int overX, int overY) &#123;</div><div class="line">        // 滚动处理</div><div class="line">        if (mFlywheel &amp;&amp; !isFinished()) &#123;</div><div class="line">            float oldVelocityX = mScrollerX.mCurrVelocity;</div><div class="line">            float oldVelocityY = mScrollerY.mCurrVelocity;</div><div class="line">	    //速度不为0时，速度就要进行变化</div><div class="line">	    //signum函数就是一个分段函数，等于0，返回0，大于0，返回1，小于0，返回-1</div><div class="line">            if (Math.signum(velocityX) == Math.signum(oldVelocityX) &amp;&amp;</div><div class="line">                    Math.signum(velocityY) == Math.signum(oldVelocityY)) &#123;</div><div class="line">                velocityX += oldVelocityX;</div><div class="line">                velocityY += oldVelocityY;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mMode = FLING_MODE;</div><div class="line">	//在这里进行滑动</div><div class="line">        mScrollerX.fling(startX, velocityX, minX, maxX, overX);</div><div class="line">        mScrollerY.fling(startY, velocityY, minY, maxY, overY);</div><div class="line">    &#125;</div><div class="line">======&gt;我们只看Y方向的滑动</div><div class="line">void fling(int start, int velocity, int min, int max, int over) &#123;</div><div class="line">            mOver = over;</div><div class="line">            mFinished = false;</div><div class="line">            mCurrVelocity = mVelocity = velocity;</div><div class="line">            mDuration = mSplineDuration = 0;</div><div class="line">            mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">            mCurrentPosition = mStart = start;</div><div class="line"></div><div class="line">            if (start &gt; max || start &lt; min) &#123;</div><div class="line">                startAfterEdge(start, min, max, velocity);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">	</div><div class="line">            mState = SPLINE;</div><div class="line">            double totalDistance = 0.0;</div><div class="line"></div><div class="line">            if (velocity != 0) &#123;</div><div class="line">		//计算曲线速度下降到0的时间，是一个对数函数</div><div class="line">                mDuration = mSplineDuration = getSplineFlingDuration(velocity);</div><div class="line">		//计算速度将为0的总距离</div><div class="line">                totalDistance = getSplineFlingDistance(velocity);</div><div class="line">            &#125;</div><div class="line">	    //总距离有正负方向</div><div class="line">            mSplineDistance = (int) (totalDistance * Math.signum(velocity));</div><div class="line">            //mFinal为终点位置</div><div class="line">	    mFinal = start + mSplineDistance;</div><div class="line"></div><div class="line">            // 如果终点位置最小的距离，那么调整终点位置为最小的距离</div><div class="line">            if (mFinal &lt; min) &#123;</div><div class="line">                adjustDuration(mStart, mFinal, min);</div><div class="line">                mFinal = min;</div><div class="line">            &#125;</div><div class="line">		</div><div class="line">            if (mFinal &gt; max) &#123;</div><div class="line">                adjustDuration(mStart, mFinal, max);</div><div class="line">                mFinal = max;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>在这个fling调用链中，其实最终的这个方法也只是进行计算而已，实际上这个相当于时一个动画，计算出速度降为0的时间就是动画执行的时间，速度降为0的时需要移动的总距离就是动画移动的总距离，SplineOverScroller就是这个动画的实体，它里面包含了执行动画所需的参数，动画的执行就和属性动画ValueAnimator十分类似，在每次调用computerScrollOffset方法时，就会调用update方法去更新动画的实时参数。我们看看最开始的postOnAmation，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void postOnAnimation() &#123;</div><div class="line">            if (mEatRunOnAnimationRequest) &#123;</div><div class="line">                mReSchedulePostAnimationCallback = true;</div><div class="line">            &#125; else &#123;</div><div class="line">                removeCallbacks(this);</div><div class="line">                ViewCompat.postOnAnimation(RecyclerView.this, this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>在默认的延迟时间到了之后，就会执行自身的run方法，我们来看看这个run方法的复杂处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">            if (mLayout == null) &#123;</div><div class="line">                stop();</div><div class="line">                return; // no layout, cannot scroll.</div><div class="line">            &#125;</div><div class="line">	    //此时正在执行自动滚动动画，关掉其他自滚动的请求</div><div class="line">            disableRunOnAnimationRequests();</div><div class="line">	    //等待layout操作</div><div class="line">            consumePendingUpdateOperations();</div><div class="line">            // 将这个scroller存储为局部变量，以防它后面有变化</div><div class="line">            final ScrollerCompat scroller = mScroller;</div><div class="line">            final SmoothScroller smoothScroller = mLayout.mSmoothScroller;</div><div class="line">            if (scroller.computeScrollOffset()) &#123;</div><div class="line">		//计算滑动的偏移量</div><div class="line">                final int x = scroller.getCurrX();</div><div class="line">                final int y = scroller.getCurrY();</div><div class="line">                final int dx = x - mLastFlingX;</div><div class="line">                final int dy = y - mLastFlingY;</div><div class="line">                int hresult = 0;</div><div class="line">                int vresult = 0;</div><div class="line">                mLastFlingX = x;</div><div class="line">                mLastFlingY = y;</div><div class="line">                int overscrollX = 0, overscrollY = 0;</div><div class="line">                if (mAdapter != null) &#123;</div><div class="line">                    eatRequestLayout();</div><div class="line">                    onEnterLayoutOrScroll();</div><div class="line">                    TraceCompat.beginSection(TRACE_SCROLL_TAG);</div><div class="line">		    //滑动item处理交给layout执行,通过计算offset处理添加View和回收View</div><div class="line">                    if (dx != 0) &#123;</div><div class="line">                        hresult = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</div><div class="line">                        overscrollX = dx - hresult;</div><div class="line">                    &#125;</div><div class="line">                    if (dy != 0) &#123;</div><div class="line">                        vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</div><div class="line">                        overscrollY = dy - vresult;</div><div class="line">                    &#125;</div><div class="line">                    TraceCompat.endSection();</div><div class="line">                    repositionShadowingViews();</div><div class="line"></div><div class="line">                    onExitLayoutOrScroll();</div><div class="line">                    resumeRequestLayout(false);</div><div class="line">		    //smoothScroller来执行滚动动画</div><div class="line">                    if (smoothScroller != null &amp;&amp; !smoothScroller.isPendingInitialRun() &amp;&amp;</div><div class="line">                            smoothScroller.isRunning()) &#123;</div><div class="line">                        final int adapterSize = mState.getItemCount();</div><div class="line">                        if (adapterSize == 0) &#123;</div><div class="line">                            smoothScroller.stop();</div><div class="line">                        &#125; else if (smoothScroller.getTargetPosition() &gt;= adapterSize) &#123;</div><div class="line">                            smoothScroller.setTargetPosition(adapterSize - 1);</div><div class="line">                            smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</div><div class="line">                        &#125; else &#123;</div><div class="line">			    //在onAnimation会开启scroll动画</div><div class="line">                            smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//刷新ui</div><div class="line">                if (!mItemDecorations.isEmpty()) &#123;</div><div class="line">                    invalidate();</div><div class="line">                &#125;</div><div class="line">                if (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</div><div class="line">                    considerReleasingGlowsOnScroll(dx, dy);</div><div class="line">                &#125;</div><div class="line">                if (overscrollX != 0 || overscrollY != 0) &#123;</div><div class="line">             	    //获取当前的速度</div><div class="line">	            final int vel = (int) scroller.getCurrVelocity();</div><div class="line"></div><div class="line">                    int velX = 0;</div><div class="line">                    if (overscrollX != x) &#123;</div><div class="line">                        velX = overscrollX &lt; 0 ? -vel : overscrollX &gt; 0 ? vel : 0;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    int velY = 0;</div><div class="line">                    if (overscrollY != y) &#123;</div><div class="line">                        velY = overscrollY &lt; 0 ? -vel : overscrollY &gt; 0 ? vel : 0;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</div><div class="line">                        absorbGlows(velX, velY);</div><div class="line">                    &#125;</div><div class="line">                    if ((velX != 0 || overscrollX == x || scroller.getFinalX() == 0) &amp;&amp;</div><div class="line">                            (velY != 0 || overscrollY == y || scroller.getFinalY() == 0)) &#123;</div><div class="line">               		 //如果终点坐标为0，那么停止animation</div><div class="line">		         scroller.abortAnimation();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (hresult != 0 || vresult != 0) &#123;</div><div class="line">                    dispatchOnScrolled(hresult, vresult);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!awakenScrollBars()) &#123;</div><div class="line">                    invalidate();</div><div class="line">                &#125;</div><div class="line">		</div><div class="line">		//是否占用空间</div><div class="line">                final boolean fullyConsumedVertical = dy != 0 &amp;&amp; mLayout.canScrollVertically()</div><div class="line">                        &amp;&amp; vresult == dy;</div><div class="line">                final boolean fullyConsumedHorizontal = dx != 0 &amp;&amp; mLayout.canScrollHorizontally()</div><div class="line">                        &amp;&amp; hresult == dx;</div><div class="line">                final boolean fullyConsumedAny = (dx == 0 &amp;&amp; dy == 0) || fullyConsumedHorizontal</div><div class="line">                        || fullyConsumedVertical;</div><div class="line">		</div><div class="line">		//如果没有占用空间，而且滑动已经结束了</div><div class="line">                if (scroller.isFinished() || !fullyConsumedAny) &#123;</div><div class="line">                    setScrollState(SCROLL_STATE_IDLE);</div><div class="line">                    if (ALLOW_THREAD_GAP_WORK) &#123;</div><div class="line">                        mPrefetchRegistry.clearPrefetchPositions();</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    postOnAnimation();</div><div class="line">                    if (mGapWorker != null) &#123;</div><div class="line">                        mGapWorker.postFromTraversal(RecyclerView.this, dx, dy);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (smoothScroller != null) &#123;</div><div class="line">                if (smoothScroller.isPendingInitialRun()) &#123;</div><div class="line">                    smoothScroller.onAnimation(0, 0);</div><div class="line">                &#125;</div><div class="line">                if (!mReSchedulePostAnimationCallback) &#123;</div><div class="line">                    smoothScroller.stop(); //stop if it does not trigger any scroll</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    //执行结束后开启处理animation请求</div><div class="line">            enableRunOnAnimationRequests();</div><div class="line">        &#125;</div><div class="line">=====&gt;onAnimation</div><div class="line">private void onAnimation(int dx, int dy) &#123;</div><div class="line">            final RecyclerView recyclerView = mRecyclerView;</div><div class="line">            if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION || recyclerView == null) &#123;</div><div class="line">                stop();</div><div class="line">            &#125;</div><div class="line">            mPendingInitialRun = false;</div><div class="line">            if (mTargetView != null) &#123;</div><div class="line">                if (getChildPosition(mTargetView) == mTargetPosition) &#123;</div><div class="line">                    onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction);</div><div class="line">                    mRecyclingAction.runIfNecessary(recyclerView);</div><div class="line">                    stop();</div><div class="line">                &#125; else &#123;</div><div class="line">                    Log.e(TAG, &quot;Passed over target position while smooth scrolling.&quot;);</div><div class="line">                    mTargetView = null;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (mRunning) &#123;</div><div class="line">                onSeekTargetStep(dx, dy, recyclerView.mState, mRecyclingAction);</div><div class="line">                boolean hadJumpTarget = mRecyclingAction.hasJumpTarget();</div><div class="line">                //通过下面这个方法开启startScroll,内部会调用postAnimation循环调用动画，直到移动到目标位置或速度为0	</div><div class="line">	        mRecyclingAction.runIfNecessary(recyclerView);</div><div class="line">                if (hadJumpTarget) &#123;</div><div class="line">                    //判断是否移动到目标位置</div><div class="line">		    if (mRunning) &#123;</div><div class="line">                        mPendingInitialRun = true;</div><div class="line">                        recyclerView.mViewFlinger.postOnAnimation();</div><div class="line">                    &#125; else &#123;</div><div class="line">                        stop(); // done</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>对于smoothScroller和scroller这两种滚动方式，我们必须要有区分，scroller的移动是没有渐变过程的，对于一个移动，就是直接从start位置变化到我们设置的终点位置，而smoothScroller是不一样的，它对于移动会用一个变化的过程，例如linearLayoutmanager所用的scroll就用了Linearinterpolator，做一个匀速的变化过程。上面就是一个recyclerView的滚动全过程.</p>
<h2 id="recyclerView-缓存处理"><a href="#recyclerView-缓存处理" class="headerlink" title="recyclerView 缓存处理"></a>recyclerView 缓存处理</h2><p>在了解了recyclerView的滚动全过程之后，我们最后来阅读下recyclerView的缓存机制，也就是为什么recyclerView会优于listView的最主要原因。首先通过上一部分的滑动处理来进行阅读，即在scrollBy函数中调用fill函数，里面通过recycleByLayoutState回收不显示的View，通过layoutChunk从缓存中读取即将显示的View。那么回收和复用的过程究竟是如何呢？我们从源码中阅读，当然，首先应该从回收的地方阅读起，没有回收，哪里能复用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123;</div><div class="line">        if (!layoutState.mRecycle || layoutState.mInfinite) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">	//通过判读现在加载的方向来确定回收的方向，如果从start方向加载，那么就应该从end方向回收，否则相反</div><div class="line">        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</div><div class="line">        &#125; else &#123;</div><div class="line">            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=====&gt; recycleViewsFromEnd</div><div class="line">private void recycleViewsFromEnd(RecyclerView.Recycler recycler, int dt) &#123;</div><div class="line">     	//geChildCount获取的仅仅只是界面显示的子item数量</div><div class="line">        final int childCount = getChildCount();</div><div class="line">        ...</div><div class="line">	//计算最后一个item距离底部的距离减去需要滑动的距离，就是此时回收的总距离</div><div class="line">	final int limit = mOrientationHelper.getEnd() - dt;</div><div class="line">        if (mShouldReverseLayout) &#123;</div><div class="line">	    //通常不会设置reverse，所以我们从下面的else阅读</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                View child = getChildAt(i);</div><div class="line">                if (mOrientationHelper.getDecoratedStart(child) &lt; limit</div><div class="line">                        || mOrientationHelper.getTransformedStartWithDecoration(child) &lt; limit) &#123;</div><div class="line">                    // stop here</div><div class="line">                    recycleChildren(recycler, 0, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">	    //从最后一个子item开始进行回收</div><div class="line">            for (int i = childCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                View child = getChildAt(i);</div><div class="line">		//计算回收区间</div><div class="line">                if (mOrientationHelper.getDecoratedStart(child) &lt; limit</div><div class="line">                        || mOrientationHelper.getTransformedStartWithDecoration(child) &lt; limit) &#123;</div><div class="line">                    // 进行回收</div><div class="line">                    recycleChildren(recycler, childCount - 1, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=====&gt;recyclerChildren</div><div class="line">private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) &#123;</div><div class="line">        if (startIndex == endIndex) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            Log.d(TAG, &quot;Recycling &quot; + Math.abs(startIndex - endIndex) + &quot; items&quot;);</div><div class="line">        &#125;</div><div class="line">        if (endIndex &gt; startIndex) &#123;</div><div class="line">	    //逐一回收</div><div class="line">            for (int i = endIndex - 1; i &gt;= startIndex; i--) &#123;</div><div class="line">                removeAndRecycleViewAt(i, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int i = startIndex; i &gt; endIndex; i--) &#123;</div><div class="line">                removeAndRecycleViewAt(i, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=====&gt;removeAndRecycleViewAt</div><div class="line">public void removeAndRecycleViewAt(int index, Recycler recycler) &#123;</div><div class="line">            final View view = getChildAt(index);</div><div class="line">            //移除这个View</div><div class="line">	    removeViewAt(index);</div><div class="line">	    //回收View</div><div class="line">            recycler.recycleView(view);</div><div class="line">        &#125;</div><div class="line">=====&gt;recycleView</div><div class="line"> public void recycleView(View view) &#123;</div><div class="line">            //获取这个View对应的ViewHolder</div><div class="line">	    ViewHolder holder = getChildViewHolderInt(view);</div><div class="line">            if (holder.isTmpDetached()) &#123;</div><div class="line">	        //如果这个holder被被标记为临时移除，那么首先从DetachedView中移除</div><div class="line">                removeDetachedView(view, false);</div><div class="line">            &#125;</div><div class="line">            if (holder.isScrap()) &#123;</div><div class="line">		//如果这个holder已经在scrap缓存里面了，那么从scrap列表中移除，scrap</div><div class="line">                holder.unScrap();</div><div class="line">            &#125; else if (holder.wasReturnedFromScrap())&#123;</div><div class="line">		//如果这个Viewholder标记为将会在scrap中重用，在移除时应该清除这个标记</div><div class="line">                holder.clearReturnedFromScrapFlag();</div><div class="line">            &#125;</div><div class="line">            recycleViewHolderInternal(holder);</div><div class="line">        &#125;</div><div class="line">=====&gt;recycleViewHolderInternal</div><div class="line">void recycleViewHolderInternal(ViewHolder holder) &#123;</div><div class="line">            ...</div><div class="line">            boolean cached = false;</div><div class="line">            boolean recycled = false;</div><div class="line">            ...</div><div class="line">	    if (forceRecycle || holder.isRecyclable()) &#123;</div><div class="line">                if (mViewCacheMax &gt; 0</div><div class="line">                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</div><div class="line">                                | ViewHolder.FLAG_REMOVED</div><div class="line">                                | ViewHolder.FLAG_UPDATE</div><div class="line">                                | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</div><div class="line">		    //先移除最老的mcacheView，默认大小为2</div><div class="line">                    int cachedViewSize = mCachedViews.size();</div><div class="line">                    if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</div><div class="line">                        recycleCachedViewAt(0);</div><div class="line">                        cachedViewSize--;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    int targetCacheIndex = cachedViewSize;</div><div class="line">                    if (ALLOW_THREAD_GAP_WORK</div><div class="line">                            &amp;&amp; cachedViewSize &gt; 0</div><div class="line">                            &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;</div><div class="line">                        int cacheIndex = cachedViewSize - 1;</div><div class="line">                        while (cacheIndex &gt;= 0) &#123;</div><div class="line">                            int cachedPos = mCachedViews.get(cacheIndex).mPosition;</div><div class="line">                            if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;</div><div class="line">                     		   //如果有被预加载的position，那么直接添加到这个位置</div><div class="line">			           break;</div><div class="line">                            &#125;</div><div class="line">                            cacheIndex--;</div><div class="line">                        &#125;</div><div class="line">                        targetCacheIndex = cacheIndex + 1;</div><div class="line">                    &#125;</div><div class="line">                    mCachedViews.add(targetCacheIndex, holder);</div><div class="line">                    cached = true;</div><div class="line">                &#125;</div><div class="line">		//如果没有添加到cache里面，那么直接回收到Pool中</div><div class="line">                if (!cached) &#123;</div><div class="line">                    addViewHolderToRecycledViewPool(holder, true);</div><div class="line">                    recycled = true;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">            ...</div><div class="line">	    //在动画没执行完时，我们有可能会出现回收失败的情况，所以需要再进行移除</div><div class="line">	    mViewInfoStore.removeViewHolder(holder);</div><div class="line">            if (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123;</div><div class="line">                holder.mOwnerRecyclerView = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">======&gt;recycleCachedViewAt</div><div class="line">void recycleCachedViewAt(int cachedViewIndex) &#123;</div><div class="line">            ...</div><div class="line">	    //获取这个cacheView中对应位置的ViewHolder</div><div class="line">	    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);</div><div class="line">            ...</div><div class="line">	    //添加到RecyclerViewPool</div><div class="line">	    addViewHolderToRecycledViewPool(viewHolder, true);</div><div class="line">            //移除cacheView中的这个ViewHolder</div><div class="line">	    mCachedViews.remove(cachedViewIndex);</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>通过这个回收时的过程，我们可以看到有两个缓存的列表，分别是mCacheViews和recyclerViewHolderPool，首先会缓存到mCacheViews中，然后以lru的方式将最先缓存的Viewholder移到pool中缓存。我们接下来看看复用机制,入口是layoutChunk的next函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">View next(RecyclerView.Recycler recycler) &#123;</div><div class="line">            if (mScrapList != null) &#123;</div><div class="line">		//如果scrapList非空，直接从scrapList中进行复用</div><div class="line">		//我们必须了解下这个mScrapList的含义,这个并不是一个缓存列表,这个是一个不可以修改的可见的viewHolder列表，只有在onLayoutChild的过程中才会是非空的，在我们普通的滑动并不会非空。</div><div class="line">                return nextViewFromScrapList();</div><div class="line">            &#125;</div><div class="line">	    //真正的从缓存中复用</div><div class="line">            final View view = recycler.getViewForPosition(mCurrentPosition);</div><div class="line">            mCurrentPosition += mItemDirection;</div><div class="line">            return view;</div><div class="line">        &#125;</div><div class="line">======&gt;nextViewFromScrapList</div><div class="line">private View nextViewFromScrapList() &#123;</div><div class="line">            final int size = mScrapList.size();</div><div class="line">            for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">                final View view = mScrapList.get(i).itemView;</div><div class="line">                final LayoutParams lp = (LayoutParams) view.getLayoutParams();</div><div class="line">                if (lp.isItemRemoved()) &#123;</div><div class="line">		    //如果这个view被标记为移除</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">		//如果这个View的position和当前要显示的position是一致的，将这个view返回</div><div class="line">                if (mCurrentPosition == lp.getViewLayoutPosition()) &#123;</div><div class="line">                    assignPositionFromScrapList(view);</div><div class="line">                    return view;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">=======&gt;recycler.getViewForPosition</div><div class="line">public View getViewForPosition(int position) &#123;</div><div class="line">            return getViewForPosition(position, false);</div><div class="line">        &#125;</div><div class="line">=====&gt;getViewForPosition(position, false)</div><div class="line">View getViewForPosition(int position, boolean dryRun) &#123;</div><div class="line">            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</div><div class="line">        &#125;</div><div class="line">====&gt;tryGetViewHolderForPositionByDeadline</div><div class="line"> ViewHolder tryGetViewHolderForPositionByDeadline(int position,</div><div class="line">                boolean dryRun, long deadlineNs) &#123;</div><div class="line">            boolean fromScrapOrHiddenOrCache = false;</div><div class="line">            ViewHolder holder = null;</div><div class="line">            // 如果是在预布局中，判断这个position对应的Viewholder是否被添加到了changeScrap中,并获取出对应的viewholder</div><div class="line">            if (mState.isPreLayout()) &#123;</div><div class="line">                holder = getChangedScrapViewForPosition(position);</div><div class="line">                fromScrapOrHiddenOrCache = holder != null;</div><div class="line">            &#125;</div><div class="line">            // 按顺序从attachscrap列表，hidden列表，一级缓存列表中获取对应的viewholder</div><div class="line">            if (holder == null) &#123;</div><div class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</div><div class="line">                if (holder != null) &#123;</div><div class="line">                    if (!validateViewHolderForOffsetPosition(holder)) &#123;</div><div class="line">			//判断这个Viewholder在这个position上是否可用,此时不可用，需要回收</div><div class="line">                        if (!dryRun) &#123;</div><div class="line">                                removeDetachedView(holder.itemView, false);</div><div class="line">                                holder.unScrap();</div><div class="line">                            &#125; else if (holder.wasReturnedFromScrap()) &#123;</div><div class="line">                                holder.clearReturnedFromScrapFlag();</div><div class="line">                            &#125;</div><div class="line">                            recycleViewHolderInternal(holder);</div><div class="line">                        &#125;</div><div class="line">                        holder = null;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        fromScrapOrHiddenOrCache = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    //如果在上面没找到可用的Viewholder</div><div class="line">            if (holder == null) &#123;</div><div class="line">                final int offsetPosition = mAdapterHelper.findPositionOffset(position);</div><div class="line">		...</div><div class="line">		//获取这个position对应ViewType</div><div class="line">                final int type = mAdapter.getItemViewType(offsetPosition);</div><div class="line">                //如果这个position有对应的stableId,那么按序从mattachScrap和mCacheViews中寻找</div><div class="line">                if (mAdapter.hasStableIds()) &#123;</div><div class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</div><div class="line">                            type, dryRun);</div><div class="line">                    if (holder != null) &#123;</div><div class="line">                        // 找到相对应的holder，更新position</div><div class="line">                        holder.mPosition = offsetPosition;</div><div class="line">                        fromScrapOrHiddenOrCache = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//如果还没找到，从自定义的cacheExtension寻找</div><div class="line">                if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</div><div class="line">                    final View view = mViewCacheExtension</div><div class="line">                            .getViewForPositionAndType(this, position, type);</div><div class="line">                    if (view != null) &#123;</div><div class="line">                        holder = getChildViewHolder(view);</div><div class="line">                        ...</div><div class="line">			&#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//最后一级缓存，viewHolderPool</div><div class="line">                if (holder == null) &#123; </div><div class="line">                    holder = getRecycledViewPool().getRecycledView(type);</div><div class="line">                    if (holder != null) &#123;</div><div class="line">			//因为缓存池是公用的，所以需要清除所有状态</div><div class="line">                        holder.resetInternal();</div><div class="line">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</div><div class="line">                            invalidateDisplayListInt(holder);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (holder == null) &#123;</div><div class="line">		    //所有缓存中都没有这个holder类型</div><div class="line">                    long start = getNanoTime();</div><div class="line">                    if (deadlineNs != FOREVER_NS</div><div class="line">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</div><div class="line">                        return null;</div><div class="line">                    &#125;</div><div class="line">		    //通过createViewHolder去创建</div><div class="line">                    holder = mAdapter.createViewHolder(RecyclerView.this, type);</div><div class="line">                    if (ALLOW_THREAD_GAP_WORK) &#123;</div><div class="line">                        //只有在支持预加载时才会寻找nextRv</div><div class="line">                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</div><div class="line">                        if (innerView != null) &#123;</div><div class="line">                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">		   ...</div><div class="line">		if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</div><div class="line">                	holder.mPreLayoutPosition = position;</div><div class="line">            	&#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;	</div><div class="line">	      //如果这个holder的数据需要更新，那么重新绑定数据，在tryBindViewHolderByDeadline中会调用bindViewholder去绑定计算出来的position所对应的数据</div><div class="line">              final int offsetPosition = mAdapterHelper.findPositionOffset(position);</div><div class="line">                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</div><div class="line">            &#125;</div><div class="line">	    ...</div><div class="line">            return holder;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>下面我们来看看getScrapOrHiddenOrCachedHolderForPosition这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123;</div><div class="line">            //mAttachedScrap是当前recyclerView显示的viewholder列表</div><div class="line">	    final int scrapCount = mAttachedScrap.size();</div><div class="line">		</div><div class="line">            for (int i = 0; i &lt; scrapCount; i++) &#123;</div><div class="line">                final ViewHolder holder = mAttachedScrap.get(i);</div><div class="line">                if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position</div><div class="line">                        &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;</div><div class="line">        	//如果在这个可见列表中找到了这个viewHolder，那么直接返回。    </div><div class="line">	        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</div><div class="line">                    return holder;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!dryRun) &#123;</div><div class="line">		//从隐藏的list列表中寻找对应position的View,只有在开启了PredictiveAnimation才有这个列表</div><div class="line">                View view = mChildHelper.findHiddenNonRemovedView(position);</div><div class="line">                if (view != null) &#123;</div><div class="line">		    //不为空，表示可以复用，只需要设置为非隐藏的</div><div class="line">                    final ViewHolder vh = getChildViewHolderInt(view);</div><div class="line">                    mChildHelper.unhide(view);</div><div class="line">                    int layoutIndex = mChildHelper.indexOfChild(view);</div><div class="line">                    if (layoutIndex == RecyclerView.NO_POSITION) &#123;</div><div class="line">                        throw new IllegalStateException(&quot;layout index should not be -1 after &quot;</div><div class="line">                                + &quot;unhiding a view:&quot; + vh);</div><div class="line">                    &#125;</div><div class="line">                    mChildHelper.detachViewFromParent(layoutIndex);</div><div class="line">                    scrapView(view);</div><div class="line">                    vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP</div><div class="line">                            | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</div><div class="line">                    return vh;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 从第一级缓存中读取</div><div class="line">            final int cacheSize = mCachedViews.size();</div><div class="line">            for (int i = 0; i &lt; cacheSize; i++) &#123;</div><div class="line">                final ViewHolder holder = mCachedViews.get(i);</div><div class="line">                if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;</div><div class="line">                    if (!dryRun) &#123;</div><div class="line">                        mCachedViews.remove(i);</div><div class="line">                    &#125;</div><div class="line">                    if (DEBUG) &#123;</div><div class="line">                        Log.d(TAG, &quot;getScrapOrHiddenOrCachedHolderForPosition(&quot; + position</div><div class="line">                                + &quot;) found match in cache: &quot; + holder);</div><div class="line">                    &#125;</div><div class="line">                    return holder;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>通过上面这一系列的复用机制，我们可以知道复用的流程，首先会从attachScrap,也就是当前已经显示的ViewHolder列表中获取可以复用的ViewHolder，如果存在hidden的Viewholder列表，那么接下来会从这个列表中获取缓存，如果不存在，接下来就是一级缓存mCacheView，二级缓存默认是我们自定义的mExtension，最后一级缓存是ViewholderPool，这个是一个公用的holder池。</p>
<h2 id="一些关于recyclerView相关的应用"><a href="#一些关于recyclerView相关的应用" class="headerlink" title="一些关于recyclerView相关的应用"></a>一些关于recyclerView相关的应用</h2><p>这一部分后面有时间再增加，顺便自己添加几张图，毕竟光看代码比较抽象。</p>
<p><div id="disqus_thread"></div></p>
<script>

<p>/**</p>
<ul>
<li>RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.</li>
<li><p>LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: <a href="https://disqus.com/admin/universalcode/#configuration-variables*/">https://disqus.com/admin/universalcode/#configuration-variables*/</a><br>/<em><br>var disqus_config = function () {<br>this.page.url = PAGE_URL;  // Replace PAGE_URL with your page’s canonical URL variable<br>this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page’s unique identifier variable<br>};
</em>/<br>(function() { // DON’T EDIT BELOW THIS LINE<br>var d = document, s = d.createElement(‘script’);<br>s.src = ‘<a href="https://disqus-jqqn8rznxd.disqus.com/embed.js">https://disqus-jqqn8rznxd.disqus.com/embed.js</a>‘;<br>s.setAttribute(‘data-timestamp’, +new Date());<br>(d.head || d.body).appendChild(s);<br>})();<br></script><p></p>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="external">comments powered by Disqus.</a></noscript>

<p><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></p>
<pre><code>&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;
</code></pre>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/04/09/0409anotation的基本原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个被裁的菜鸟程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/xiejl.github.io/2017/04/09/0409anotation的基本原理/" itemprop="url">
                  annotation(注解)的基本原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T13:14:52+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/xiejl.github.io/2017/04/09/0409anotation的基本原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/09/0409anotation的基本原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于注解"><a href="#关于注解" class="headerlink" title="关于注解"></a>关于注解</h1><h2 id="注解的概念"><a href="#注解的概念" class="headerlink" title="注解的概念"></a>注解的概念</h2><p>首先，注解只是一种描述数据的数据，俗称是元数据。注解，即Annotation,这个类位于java.lang.annotation包下。在android里面，Annotation有以下几个元注解，元注解是指用来定义annotation的annotation，</p>
<ul>
<li>Documented:表明了这个注解是否要被包含在java文档中</li>
<li>Inherited:表明了这个注解类型是否可以继承。</li>
<li>Retention:表明这个注解的存活时间，可选值封装在RetentionPolicy里面，可选值有source（源码期间），class（编译时），runtime（运行时），</li>
<li>Target:表示可以用来修饰的元素,封装在ElementType这个枚举类里面，可选属性有TYPE,METHOD,FIELD,PARAMENTER,CONSTRUCT等</li>
<li>Repeatable:表明这个注解是否可以重复声明，这个是在java8中新增的，java提供了重复注解的语法糖。</li>
</ul>
<p>上面几个元注解的定义上都是大同小异的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Documented</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(ElementType.ANNOTATION_TYPE)</div><div class="line">public @interface Documented &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><p>对于注解的使用，首先我们先从java中已经给我们定义好的override这个注解进行分析。我们都知道，@override注解可以在我们编写代码的时候进行查错，是否该注解方法是否真的是从父类继承而来的。下面时override注解的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Target(ElementType.METHOD)</div><div class="line">@Retention(RetentionPolicy.SOURCE)</div><div class="line">public @interface Override&#123;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><br>首先，定义注解的目标为方法，注解存活时间仅仅在编码时。在我们编写代码时，编译器会替我们去寻找该方法是否在父类方法中存在，如果不存在则报错。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>在很多框架中，都是用的自定义注解来实现aoc，也就是所谓的以来注入。<br>下面我们来自定义一个注解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Document</div><div class="line">@Inherite</div><div class="line">@Retetion(RetetionPolicy.RUNTIME)</div><div class="line">@Target(ElementType.MOTHED)</div><div class="line">public @interface AuthorXie&#123;</div><div class="line">    String name();</div><div class="line">    String webSite() default &quot;hhhhhh&quot;;</div><div class="line">    int reversion() default 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>自定义注解必须遵守下面的规则：</p>
<ul>
<li>接口方法不带参数</li>
<li>接口方法的返回值类型限制</li>
<li>接口方法能有默认值</li>
</ul>
<p>在我们定义完了注解之后，我们便可以在方法中使用注解。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class AnnotationTest&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new AnnotationTest.myTest();</div><div class="line">    &#125;</div><div class="line">    @AuthorXie(&quot;haha&quot;, &quot;xixi&quot;, 2)</div><div class="line">    private int myTest()&#123;</div><div class="line">        System.out.println(&quot;i am xiexie&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>因为这个注解的policy我们选择的运行时，所以会在程序的运行期间进行反射转换。在反射中，有一个专门用于解析注解的接口，annotateElement，有几个核心的方法：</p>
<ul>
<li>getAnnotationClass –返回该元素上的指定类型的注解</li>
<li>getAnnotations –返回该元素上的所有注解</li>
<li>getDeclareAnnotations –直接存在于该元素上的所有注解</li>
<li>isAnnotationPresent –是否存在该注解</li>
</ul>
<p>我们通常利用这个接口，去实现我们自定义注解的解析类，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ParaseAnnotation&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        String clazz = &quot;packageName&quot;;</div><div class="line">        Method[] method = ParaseAnnotation.class.getClassLoader().loadClass(class).getMethods();</div><div class="line">        for (Method methods: methed) &#123;</div><div class="line">            if (methods.isAnnotationPresent(AuthorXie)) &#123;</div><div class="line">                AuthorXie authorXie = method.getAnnotations(AuthorXie.class);</div><div class="line">                System.out.println(&quot;-----&quot;+ authorXie.name() +&quot;---- &quot; +authorXie.WebSite() + &quot;----&quot;+</div><div class="line">                authorXie.reVersion());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以，一般来说，我们通过AnnotateElement类去进行注解的解析。我们可以大概的概括自定义注解的实现原理：</p>
<ul>
<li>定义RUNTIME注解，因为只有在运行时才需要利用反射机制。</li>
<li>在类中的方法使用我们所定义的注解。</li>
<li>最重要的就是在解析类中，进行反射操作，在这个地方可以做很多额外的事情，很多框架利用注解也都是在这里做的，首先利用我们的类名，通过反射获取类，进而获取类里面的所有方法。对每个方法进行判断是否调用我们所定义的注解，假如调用了，利用反射接口方法getAnnotations获取注解接口。然后再进行注解的接口方法操作。</li>
</ul>
<h2 id="几句话了解注解的真正原理"><a href="#几句话了解注解的真正原理" class="headerlink" title="几句话了解注解的真正原理"></a>几句话了解注解的真正原理</h2><p>其实关于注解的原理非常简单，就是对一个方法用了注解，在解析的时候，通过反射，获取出类的所有方法并进行遍历，通过注解相关的类annotateElement，获取该方法上所有的注解，然后并调用注解方法。这样就是所谓的注解的解析。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/04/05/0405android自定义图片动画的尝试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个被裁的菜鸟程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/xiejl.github.io/2017/04/05/0405android自定义图片动画的尝试/" itemprop="url">
                  android中ImageView动画的一些相关问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T13:14:52+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/xiejl.github.io/2017/04/05/0405android自定义图片动画的尝试/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/05/0405android自定义图片动画的尝试/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="图片旋转所遇到的问题"><a href="#图片旋转所遇到的问题" class="headerlink" title="图片旋转所遇到的问题"></a>图片旋转所遇到的问题</h3><p>最近项目中接触到一个动画的实现，<br>遇到的最主要的难点就是在执行view动画rotate的时候，让里面的drawable只显示上半部分，虽然到现在都还没有实现，但还是把解决问题时遇到的一些东西给记录下来，以便以后再进行解决或者回顾。<br>首先想到的第一种解决方法：<br>利用clipDrawable去进行drawbale的截断。关于clipDrawble的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//in xml</div><div class="line">&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:clipOrientation=&quot;vertical&quot;</div><div class="line">    android:drawable=&quot;@drawable/light&quot;</div><div class="line">    android:gravity=&quot;top&quot;&gt;</div><div class="line">&lt;/clip&gt;</div><div class="line">//其中，clipOrientation设置从哪个方向开始裁剪，drawable表示需要裁剪的图片，gravity表示最后保留的部分，如果设置top，则会从底部开始裁剪，设置了bottom，则会从顶部开始裁剪。</div><div class="line">//in java code</div><div class="line">    ClipDrawable cd = (ClipDrawable)lightView.getDrawable();</div><div class="line">    cd.setLevel(5000);</div><div class="line">//其中，这个level表示的是裁剪的程度，范围是0到10000，默认为0，即不进行裁剪</div></pre></td></tr></table></figure><br>通过clipDrawble这种实现方法，最终的结果是半张drawable填充满整个imageview，并进行旋转。</p>
<p>然后尝试着第二种解法：<br>本来想着用一个与背景色同样的view去覆盖旋转的imageView的下半部分，自己写的module发现是可行的。但是工程里面的背景色是带有透明度alpha的，一旦有透明度的相同的背景相互叠加，透明度会发生改变，而且带透明度的是可以看到后面控件的。所以这种方法也不行。</p>
<p>后面想到第三种解法：<br>当时想法是如果在自定义一个imageView并重写它的ondraw方法，每次进行ondraw时只绘制其drawable的一半。</p>
<p>发现这种方法也不行，突然发现animator动画其实是对view也就是这个imageView的位置进行旋转，仅仅修改掉这个drawable并不能完成这个要求，在stackoverflow上找到一个比较相近的实现：<br><a href="http://stackoverflow.com/questions/36546760/how-to-show-half-of-the-imageview-which-is-rotated-using-matrix-in-android" target="_blank" rel="external">http://stackoverflow.com/questions/36546760/how-to-show-half-of-the-imageview-which-is-rotated-using-matrix-in-android</a></p>
<h2 id="ImageView实现自定义位移的问题"><a href="#ImageView实现自定义位移的问题" class="headerlink" title="ImageView实现自定义位移的问题"></a>ImageView实现自定义位移的问题</h2><p>因为项目中有一个动画的实现是需要对imageView做一个半圆形位移，看了一下android的view动画和属性动画，基本位移都是只有对于x和y来作移动的。既然说到了android的动画，那我们就简单的来了解以下android里面的各种动画吧。</p>
<h4 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a>View动画</h4><p>view动画，又称为补间动画，可以对View做一些简单的动画，包括scale，alpha，rotation和translate。这种这种并不会实际的改变view的属性，即如果你对一个view向右移动了50px，实际上这个view的可触摸区域还是在起始的地方，并不会随着位移的改变而改变。这几种相对比较简单，可以在xml里面写好，也可以在代码中动态的实现。</p>
<h3 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h3><p>顾名思义，即不同时刻的几张图片添加到帧列表里面，然后可以设置每一帧的间隔，最后播放，就形成了动画，也就由一帧一帧的播放组成的帧动画。</p>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>先放些官方文档所给定的翻译：属性动画是一个能够让我们去对任何东西做动画的框架。我们可以定义在一个时间段里面去改变对象的属性的动画，但是我们必须指定我们所需要改变的属性，动画持续的时间，还有执行动画的一些相关的值。属性动画提供了下面这些属性让我们使用：</p>
<ul>
<li>duration：动画的持续时间，默认为300ms</li>
<li>time interpolation：时间插值器，用于设置动画在时间内的变化速率。</li>
<li>repeat count and behavior：repeat时用于指定动画的重复次数，默认为0，表示不重复，如果想要重复，可以设置为设为-1或infinite，表示为无限重复。 behavior用于指定动画是否能够倒着执行。</li>
<li>animator set：用于指定一个属性动画集合，可以同时开始播放。</li>
<li>frame refresh delay：我们可以指定动画的刷新频率，也就是每一帧的刷新频率，默认为10ms刷新一次，不过这个速度还是得依靠我们cpu的处理，如果我们cpu过于繁忙，这个刷新频率就要延后了。</li>
</ul>
<p>我们来看看在属性动画中一些比较重要的组件的使用。</p>
<h4 id="ValueAnimator："><a href="#ValueAnimator：" class="headerlink" title="ValueAnimator："></a>ValueAnimator：</h4><h5 id="简单了解"><a href="#简单了解" class="headerlink" title="简单了解"></a>简单了解</h5><p>下面这个图是官方文档所给的图：稍微了解下就好，其实我们做的很多动画都是基于这张图片所显示的计算：<br><img src="http://onu21exz8.bkt.clouddn.com/animator_caculate.jpeg" alt=""><br>valueAnimator会持续的追踪属性动画的时间变化，比如说我们的动画已经持续了多久，现在属性动画的value值。在它里面还有一个TimeInterpolator和TypeEvaluetor。对于TimeInterpolator，也就是时间插值器，它决定着我们的动画在时间内的变化速率。android里面提供了很多可以直接用的插值器，如果我们自己要自定义插值器，只需要实现interpolator这个接口就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class MyInterpolator implements Interpolator &#123;</div><div class="line">    @Override</div><div class="line">    public float getInterpolation(float input) &#123;</div><div class="line">        return input;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>这个input就是我们所要改变的变化值，即如果我们要让动画先加速再减速，只需要对这个input进行先加速再减速就行了。<br>对于TypeEvaluetor，和时间插值器很类似，这个类主要是用来计算动画在某个时刻的值，我们看自带的其中一个IntEvaluator。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123;</div><div class="line">        int startInt = startValue;</div><div class="line">        return (int)(startInt + fraction * (endValue - startInt));</div><div class="line">    &#125;</div><div class="line">    </div></pre></td></tr></table></figure><br>其中，fraction是一个0到1的值，其实就是时间差值器中返回的input，通过这个变化率和起始位置、结束位置去进行计算，当然，这个计算只是针对于这个类型的Evaluator。实际上，接口的方法是有范型的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public T evaluate(float fraction, T startValue, T endValue);</div></pre></td></tr></table></figure><br>这就意味着我们能够定义出任何我们想要的类型，并对类型进行计算，然后返回。</p>
<h5 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h5><p>首先我们需要创建出一个ValueAnimator实例，必须指定start和end值，当调用start方法时，动画才真正的开始执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//其中a表示start值，b表示end值</div><div class="line">ValueAnimator animator = ValueAnimator.ofArgb(int a, int b);</div><div class="line">ValueAnimator animator = ValueAnimator.ofFloat(int a, int b);</div><div class="line">ValueAnimator animator = ValueAnimator.ofInt(int a, int b);</div><div class="line"></div><div class="line">animator.setDuration(1234);//设置持续时间</div><div class="line">animator.setIntrepolator();//设置时间插值器</div><div class="line">animaotr.start();开始动画。</div><div class="line"></div><div class="line">//添加监听，指定改变的对象并进行改变。</div><div class="line">animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">                float value = (float) animation.getAnimatedValue();</div><div class="line">                object.setValue(value);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p>
<h4 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a>ObjectAnimator</h4><p>ObjectAnimator是ValueAnimator的一个子类，主要就提供了创建动画时便指定动画的对象。其实主要看看其使用方式就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(target, &quot;translationX&quot;, start, end，...);</div></pre></td></tr></table></figure><br>这个动画的使用和View动画比较类似，我们看看上面的几个参数。</p>
<ul>
<li>target: 执行动画的对象。</li>
<li>translationX:指定为哪种动画。scaleY，scaleX，rotation，translationY，alpha等动画，</li>
<li>start:指定动画的起始值</li>
<li>end：指定动画的终止值。</li>
<li>…：可以设置下一个参数作为下一次动画的终止值，而之前的end在动画结束后会作为动画的起始位置。</li>
</ul>
<h3 id="Path和PathMeasure"><a href="#Path和PathMeasure" class="headerlink" title="Path和PathMeasure"></a>Path和PathMeasure</h3><p>在动画里面，path和PathMeasure是两个非常重要的类，path主要是用于绘制路径，PathMeasure主要是用于Path路径的一些相关处理，比如说计算总长度，获取当前的postion位置，截取path的某一小段路径。<br>我们先通过一个例子来了解一下吧：这是一个关于circle动画的例子，就是spreshLayout加载的那个动画类似。现在还不知道怎么弄成gif展示，后面找到了再上图。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public PathMeasureView(Context context, AttributeSet attrs) &#123;</div><div class="line">      super(context, attrs);</div><div class="line">      mPathMeasure = new PathMeasure();</div><div class="line">      mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">      mPaint.setStyle(Paint.Style.STROKE);</div><div class="line">      mPaint.setStrokeWidth(5);</div><div class="line">      //绘制一个空心圆</div><div class="line">      mPath = new Path();</div><div class="line">      mPath.addCircle(400, 400, 100, Path.Direction.CW);</div><div class="line">      mPathMeasure.setPath(mPath, true);</div><div class="line">      //获取路径的总长度</div><div class="line">      mLength = mPathMeasure.getLength();</div><div class="line">      mDst = new Path();</div><div class="line">      </div><div class="line">      final ValueAnimator valueAnimator = ValueAnimator.ofFloat(0,1);</div><div class="line">      valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">          @Override</div><div class="line">          public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">              //在每一次动画更新时，获取现在更新的百分比，然后进行重绘</div><div class="line">              mAnimatorValue = (float) valueAnimator.getAnimatedValue();</div><div class="line">              invalidate();</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">      valueAnimator.setDuration(2000);</div><div class="line">      valueAnimator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">      valueAnimator.start();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">   @Override</div><div class="line">  protected void onDraw(Canvas canvas) &#123;</div><div class="line">      super.onDraw(canvas);</div><div class="line">      //每次绘制时都重新将需要绘制path清空</div><div class="line">      mDst.reset();</div><div class="line">      mDst.lineTo(0,0);</div><div class="line">      //计算现在动画绘制结束的总长度</div><div class="line">      float stop = mLength * mAnimatorValue;</div><div class="line">      //计算起始点的位置</div><div class="line">      float rStart = stop - mLength * (mAnimatorValue &gt; 0.5 ? (1- mAnimatorValue) : mAnimatorValue) ;</div><div class="line">      //截取当前需要显示的片段，并进行绘制</div><div class="line">      mPathMeasure.getSegment(rStart, stop, mDst, true);</div><div class="line">      canvas.drawPath(mDst, mPaint);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="对ImageView做位移"><a href="#对ImageView做位移" class="headerlink" title="对ImageView做位移"></a>对ImageView做位移</h4><p>最后来看看如何对ImageView做指定路径的移动，其实看了上面那几个部分，应该已经了解了整个过程了吧，首先利用path生成我们所需要的曲线移动，在生成曲线的时候我们就可以利用贝塞尔曲线函数，通过提供几个点来生成。然后结合pathMeasure和ValueAnimator来进行移动。下面来看看简单的代码片段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">   private PathMeasure getPathMeasure(ImageView imageView) &#123;</div><div class="line">       ...</div><div class="line">       //生成贝塞尔曲线控制点</div><div class="line">       float startX = 0;</div><div class="line">       float startY = 0;</div><div class="line">       float endX = 0;</div><div class="line">       float endY = 0;</div><div class="line">       float controlX = 0;</div><div class="line">       float controlY = 0;</div><div class="line">       startX = imageView.getTranslationX();</div><div class="line">       startY = imageView.getTranslationY();</div><div class="line">       endX = startX;</div><div class="line">       endY = startY + imageView.getHeight() / 2;</div><div class="line">       controlX = startX - imageView.getHeight() / 4;</div><div class="line">       controlY = startY + imageView.getHeight() / 4;</div><div class="line">       ...</div><div class="line">       return initPathMeasure(startX, startY, endX, endY, controlX, controlY);</div><div class="line"></div><div class="line">   &#125;</div><div class="line">//绘制贝塞尔曲线</div><div class="line">private PathMeasure initPathMeasure(float startX, float startY, float endX, float endY,</div><div class="line">                                       float controlX, float controlY) &#123;</div><div class="line">       Path path = new Path();</div><div class="line">       path.moveTo(startX, startY);</div><div class="line">       path.quadTo(controlX, controlY, endX, endY);</div><div class="line">       PathMeasure pathMeasure = new PathMeasure(path, false);</div><div class="line">       return pathMeasure;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"> private ValueAnimator initTranslateAnimator(final ImageView imageView) &#123;</div><div class="line"></div><div class="line">       final PathMeasure pathMeasure = getPathMeasure(imageView);</div><div class="line">       final float[] mCurrentPosition = new float[2];</div><div class="line">       </div><div class="line">       ValueAnimator valueAnimator = ValueAnimator.ofFloat(0, pathMeasure.getLength());</div><div class="line">       valueAnimator.setDuration(VIEW_ANIMATION_TIME);</div><div class="line">       valueAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">       valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">           @Override</div><div class="line">           public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">               //实时设置imageView的位置</div><div class="line">               float value = (float) animation.getAnimatedValue();</div><div class="line">               pathMeasure.getPosTan(value, mCurrentPosition, null);</div><div class="line">               imageView.setTranslationX(mCurrentPosition[0]);</div><div class="line">               imageView.setTranslationY(mCurrentPosition[1]);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       return valueAnimator;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>简单的看看上面imageView曲线移动的步骤：</p>
<ul>
<li>利用getPathMeasure生成贝塞尔曲线并进行绘制</li>
<li>添加ValueAnimator监听</li>
<li>valueAnimator的每次更新，利用pathMeasure获取出当前移动位置的position，并set到imageView的translation上。</li>
</ul>
<p>这样，imageView就会像我们所绘制的曲线一样移动。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/03/27/0327hexo结合github建博客的尝试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个被裁的菜鸟程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/xiejl.github.io/2017/03/27/0327hexo结合github建博客的尝试/" itemprop="url">
                  hexo结合github建博客的尝试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-27T18:21:24+08:00">
                2017-03-27
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/xiejl.github.io/2017/03/27/0327hexo结合github建博客的尝试/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/03/27/0327hexo结合github建博客的尝试/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>突然有了写博客的想法，就在网上找了搭建博客的教程，发现很多人都用了hexo结合github搭建博客的方式，因此，利用这个周末的时间，自己学着来搭建下这个博客。搭建hexo博客的必要前提就是安装git和nodejs，在mac下，git是默认安装的，node需要我们手动去安装。这个我们可以从hexo的官方文档所给定的步骤来安装。简单的列举下我的搭建博客步骤。</p>
<ol>
<li>安装nodejs，在其官网上，下载dmg文件，并安装。附上连接：<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a></li>
<li>安装hexo，只需要执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure></li>
<li>初始化一个hexo仓库，利用hexo init <folder>命令，创建出一个仓库，这个仓库名称通常取名为ourname.github.io,github.io,是git page的访问格式。</folder></li>
<li>第三步创建的仅仅只是我们本地的仓库，因为我们最终的静态页面是要部署到github上面的，所以我们还需要在我们的github上去创建对应的远程仓库，需要注意的是，我们创建的仓库名称和我们本地的仓库名称需要一致，也就是仓库名称也要为ourname.github.io,github.io,至于如何在github上配置和创建仓库，我就不多说了，google也有，基本不会出现什么坑。</li>
<li>现在，就是要让我们本地的仓库和远程github上的仓库建立连接了，我们本地的仓库还不是一个git仓库，所以我们应该要cd到我们的仓库目录的根目录下，执行下面的命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git init  //在ourname.github.io,github.io目录下，将这个仓库初始化为一个git，默认分支为master</div><div class="line">git add . //添加修改文件到暂存区</div><div class="line">git commit -m &quot;my first commit&quot;;//生成commit提交</div><div class="line">//后面的https连接就是我们github上远程仓库的地址。这就建立了连接。</div><div class="line">git git remote add origin https://github.com/username/projectName.git</div><div class="line">git push origin master.//将刚刚的修改进行提交。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>我们必须要记住的一点就是，对于hexo和github的建站，我们只需要自己push这一次，其他的部署都是hexo自动为什么生成提交的，我刚开始并不清楚，所以每次部署完成后，都自己手动push了一次，导致github上老是build page失败。</p>
<ol>
<li>这个时候，我们就需要修改我们的目录下的config文件了，做一些必要的相关配置,也就是和部署相关的配置。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line"> type: git</div><div class="line"> repository: https://github.com/xiejinlong/xiejl.github.io.git</div><div class="line"> branch: master</div></pre></td></tr></table></figure>
<p>这个config文件yaml格式要求非常严格，对于每一个映射前面必须有空格。这个deploy就是配置部署的项，repository就是部署到哪里，然后必须指定分支，部署类型设置为git，最初的部署类型为github，最后统一为git。这个设置关乎hexo是否能够部署成功。下面还有一个地方需要修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">url: https://xiejinlong.github.io/xiejl.github.io/</div><div class="line">root: /xiejl.github.io</div></pre></td></tr></table></figure>
<p>这个是关于访问路径的配置的，假如你设置了其他的主题，那么如何这个访问路径没配置好的话，那么主题的样式是显示不出来的。</p>
<p>7.这个时候我们就可以执行hexo命令啦，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean //清除上一次缓存</div><div class="line">hexo g      //自动生成静态页面</div><div class="line">hexo d      //执行部署</div></pre></td></tr></table></figure>
<p>在这个时候就会把上面的生成的静态页面部署到了github上面了。</p>
<ol>
<li>这个时候我们访问我们的网页github.io并不能显示出正确的页面，这个时候我们还差最后一步，我们需要在我们github的对应项目仓库的做点配置。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">settings ----&gt; Github Page 项---&gt;在source下选择我们deploy的分支。</div></pre></td></tr></table></figure>
<p>这样就部署成功啦，github就会提醒你：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Your site is published at https://xiejinlong.github.io/xiejl.github.io/</div></pre></td></tr></table></figure>
<p>然后直接访问published所对应的地址就行了。</p>
<p>如果我们想要替换不同的主题，我们应该将主题clone到本地仓库的theme目录下，然后对应的修改项目目录下面的config文件的theme项，设置为我们clone的项目名称就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next</div></pre></td></tr></table></figure>
<p>至于如何配置用户名和标题什么的，hexo文档里面介绍的非常清楚，如果要修改theme的样式，只需要到对应的目录下的配置文件去修改就行了。</p>
<p>下面简单的列举遇到的坑，毕竟这么简单的流程整了整天两天。</p>
<ul>
<li>Deployer not found: git 这个需要执行 npm install hexo-deployer-git –save 下载deployer git插件</li>
<li>突然出现hexo命令找不到：这个需要在我们的博客项目的根目录去执行。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/xiejl.github.io/images/avatar.gif"
               alt="xie" />
          <p class="site-author-name" itemprop="name">xie</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/xiejl.github.io/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xie</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/xiejl.github.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/xiejl.github.io/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/xiejl.github.io/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://disqus_JQqn8rznXd.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  





  

  

  

  

</body>
</html>
