<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉迷学习却日渐发福</title>
  
  <subtitle>我会笑着迎接每一天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xjlhhz.com/"/>
  <updated>2018-11-04T09:06:35.000Z</updated>
  <id>https://xjlhhz.com/</id>
  
  <author>
    <name>phiCoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Adnroid processor的一次尝试</title>
    <link href="https://xjlhhz.com/2018/11/04/20181104%E5%85%B3%E4%BA%8EAdnroid%20processor/"/>
    <id>https://xjlhhz.com/2018/11/04/20181104关于Adnroid processor/</id>
    <published>2018-11-04T05:14:00.000Z</published>
    <updated>2018-11-04T09:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# 关于Adnroid processor</p><h2 id="LovelyInject"><a href="#LovelyInject" class="headerlink" title="LovelyInject"></a>LovelyInject</h2><p>项目地址：<a href="https://github.com/xiejinlong/LovelyInject" target="_blank" rel="external">https://github.com/xiejinlong/LovelyInject</a><br>这个是一个基于<a href="https://github.com/enbandari/TieGuanYin库实现的一个简易版的intent注入框架。" target="_blank" rel="external">https://github.com/enbandari/TieGuanYin库实现的一个简易版的intent注入框架。</a></p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>可以使用的有3个注解，BuilderActivity，BuilderFragment和BuilderModel，这三个注解是用来修饰类的,三个注解的retention都是编译期间，targetType都是ElementType.TYPE，也就是用来修饰Class。<br>其中，BuilderActivity用来修饰Activity，可以指定默认的跳转Scheme，会生成一个通过scheme跳转的静态方法。<br>BuilderFragme用来修饰Fragment。<br>BuilderModel用来修饰普通的model类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">@Target(ElementType.TYPE)</div></pre></td></tr></table></figure></p><ul><li><p>修饰activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@BuilderActivity(routerValue = &quot;to_test_scheme&quot;)</div><div class="line">    class TestActivity: Activity() &#123;</div><div class="line">    @Fields</div><div class="line">    var name: String? = null</div><div class="line">    @Fields</div><div class="line">    var age: Int = 0</div><div class="line">    @Fields</div><div class="line">    var msg: String? = null</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>修饰fragment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@BuilderFragment</div><div class="line">    class TestFragment: Fragment() &#123;</div><div class="line">    @Fields</div><div class="line">    var name: String? = null</div><div class="line">    @Fields</div><div class="line">    var age: Int = 0</div><div class="line">    @Fields</div><div class="line">    var msg: String? = null</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>修饰model类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@BuilderModel</div><div class="line">    class TestModel &#123;</div><div class="line">    @Fields</div><div class="line">    var name: String? = null</div><div class="line">    @Fields</div><div class="line">    var age: Int = 0</div><div class="line">    @Fields</div><div class="line">    var msg: String? = null</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><h4 id="编译build"><a href="#编译build" class="headerlink" title="编译build"></a>编译build</h4><ul><li><p>生成的ActivityBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public final class TestActivityBuilder &#123;</div><div class="line">  public static final String FIELD_NAME = &quot;name&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_AGE = &quot;age&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_MSG = &quot;msg&quot;;</div><div class="line"></div><div class="line">  private String name;</div><div class="line"></div><div class="line">  private int age;</div><div class="line"></div><div class="line">  private String msg;</div><div class="line"></div><div class="line">  public static TestActivityBuilder builder() &#123;</div><div class="line">    TestActivityBuilder builder = new TestActivityBuilder();</div><div class="line">    return builder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestActivityBuilder name(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestActivityBuilder age(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestActivityBuilder msg(String msg) &#123;</div><div class="line">    this.msg = msg;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private void fillIntent(Intent intent) &#123;</div><div class="line">    intent.putExtra(&quot;name&quot;, name);</div><div class="line">    intent.putExtra(&quot;age&quot;, age);</div><div class="line">    intent.putExtra(&quot;msg&quot;, msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void start(Context context) &#123;</div><div class="line">    Intent intent = new Intent(context, TestActivity.class);</div><div class="line">    fillIntent(intent);</div><div class="line">    context.startActivity(intent);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></li><li><p>生成的fragmentBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public final class TestFragmentBuilder &#123;</div><div class="line">  public static final String FIELD_NAME = &quot;name&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_AGE = &quot;age&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_MSG = &quot;msg&quot;;</div><div class="line"></div><div class="line">  private String name;</div><div class="line"></div><div class="line">  private int age;</div><div class="line"></div><div class="line">  private String msg;</div><div class="line"></div><div class="line">  public static TestFragmentBuilder builder() &#123;</div><div class="line">    TestFragmentBuilder builder = new TestFragmentBuilder();</div><div class="line">    return builder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragmentBuilder name(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragmentBuilder age(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragmentBuilder msg(String msg) &#123;</div><div class="line">    this.msg = msg;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private void fillIntent(Intent intent) &#123;</div><div class="line">    intent.putExtra(&quot;name&quot;, name);</div><div class="line">    intent.putExtra(&quot;age&quot;, age);</div><div class="line">    intent.putExtra(&quot;msg&quot;, msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragment build() &#123;</div><div class="line">    TestFragment fragment = new TestFragment();</div><div class="line">    Intent intent = new Intent();</div><div class="line">    fillIntent(intent);</div><div class="line">    fragment.setArguments(intent.getExtras());</div><div class="line">    return fragment;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>-生成的modelBuilder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public final class TestModelBuilder &#123;</div><div class="line">  public static final String FIELD_NAME = &quot;name&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_AGE = &quot;age&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_MSG = &quot;msg&quot;;</div><div class="line"></div><div class="line">  private String name;</div><div class="line"></div><div class="line">  private int age;</div><div class="line"></div><div class="line">  private String msg;</div><div class="line"></div><div class="line">  public static TestModelBuilder builder() &#123;</div><div class="line">    TestModelBuilder builder = new TestModelBuilder();</div><div class="line">    return builder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModelBuilder name(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModelBuilder age(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModelBuilder msg(String msg) &#123;</div><div class="line">    this.msg = msg;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModel build() &#123;</div><div class="line">    TestModel model = new TestModel();</div><div class="line">    return model;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这三个builder文件基本类似，每个@Fields修饰的成员变量都将生成一个对应的builder方法。activityBuilder会多一个fillIntent方法和start方法，用来填充intent和开启新页面。而fragmentBuilder会多一个fillIntent方法和build方法，fillIntent也是用来填充intent，而build方法是用来返回fragment实例的。</p><h3 id="使用Builder"><a href="#使用Builder" class="headerlink" title="使用Builder"></a>使用Builder</h3><ul><li><p>in ActivityBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//调用</div><div class="line">TestActivityBuilder.builder().age(12)</div><div class="line">                    .name(&quot;xie&quot;)</div><div class="line">                    .msg(&quot;我是从mainAc过来的参数&quot;)</div><div class="line">                    .start(this)</div><div class="line">//使用变量，in TestActivity</div><div class="line"> Toast.makeText(this,</div><div class="line">                &quot;我是 $name，今年 $age, $msg&quot;, Toast.LENGTH_LONG).show()</div></pre></td></tr></table></figure></li><li><p>in fragmentBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//调用</div><div class="line">fragmentManager.beginTransaction()</div><div class="line">                    .replace(R.id.mainLayout,</div><div class="line">                            TestFragmentBuilder.builder()</div><div class="line">                                    .name(&quot;lovely&quot;)</div><div class="line">                                    .age(13)                                .msg(&quot;我是从testAc过来的参数&quot;).build())</div><div class="line">                    .commitAllowingStateLoss()</div><div class="line">//使用变量，in TestFragment</div><div class="line"> Toast.makeText(context,</div><div class="line">                &quot;我是 $name，今年 $age, $msg&quot;, Toast.LENGTH_LONG).show()</div></pre></td></tr></table></figure></li></ul><h2 id="Prossor生成代码原理"><a href="#Prossor生成代码原理" class="headerlink" title="Prossor生成代码原理"></a>Prossor生成代码原理</h2><p>上面就是通过builder生成的代码来给我简化使用流程，每一个activity和fragment都会相对应的生成一个Builder类来供我们使用。下面我们来详细了解一下这个框架的原理实现。</p><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><p>Element是基类，可在不同的情况下转化成不同的子类，具体的类型可以通过getKind方法获得</p><ul><li>TypeElement: 表示类或者接口</li><li>VariableElement: 表示字段参数</li><li>PackageElement: 表示一个包</li><li>ExecutableElement: 表示方法</li><li>TypeParameterElement: 表示范型参数</li></ul><h4 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a>TypeMirror</h4><p>Element表示的是元素，而TypeMirror表示的是参数类型。可以通过getkind来获取参数类型。</p><h4 id="TypeSpec"><a href="#TypeSpec" class="headerlink" title="TypeSpec"></a>TypeSpec</h4><p>是javapoet库用来生成文件的主要的类。</p><h4 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h4><p>ProcessingEnvironment中提供了4个工具接口</p><ul><li>lateinit var types: Types //java类型工具</li><li>lateinit var elements: Elements //注解获取出来的元素</li><li>lateinit var messager: Messager//消息输出</li><li>lateinit var filer: Filer//文件写入</li></ul><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><ol><li><p>首先我们需要先创建出Annotation库，创建出对应的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">@Target(ElementType.TYPE)</div><div class="line">public @interface BuilderActivity &#123;</div><div class="line">    String routerValue() default &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>创建出Processor库，并且自定义Processor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class KKProcessor : AbstractProcessor() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>在这里需要注意的是，我们必须手动的建立Processor索引，不然编译期间不会执行到这个Processor。<br>需要在和java同级目下创建出resources/META-INF/services/javax.annotation.processing.Processor文件，然后在内部添加processor的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.inject.xie.processor.KKProcessor</div></pre></td></tr></table></figure></p><p>而且，需要在app的gradle中添加该processor的编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kapt project(&quot;:Processor&quot;)</div></pre></td></tr></table></figure></p><ol><li>开始编译，解析注解<br>在编译时，会调用到processor的process方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override fun process(p0: MutableSet&lt;out TypeElement&gt;?, p1: RoundEnvironment?): Boolean &#123;</div><div class="line">        LogUtils.warn(&quot;KKProcessor process&quot;)</div><div class="line"></div><div class="line">        return true</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ol><p>在这个方法中，我们需要解析出我们要的注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//解析class</div><div class="line">env.getElementsAnnotatedWith(BuilderActivity::class.java)</div><div class="line">                .asSequence()</div><div class="line">                .filter(SuperficialValidation::validateElement)</div><div class="line">                .filter &#123; it.kind.isClass &#125;</div><div class="line">                .toList()</div><div class="line">                .forEach &#123; element -&gt;</div><div class="line">                    LogUtils.warn(&quot;KKProcessor parasClass $&#123;element.simpleName&#125; is Activity~&quot;)</div><div class="line">                    if (ProcessorEnv.types.isSubtype(element.asType(), ClassType.KKACTIVITY.typeMirror)) &#123;</div><div class="line">                        classMap[element] = KKActivityBuilder(element as TypeElement)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>通过getElementsAnnotatedWith方法来获取被BuilderActivity修饰的所有的类。其他几个注解类似，然后存储在classMap，这里需要注意一点，process方法可能会执行多次，所以需要将解析的产物放在map中或者每次解析都将list清空。<br>然后解析field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private fun parasFiled(env: RoundEnvironment) &#123;</div><div class="line">        env.getElementsAnnotatedWith(Fields::class.java)</div><div class="line">                .asSequence()</div><div class="line">                .filter(SuperficialValidation::validateElement)</div><div class="line">                .filter &#123; it.kind.isField &#125;</div><div class="line">                .toList()</div><div class="line">                .forEach &#123; element -&gt;</div><div class="line">                    LogUtils.warn(&quot;KKProcessor parasFiled $&#123;element.simpleName&#125;&quot;)</div><div class="line">                    classMap[element.enclosingElement]?.addFiled(element)</div><div class="line">                &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>将解析生成的fields存储到上一步生成的class产物中，这样，就拿到了被注解的类和其中的被注解的成员变量。</p><ol><li>生成代码</li></ol><ul><li><p>创建class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val classFileBuilder = TypeSpec.classBuilder(builderClassName)</div><div class="line">        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</div></pre></td></tr></table></figure></li><li><p>创建成员及成员的builder方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fields.forEach &#123; field -&gt;</div><div class="line">            LogUtils.warn(&quot;fieldBuilder $&#123;field.name&#125;&quot;)</div><div class="line">            //构造临时变量</div><div class="line">            classFileBuilder.addField(FieldSpec.builder(field.asTypeName(), field.name, Modifier.PRIVATE).build())</div><div class="line"></div><div class="line">            //构造变量相关的静态变量</div><div class="line">            classFileBuilder.addField(FieldSpec.builder(String::class.java, KKActivityBuilder.CONST_POSIX + field.name.toUpperCase())</div><div class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</div><div class="line">                    .initializer(&quot;\$S&quot;, field.name)</div><div class="line">                    .build())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            //构造相关变量的builder方法</div><div class="line">            classFileBuilder.addMethod(MethodSpec.methodBuilder(field.name)</div><div class="line">                    .addModifiers(Modifier.PUBLIC)</div><div class="line">                    .addParameter(field.asTypeName(), field.name)</div><div class="line">                    .addStatement(&quot;this.$&#123;field.name&#125; = $&#123;field.name&#125;&quot;)</div><div class="line">                    .addStatement(&quot;return this&quot;)</div><div class="line">                    .returns(builderClassTypeName)</div><div class="line">                    .build())</div><div class="line">        &#125;</div></pre></td></tr></table></figure></li><li><p>创建方法<br>首先需要静态的builder方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//构造主builder</div><div class="line">        classFileBuilder.addMethod(MethodSpec.methodBuilder(&quot;builder&quot;)</div><div class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</div><div class="line">                .returns(builderClassTypeName)</div><div class="line">                .addStatement(&quot;\$T builder = new \$T()&quot;, builderClassTypeName, builderClassTypeName)</div><div class="line">                .addStatement(&quot;return builder&quot;).build())</div></pre></td></tr></table></figure></li></ul><p>对于Activity，需要创建fillIntent和start方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//对于Activity，需要创建fillIntent和start方法</div><div class="line">       val intentMethod = MethodSpec.methodBuilder(&quot;fillIntent&quot;)</div><div class="line">               .addModifiers(Modifier.PRIVATE)</div><div class="line">               .addParameter(INTENT.java, &quot;intent&quot;)</div><div class="line">       fields.forEach &#123; field -&gt;</div><div class="line">           //给fillIntent方法添加元素</div><div class="line">           intentMethod.addStatement(&quot;intent.putExtra(\$S, \$L)&quot;, field.name, field.name)</div><div class="line">       &#125;</div><div class="line">       typeBuilder.addMethod(intentMethod.build())</div><div class="line"></div><div class="line"></div><div class="line">       //start</div><div class="line">       typeBuilder.addMethod(MethodSpec.methodBuilder(&quot;start&quot;)</div><div class="line">               .addModifiers(Modifier.PUBLIC)</div><div class="line">               .addParameter(CONTEXT.java, &quot;context&quot;)</div><div class="line">               .addStatement(&quot;Intent intent = new Intent(context, \$L.class)&quot;, simpleName)</div><div class="line">               .addStatement(&quot;fillIntent(intent)&quot;)</div><div class="line">               .addStatement(&quot;context.startActivity(intent)&quot;)</div><div class="line">               .build())</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>对于fragment需要创建fillIntent和build方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//fragment也需要fillIntent</div><div class="line">     val intentMethod = MethodSpec.methodBuilder(&quot;fillIntent&quot;)</div><div class="line">             .addModifiers(Modifier.PRIVATE)</div><div class="line">             .addParameter(ClassType.INTENT.java, &quot;intent&quot;)</div><div class="line">     fields.forEach &#123; field -&gt;</div><div class="line">         //给fillIntent方法添加元素</div><div class="line">         intentMethod.addStatement(&quot;intent.putExtra(\$S, \$L)&quot;, field.name, field.name)</div><div class="line">     &#125;</div><div class="line">     typeBuilder.addMethod(intentMethod.build())</div><div class="line"></div><div class="line"></div><div class="line">     val originClassName = ClassName.get(packageName, simpleName.toString())</div><div class="line">     //通过builder方法返回实例</div><div class="line">     typeBuilder.addMethod(MethodSpec.methodBuilder(&quot;build&quot;)</div><div class="line">             .returns(originClassName)</div><div class="line">             .addModifiers(Modifier.PUBLIC)</div><div class="line">             .addStatement(&quot;\$T fragment = new \$T()&quot;, originClassName, originClassName)</div><div class="line">             .addStatement(&quot;Intent intent = new Intent()&quot;)</div><div class="line">             .addStatement(&quot;fillIntent(intent)&quot;)</div><div class="line">             .addStatement(&quot;fragment.setArguments(intent.getExtras())&quot;)</div><div class="line">             .addStatement(&quot;return fragment&quot;)</div><div class="line">             .build())</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><ul><li>写入文件<br>当构建好了TypeSpec，通过Filer进行文件写入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private fun writeJavaToFile(typeSpec: TypeSpec) &#123;</div><div class="line">       try &#123;</div><div class="line">           val file = JavaFile.builder(packageName, typeSpec).build()</div><div class="line">           file.writeTo(ProcessorEnv.filer)</div><div class="line">       &#125; catch (e: IOException) &#123;</div><div class="line">           e.printStackTrace()</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ul><p>这样，对应的生成文件就创建出来了。</p><ol><li>依赖注入<br>在文件生成之后，我们通过对应的Builder类来启动activity或者创建fragment实例，那我们如何直接在activity或者fragment中直接使用被注解的成员变量呢？这个其实也比较简单。</li></ol><ul><li>对于activity<br>在application中注册activity监听，然后通过onActivityCreate的回调方法中进行inject，这个方法会在oncreate之前调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"> override fun onActivityCreated(activity: Activity?, savedInstanceState: Bundle?) &#123;</div><div class="line">                if (activity == null) &#123;</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line">                if (!activity.javaClass.isAnnotationPresent(BuilderActivity::class.java)) &#123;</div><div class="line">                    //该activity没有被Builder标注，跳过</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line">                Log.d(&quot;KKActivityBuilder&quot;, &quot;onActivityCreated~&quot;)</div><div class="line">                val intent = activity.intent ?: return</div><div class="line">                var fields = activity.javaClass.declaredFields</div><div class="line">                inject(activity, fields, intent.extras)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">fun inject(activity: Activity?, fields: Array&lt;Field&gt;?, extras: Bundle?) &#123;</div><div class="line">        if (fields == null) &#123;</div><div class="line">            Log.d(&quot;KKActivityBuilder&quot;, &quot;declaredFields is null, should return~&quot;)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        fields.forEach &#123; field -&gt;</div><div class="line">            if (field.isAnnotationPresent(Fields::class.java)) &#123;</div><div class="line">                val name = field.name</div><div class="line">                try &#123;</div><div class="line">                    val access = field.isAccessible</div><div class="line">                    if (!access) field.isAccessible = true</div><div class="line">                    val value = getIntentExtra(extras, name)</div><div class="line">                    if (value != null) &#123;</div><div class="line">                        field.set(activity, getIntentExtra(extras, name))</div><div class="line">                    &#125; else &#123;</div><div class="line">                        Log.d(&quot;KKActivityBuilder&quot;, &quot;get value is null, continue~&quot;)</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (!access) field.isAccessible = false</div><div class="line"></div><div class="line">                &#125; catch (e: Exception) &#123;</div><div class="line">                    Log.e(&quot;KKActivityBuilder&quot;, &quot;error in -&gt; $&#123;e.message&#125;&quot;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun  getIntentExtra(extras: Bundle?, name: String): Any? &#123;</div><div class="line">        return extras?.get(name)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><ol><li>判断当前的activity是否被BuilderActivity修饰过</li><li>如果被BuilderActivity修饰过，遍历fields，判断是否被Fields修饰过</li><li>如果被Fields修饰过，从intent中获取field的name对应的value，以object的形式取出即可</li><li>通过反射，给field赋值为上一步取出的值。</li><li>完成</li></ol><ul><li>对于fragment<br>fragment的注入其实与activity基本一致，只是fragment没有相对应的生命周期的监听，不过我们可以在统一的基类的onCreateView方法中调用inject方法进行注入。实际的注入流程完全一样。不过activity是从intent中取值，fragment是从argument中取值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# 关于Adnroid processor&lt;/p&gt;
&lt;h2 id=&quot;LovelyInject&quot;&gt;&lt;a href=&quot;#LovelyInject&quot; class=&quot;headerlink&quot; title=&quot;LovelyInject&quot;&gt;&lt;/a&gt;LovelyInject&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>flutter的常见问题</title>
    <link href="https://xjlhhz.com/2018/10/08/20181008flutter%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://xjlhhz.com/2018/10/08/20181008flutter常见问题/</id>
    <published>2018-10-08T05:14:00.000Z</published>
    <updated>2018-11-04T09:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何实现android的match-param？"><a href="#如何实现android的match-param？" class="headerlink" title="如何实现android的match_param？"></a>如何实现android的match_param？</h4><p>flutter控件默认的宽高为wrap_content<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Container(</div><div class="line">    width:double.infinity,</div><div class="line">)</div></pre></td></tr></table></figure></p><p>通过设置宽度为double.infinity，将会将宽度填充父布局.</p><h4 id="如何获取状态栏的高度"><a href="#如何获取状态栏的高度" class="headerlink" title="如何获取状态栏的高度"></a>如何获取状态栏的高度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final double statusBarHeight = MediaQuery.of(context).padding.top;</div><div class="line">return new Padding(</div><div class="line">      padding: new EdgeInsets.only(top: statusBarHeight),</div><div class="line">      child: content</div><div class="line">);</div></pre></td></tr></table></figure><h4 id="如何检测系统返回键"><a href="#如何检测系统返回键" class="headerlink" title="如何检测系统返回键"></a>如何检测系统返回键</h4><p>需要再外部的Widget嵌套一层WillPopScope来捕获返回事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class HomePageState extends State&lt;HomePage&gt; &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line"></div><div class="line">    return WillPopScope(</div><div class="line">        child: Scaffold(</div><div class="line">          appBar: new AppBar(</div><div class="line">            backgroundColor: new Color(0xfffde23d),</div><div class="line">            title: new Text(&quot;快看漫画&quot;,</div><div class="line">                style: new TextStyle(color: const Color(0xff442509))),</div><div class="line">          ),</div><div class="line">          body: new Container(),</div><div class="line">        ),</div><div class="line">        onWillPop: _onWillPop);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Future&lt;bool&gt; _onWillPop() &#123;</div><div class="line">    exit(0);</div><div class="line">    return new Future.value(false);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以通过dart:io的方法exit(0)来退出app。</p><h4 id="bottomTab"><a href="#bottomTab" class="headerlink" title="bottomTab"></a>bottomTab</h4><p>flutter为我们提供了bottomTab的控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">bottomNavigationBar: new CupertinoTabBar(</div><div class="line">            items: &lt;BottomNavigationBarItem&gt;[</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                icon: getTabIcon(0),</div><div class="line">                title: getTabTitle(0)</div><div class="line">              ),</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                  icon: getTabIcon(1),</div><div class="line">                  title: getTabTitle(1)</div><div class="line">              ),</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                  icon: getTabIcon(2),</div><div class="line">                  title: getTabTitle(2)</div><div class="line">              ),</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                  icon: getTabIcon(3),</div><div class="line">                  title: getTabTitle(3)</div><div class="line">              )</div><div class="line">            ],</div><div class="line">            currentIndex: currentSelectIndex,</div><div class="line">            onTap: (index)&#123;</div><div class="line">              setState(() &#123;</div><div class="line">                currentSelectIndex = index;</div><div class="line">              &#125;);</div><div class="line">            &#125;,</div></pre></td></tr></table></figure></p><p>这个控件是Scaffold内置的控件，currentIndex设置当前选中的index，可以通过onTab获取选中的index。</p><h4 id="Column内部控件的居中"><a href="#Column内部控件的居中" class="headerlink" title="Column内部控件的居中"></a>Column内部控件的居中</h4><p>可以通过mainAxisAlignment属性来设置整体列表的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">child: new Column(</div><div class="line">                     mainAxisAlignment: MainAxisAlignment.center,</div><div class="line">                     children: &lt;Widget&gt;[</div><div class="line">                       new CircleAvatar(</div><div class="line">                         backgroundImage: new AssetImage(&apos;images/ic_personal_headportrait.png&apos;),</div><div class="line">                       ),</div><div class="line">                       new Text(&quot;点击登陆&quot;)</div><div class="line">                     ],</div><div class="line">                   )</div></pre></td></tr></table></figure></p><h4 id="对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。"><a href="#对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。" class="headerlink" title="对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。"></a>对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何实现android的match-param？&quot;&gt;&lt;a href=&quot;#如何实现android的match-param？&quot; class=&quot;headerlink&quot; title=&quot;如何实现android的match_param？&quot;&gt;&lt;/a&gt;如何实现android的ma
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A Tour of the Dart Language</title>
    <link href="https://xjlhhz.com/2018/09/09/20180919Dart%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>https://xjlhhz.com/2018/09/09/20180919Dart文档翻译/</id>
    <published>2018-09-09T05:14:00.000Z</published>
    <updated>2018-11-04T09:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# A Tour of the Dart Language</p><p>下面是一个比较基础的Dart的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//定义一个方法</div><div class="line">printInteger(int aNumber) &#123;</div><div class="line">  print(&apos;The number is $aNumber.&apos;); // 输出到终端</div><div class="line">&#125;</div><div class="line"></div><div class="line">//一个app启动的入口</div><div class="line">main() &#123;</div><div class="line">  var number = 42; // 初始化一个变量</div><div class="line">  printInteger(number); // 调用方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><ul><li>每一个变量都是一个object，并且每一个object都是class的实例，甚至是一个数字、方法或者是null也是object，所有的对象继承于Object。</li><li>虽然Dart是一个强类型，但类型的声明是可选的，因为Dart可以推断出其类型，就像上面的代码，数字42将被推断出其类型是int。如果我们想要明确的一个对象没有指定的类型，那么我们可以使用动态类型。如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void log(Object object) &#123;</div><div class="line">  print(object.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// Returns a Boolean representation for [arg], which must</div><div class="line">/// be a String or bool.</div><div class="line">bool convertToBool(dynamic arg) &#123;</div><div class="line">  if (arg is bool) return arg;</div><div class="line">  if (arg is String) return arg == &apos;true&apos;;</div><div class="line">  throw ArgumentError(&apos;Cannot convert $arg to a bool.&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>我们可以将参数定义为dynamic，也可以将参数定义为Object。有一些方法是任意的对象都会有的，比如说上面的log方法，接收了一个Object的参数，然后调用了object的toString方法，dynamic是一个比较复杂的关键字，这就意味着Dart的类型系统足够复杂，复杂到能够展示所有其支持的类型，或者其值需要通过交互来获得或者它是一个在静态类型系统的范围之外的，因此我们能够在运行时明确的指出其类型和值。</p><ul><li><p>Dart支持普通类型，比如说 List<int>和List<dynamic> ，表示int类型的列表和动态类型的列表</dynamic></int></p></li><li><p>dart支持顶层方法，比如说main方法，和方法绑定在class或者object一样(静态和实例方法除外)， 同样的你也可以在方法内创建方法，嵌套方法或者局部方法</p></li><li>同样的，Dart支持顶层变量，和绑定在class或者object的变量是一样的(静态和实例变量)，实例变量在有些时候被成为是fields or properties.</li><li>和java不一样的是，Dart没有public, protected, and private关键字，如果一个标识符已括号开始， (_), 那么它是库私有的，</li><li>标识符可以从下划线(_)或者字母开始，通过任意的字母加数字的合并来排序</li><li>有时候我们可能疑惑某个东西是一个语句或者表达式，所以它可以帮助我们区分这两个东西</li><li>Dart工具可以帮我们反映两种类型的问题： 警告和错误，警告只是预测我们的代码可能会不能如期工作，但是它们不会中断我们代码的运行。Error可能出现在编译期间或者运行时，一个编译期间的错误将会直接停止代码的运行，一个运行时的错误将会抛出异常</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name = &apos;Bob&apos;;</div></pre></td></tr></table></figure><p>定义一个String类型的变量，并为其赋值为Bob。如果一个对象我们不想让它只受限于单一类型，那么我们可以将它的类型定义为Object或者Dynamic。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dynamic name = &apos;Bob&apos;;</div></pre></td></tr></table></figure></p><p>当然我们也可以声明一个确定的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String name = &apos;Bob&apos;;</div></pre></td></tr></table></figure></p><p>相对于确定类型，Dart更推荐我们使用var。</p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果一个没有初始化的变量，那么它的默认值就是null，甚至的数值类型也会未初始化时，也会是null，因为数字类型和其他类型在dart中都是一样的，都是对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int lineCount;</div><div class="line">assert(lineCount == null);</div></pre></td></tr></table></figure></p><p>assert将会在生产环境中会忽略，如果在开发环境中，assert的不为真，那么将会抛出异常。</p><h2 id="final和const"><a href="#final和const" class="headerlink" title="final和const"></a>final和const</h2><p>如果我们不尝试去改变一个变量，我们可以使用final或const去修饰变量，final的变量只允许被设置一次，const变量是一个编译时常量，const其实内部也是final，一个顶层的、class的final变量将会在第一次使用时赋值。实例变量不能声明为final但是可以声明为const。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final name = &apos;Bob&apos;; // Without a type annotation</div><div class="line">final String nickname = &apos;Bobby&apos;;</div></pre></td></tr></table></figure></p><p>一旦赋值过后将不能再进行改变。下面的语句将会在编译期间报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = &apos;Alice&apos;; // Error: a final variable can only be set once.</div></pre></td></tr></table></figure></p><p>const关键字不仅仅能修饰变量，我们可以用来创建常量，也能够声明构造器去创建常量，每一个变量都可以有一个常量值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//const创建常量[]</div><div class="line">var foo = const [];</div><div class="line">final bar = const [];</div><div class="line">const baz = []; // Equivalent to `const []`</div></pre></td></tr></table></figure></p><p>实际上我们可以忽略初始化时const的声明。比如说下面的[1, 2, 3]就是一个const的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = [1, 2, 3];</div></pre></td></tr></table></figure></p><p>同样的，const也不能够被赋值。</p><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><ul><li>数值类型</li><li>String类型</li><li>boolean类型</li><li>list类型(通常是数组)</li><li>map类型</li><li>runes(unicode的String)</li><li>symbols</li></ul><p>在dart中，每一个变量都是一个对象，一个class的实例，我们可以通过构造函数来初始化变量，一些内置类型有它们特有的构造函数，比如说我们可以通过Map()来创建map对象。</p><h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>Dart的numbers有两种表示方式：</p><ul><li>int 取值为-2的63次方到 2的63次方 - 1</li><li>double</li></ul><p>我们可以对这两种类型使用number提供的方法，比如说+-*/,或者abs、ceil和floor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int x = 1;</div><div class="line">int hex = 0xDEADBEEF;</div><div class="line"></div><div class="line">double y = 1.1;</div><div class="line">double exponents = 1.42e5;</div></pre></td></tr></table></figure></p><p>下面是一个String和number类型互转的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// String -&gt; int</div><div class="line">var one = int.parse(&apos;1&apos;);</div><div class="line">assert(one == 1);</div><div class="line"></div><div class="line">// String -&gt; double</div><div class="line">var onePointOne = double.parse(&apos;1.1&apos;);</div><div class="line">assert(onePointOne == 1.1);</div><div class="line"></div><div class="line">// int -&gt; String</div><div class="line">String oneAsString = 1.toString();</div><div class="line">assert(oneAsString == &apos;1&apos;);</div><div class="line"></div><div class="line">// double -&gt; String</div><div class="line">String piAsString = 3.14159.toStringAsFixed(2);</div><div class="line">assert(piAsString == &apos;3.14&apos;);</div></pre></td></tr></table></figure></p><p>下面是&lt;&lt; &gt;&gt; | 符号的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110</div><div class="line">assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001</div><div class="line">assert((3 | 4) == 7); // 0011 | 0100 == 0111</div></pre></td></tr></table></figure></p><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>Dart String是一个UTF-16编码格式的，下面是几个创建String的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s1 = &apos;Single quotes work well for string literals.&apos;;</div><div class="line">var s2 = &quot;Double quotes work just as well.&quot;;</div><div class="line">var s3 = &apos;It\&apos;s easy to escape the string delimiter.&apos;;</div><div class="line">var s4 = &quot;It&apos;s even easier to use the other delimiter.&quot;;</div></pre></td></tr></table></figure></p><p>我们可以通过$在String的字符串中引用其他变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s = &apos;string interpolation&apos;;</div><div class="line"></div><div class="line">assert(&apos;Dart has $s, which is very handy.&apos; ==</div><div class="line">    &apos;Dart has string interpolation, &apos; +</div><div class="line">        &apos;which is very handy.&apos;);</div><div class="line">assert(&apos;That deserves all caps. &apos; +</div><div class="line">        &apos;$&#123;s.toUpperCase()&#125; is very handy!&apos; ==</div><div class="line">    &apos;That deserves all caps. &apos; +</div><div class="line">        &apos;STRING INTERPOLATION is very handy!&apos;);</div></pre></td></tr></table></figure></p><p>需要注意的是 == 是用来比较两个对象是否相等<br>String类型也能用+来进行拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s1 = &apos;String &apos;</div><div class="line">    &apos;concatenation&apos;</div><div class="line">    &quot; works even over line breaks.&quot;;</div><div class="line">assert(s1 ==</div><div class="line">    &apos;String concatenation works even over &apos;</div><div class="line">    &apos;line breaks.&apos;);</div><div class="line"></div><div class="line">var s2 = &apos;The + operator &apos; + &apos;works, as well.&apos;;</div><div class="line">assert(s2 == &apos;The + operator works, as well.&apos;);</div></pre></td></tr></table></figure></p><p>如果我们想要创建一个多行的String，那么我们可以使用’’’或者”””来创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s1 = &apos;&apos;&apos;</div><div class="line">You can create</div><div class="line">multi-line strings like this one.</div><div class="line">&apos;&apos;&apos;;</div><div class="line"></div><div class="line">var s2 = &quot;&quot;&quot;This is also a</div><div class="line">multi-line string.&quot;&quot;&quot;;</div></pre></td></tr></table></figure></p><p>如果我们想要创建一个raw字符串，我们可以在字符串前面拼接一个r<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var s = r&apos;In a raw string, not even \n gets special treatment.&apos;;</div></pre></td></tr></table></figure></p><p>如果我们想要将编码后的字符，比如说一些表情和文字符号，转化成字符串，那么我们可以使用Runnes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">main() &#123;</div><div class="line">  var clapping = &apos;\u&#123;1f44f&#125;&apos;;</div><div class="line">  print(clapping);</div><div class="line">  print(clapping.codeUnits);</div><div class="line">  print(clapping.runes.toList());</div><div class="line"></div><div class="line">  Runes input = new Runes(</div><div class="line">      &apos;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&apos;);</div><div class="line">  print(new String.fromCharCodes(input));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>String也可以作为编译时常量，也就是能被const修饰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// These work in a const string.</div><div class="line">const aConstNum = 0;</div><div class="line">const aConstBool = true;</div><div class="line">const aConstString = &apos;a constant string&apos;;</div><div class="line"></div><div class="line">// These do NOT work in a const string.</div><div class="line">var aNum = 0;</div><div class="line">var aBool = true;</div><div class="line">var aString = &apos;a string&apos;;</div><div class="line">const aConstList = [1, 2, 3];</div><div class="line"></div><div class="line">const validConstString = &apos;$aConstNum $aConstBool $aConstString&apos;;</div><div class="line">// const invalidConstString = &apos;$aNum $aBool $aString $aConstList&apos;;</div></pre></td></tr></table></figure></p><h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><p>为了展示boolean，Dart使用了bool类型，只有两个对象有这个类型，那就是true和false。这两个都是编译时常量。<br>Dart是类型安全的，这就意味着我们不能够在判断中使用非bool类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Check for an empty string.</div><div class="line">var fullName = &apos;&apos;;</div><div class="line">assert(fullName.isEmpty);</div><div class="line"></div><div class="line">// Check for zero.</div><div class="line">var hitPoints = 0;</div><div class="line">assert(hitPoints &lt;= 0);</div><div class="line"></div><div class="line">// Check for null.</div><div class="line">var unicorn;</div><div class="line">assert(unicorn == null);</div><div class="line"></div><div class="line">// Check for NaN.</div><div class="line">var iMeantToDoThis = 0 / 0;</div><div class="line">assert(iMeantToDoThis.isNaN);</div></pre></td></tr></table></figure></p><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>大部分语言中最常用到的集合类应该就是数组或有序的对象组，在Dart中，数组是List对象，所以大部分人将其称之为列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var list = [1, 2, 3];</div></pre></td></tr></table></figure></p><p>同样的，list是有类型的，在上面的例子能够推断出类型是List<int>,如果尝试将非int类型的对象添加到列表中，那么将会报错。<br>和其他语言一样，Dart的list也是从0开始计数的。</int></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Dart中map也是有类型的，map中的key也是唯一的，但是value可以重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var gifts = &#123; // Key：Value&apos;first &apos; ：&apos;partridge&apos; ，&apos;second&apos; ：&apos;turtledoves&apos; ，&apos; first &apos; ：&apos;golden rings&apos; &#125;;</div><div class="line"></div><div class="line">var nobleGases = &#123; 2 ：&apos;氦&apos; ，10 ：&apos;氖&apos; ，18 ：&apos;氩&apos; ，&#125;;</div></pre></td></tr></table></figure></p><p>我们可以通过Map的构造函数来创建map对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var gifts = Map （）;</div><div class="line">gifts[ &apos;first&apos; ] = &apos;鹧&apos;&apos; ;</div><div class="line">gifts[ &apos;second&apos; ] = &apos;turtledoves&apos; ;</div><div class="line">gifts[ &apos;第五&apos; ] = &apos;金戒指&apos; ;       </div><div class="line"></div><div class="line">var nobleGases = Map （）;</div><div class="line">nobleGases[ 2 ] = &apos;氦&apos; ;</div><div class="line">nobleGases[ 10 ] = &apos;霓虹灯&apos; ;</div><div class="line">nobleGases[ 18 ] = &apos;氩&apos; ;</div></pre></td></tr></table></figure></p><p>如果map中不存在这个key值，那么将会返回null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var gifts = &#123; &apos;first&apos; ：&apos;partridge&apos; &#125;; 断言（gifts [ &apos;fifth&apos; ] == null ）;</div></pre></td></tr></table></figure></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>符号是用来作为标识符的,如果我们想获取标识符的符号，那么通过#添加标识符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#radix</div><div class="line">#bar</div></pre></td></tr></table></figure></p><p>符号文字是编译时常量</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Dart是一种真正的面向对象语言，所以就算是函数也是对象，并且其类型是Function对象，这就意味着函数可以作为变量或者作为参数传递到其他方法，如果是一个函数，我们可以直接调用Dart的类实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bool isNoble(int atomicNumber) &#123;</div><div class="line">  return _nobleGases[atomicNumber] != null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然Dart推荐我们对于函数设置返回值类型，但是如果我们忽略了返回值，dart仍然可以运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isNoble(atomicNumber) &#123;</div><div class="line">  return _nobleGases[atomicNumber] != null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果我们的函数中只有一个表达式，那么我们可以简化它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;</div></pre></td></tr></table></figure></p><p>这个=&gt; expr表示  { return expr; }.<br>expr只能是表达式而不能是语句</p><p>一个函数可以有两种类型得参数，必须的和可选的。如果是必须的参数，那么它会排在前面，然后后面跟着可选参数，我们可以用注解@require来标志必须的参数。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>当调用一个参数时，可以指定命名参数，例如paramName: value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enableFlags （bold ：true ，hidden ：false ）;</div></pre></td></tr></table></figure></p><p>当定义一个方法时，使用 {param1, param2, …} 来指定命名参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;...&#125;</div></pre></td></tr></table></figure></p><p>Flutter实例创建表达式可能变得复杂，因此窗口小部件构造函数仅使用命名参数<br>我们可以在任何Dart的代码中使用@required注解，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const Scrollbar （&#123; Key key ，@required Widget child &#125;）</div></pre></td></tr></table></figure></p><p>当一个Scrollbar构造时，如果child不存在，那么将会报错。<br>required定一个meta包中，使用时我们需要先引入包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import package:meta/meta.dart</div><div class="line"></div><div class="line">//flutter</div><div class="line">package:flutter/material.dart.</div></pre></td></tr></table></figure></p><p>我们可以通过[]来设置一个可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String say(String from, String msg, [String device]) &#123;</div><div class="line">  var result = &apos;$from says $msg&apos;;</div><div class="line">  if (device != null) &#123;</div><div class="line">    result = &apos;$result with a $device&apos;;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面两个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//不传可选参数</div><div class="line">assert(say(&apos;Bob&apos;, &apos;Howdy&apos;) == &apos;Bob says Howdy&apos;);</div><div class="line">//传可选参数</div><div class="line">assert(say(&apos;Bob&apos;, &apos;Howdy&apos;, &apos;smoke signal&apos;) ==</div><div class="line">    &apos;Bob says Howdy with a smoke signal&apos;);</div></pre></td></tr></table></figure></p><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>在函数中，我们可以定义默认的值，这个默认值必须是编译时常量，如果没有设置默认值，那么编译器会给它一个默认值，null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Sets the [bold] and [hidden] flags ...</div><div class="line">void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;</div><div class="line"></div><div class="line">// bold will be true; hidden will be false.</div><div class="line">enableFlags(bold: true);</div></pre></td></tr></table></figure></p><p>同样的，也能设置list和map的默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void doStuff(</div><div class="line">    &#123;List&lt;int&gt; list = const [1, 2, 3],</div><div class="line">    Map&lt;String, String&gt; gifts = const &#123;</div><div class="line">      &apos;first&apos;: &apos;paper&apos;,</div><div class="line">      &apos;second&apos;: &apos;cotton&apos;,</div><div class="line">      &apos;third&apos;: &apos;leather&apos;</div><div class="line">    &#125;&#125;) &#123;</div><div class="line">  print(&apos;list:  $list&apos;);</div><div class="line">  print(&apos;gifts: $gifts&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>每一个app都会有一个顶层的main方法，作为app的入口。这个main方法将会返回void并且接收List<string>的可选参数。<br>下面是一个web的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void main() &#123;</div><div class="line">  querySelector(&apos;#sample_text_id&apos;)</div><div class="line">    ..text = &apos;Click me!&apos;</div><div class="line">    ..onClick.listen(reverseText);</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p><p>其中，..是一个流的使用标识符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void main(List&lt;String&gt; arguments) &#123;</div><div class="line">  print(arguments);</div><div class="line"></div><div class="line">  assert(arguments.length == 2);</div><div class="line">  assert(int.parse(arguments[0]) == 1);</div><div class="line">  assert(arguments[1] == &apos;test&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以将一个函数作为参数传入另外一个方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void printElement(int element) &#123;</div><div class="line">  print(element);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var list = [1, 2, 3];</div><div class="line"></div><div class="line">// Pass printElement as a parameter.</div><div class="line">list.forEach(printElement);</div></pre></td></tr></table></figure></p><p>我们也能够将一个方法赋值给变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var loudify = (msg) =&gt; &apos;!!! $&#123;msg.toUpperCase()&#125; !!!&apos;;</div><div class="line">assert(loudify(&apos;hello&apos;) == &apos;!!! HELLO !!!&apos;);</div></pre></td></tr></table></figure></p><h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>大部分的方法都是有名称的，比如说main() 或者 printElement(). 当然我们也能够创建匿名方法，有些时候也被称为lambda或者闭包。所以我们能够给一个变量赋值为匿名方法。下面一个是一个匿名函数声明方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">([[Type] param1[, …]]) &#123;</div><div class="line">  codeBlock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>括号内接收入参，花括号处表示执行的代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var list = [&apos;apples&apos;, &apos;bananas&apos;, &apos;oranges&apos;];</div><div class="line">list.forEach((item) &#123;</div><div class="line">  print(&apos;$&#123;list.indexOf(item)&#125;: $item&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="语法范围"><a href="#语法范围" class="headerlink" title="语法范围"></a>语法范围</h3><p>Dart也有自己的语法范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">bool topLevel = true;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var insideMain = true;</div><div class="line"></div><div class="line">  void myFunction() &#123;</div><div class="line">    var insideFunction = true;</div><div class="line"></div><div class="line">    void nestedFunction() &#123;</div><div class="line">      var insideNestedFunction = true;</div><div class="line"></div><div class="line">      assert(topLevel);</div><div class="line">      assert(insideMain);</div><div class="line">      assert(insideFunction);</div><div class="line">      assert(insideNestedFunction);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="词汇闭包"><a href="#词汇闭包" class="headerlink" title="词汇闭包"></a>词汇闭包</h3><p>在语法范围内，一个函数闭包也能被使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/// Returns a function that adds [addBy] to the</div><div class="line">/// function&apos;s argument.</div><div class="line">Function makeAdder(num addBy) &#123;</div><div class="line">  return (num i) =&gt; addBy + i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  // Create a function that adds 2.</div><div class="line">  var add2 = makeAdder(2);</div><div class="line"></div><div class="line">  // Create a function that adds 4.</div><div class="line">  var add4 = makeAdder(4);</div><div class="line"></div><div class="line">  assert(add2(3) == 5);</div><div class="line">  assert(add4(3) == 7);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Function定义出来一个函数闭包，然后在main方法中，将这个函数闭包赋值给add2和add4</p><h3 id="测试方法是否相等"><a href="#测试方法是否相等" class="headerlink" title="测试方法是否相等"></a>测试方法是否相等</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void foo() &#123;&#125; // A top-level function</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">  static void bar() &#123;&#125; // A static method</div><div class="line">  void baz() &#123;&#125; // An instance method</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var x;</div><div class="line"></div><div class="line">  // Comparing top-level functions.</div><div class="line">  x = foo;</div><div class="line">  assert(foo == x);</div><div class="line"></div><div class="line">  // Comparing static methods.</div><div class="line">  x = A.bar;</div><div class="line">  assert(A.bar == x);</div><div class="line"></div><div class="line">  // Comparing instance methods.</div><div class="line">  var v = A(); // Instance #1 of A</div><div class="line">  var w = A(); // Instance #2 of A</div><div class="line">  var y = w;</div><div class="line">  x = w.baz;</div><div class="line"></div><div class="line">  // These closures refer to the same instance (#2),</div><div class="line">  // so they&apos;re equal.</div><div class="line">  assert(y.baz == x);</div><div class="line"></div><div class="line">  // These closures refer to different instances,</div><div class="line">  // so they&apos;re unequal.</div><div class="line">  assert(v.baz != w.baz);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>所有的函数都会返回值，如果没有指定返回值，那么会默认返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo() &#123;&#125;</div><div class="line"></div><div class="line">assert(foo() == null);</div></pre></td></tr></table></figure></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Dart也具有</p><ul><li>三目运算符, expr1 ? expr2 : expr3</li><li>类型判断和转化 as    is    is!,<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (emp is Person) &#123;</div><div class="line">  // Type check</div><div class="line">  emp.firstName = &apos;Bob&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>如果is为true，那么将会直接将原对象转化为指定对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(emp as Person).firstName = &apos;Bob&apos;;</div></pre></td></tr></table></figure><p>使用emp不是person类型，那么将会直接抛异常</p><ul><li>/, 默认是double，如果需要返回int值，那么需要使用~/</li></ul><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Assign value to a</div><div class="line">a = value;</div><div class="line">// Assign value to b if b is null; otherwise, b stays the same</div><div class="line">b ??= value;</div></pre></td></tr></table></figure><p>??= 将会判断b是否为null，如果为null了再执行赋值操作。</p><h3 id="扩展表达式"><a href="#扩展表达式" class="headerlink" title="扩展表达式"></a>扩展表达式</h3><ul><li>三目运算符 condition ? expr1 : expr2</li><li>evls表示表达式，expr1 ?? expr2，如果expr1非null，那么返回expr1，否则返回expr2</li></ul><p>###流式使用<br>需要使用..符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">querySelector(&apos;#confirm&apos;) // Get an object.</div><div class="line">  ..text = &apos;Confirm&apos; // Use its members.</div><div class="line">  ..classes.add(&apos;important&apos;)</div><div class="line">  ..onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));</div></pre></td></tr></table></figure></p><p>第一个方法，将会返回一个对象，如果后续紧跟..，那么将会持续的返回相同的对象，并且进行操作。上面的语句相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var button = querySelector(&apos;#confirm&apos;);</div><div class="line">button.text = &apos;Confirm&apos;;</div><div class="line">button.classes.add(&apos;important&apos;);</div><div class="line">button.onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));</div></pre></td></tr></table></figure></p><p>而且..可以嵌套使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">final addressBook = (AddressBookBuilder()</div><div class="line">      ..name = &apos;jenny&apos;</div><div class="line">      ..email = &apos;jenny@example.com&apos;</div><div class="line">      ..phone = (PhoneNumberBuilder()</div><div class="line">            ..number = &apos;415-555-0100&apos;</div><div class="line">            ..label = &apos;home&apos;)</div><div class="line">          .build())</div><div class="line">    .build();</div></pre></td></tr></table></figure></p><p>需要注意的是，我们只能在有返回值的方法后使用..，如果在一个返回值为void的方法之后使用..将会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sb = StringBuffer();</div><div class="line">sb.write(&apos;foo&apos;)</div><div class="line">  ..write(&apos;bar&apos;); // Error: method &apos;write&apos; isn&apos;t defined for &apos;void&apos;.</div></pre></td></tr></table></figure></p><h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><ul><li>()表示一个方法</li><li>[]表示一个list的位置</li><li>.属性</li><li>?.表示不为null的取值</li></ul><h3 id="循环语句基本与其他语言一致"><a href="#循环语句基本与其他语言一致" class="headerlink" title="循环语句基本与其他语言一致"></a>循环语句基本与其他语言一致</h3><ul><li><p>if and else</p></li><li><p>for loops</p></li><li><p>while and do-while loops</p></li><li><p>break and continue</p></li><li><p>switch and case</p></li><li><p>assert</p></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的创建可以使用new也能不使用new,两个调用的操作是一致的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p1 = Point(2, 2);</div><div class="line">var p2 = Point.fromJson(&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;);</div><div class="line"></div><div class="line">var p1 = new Point(2, 2);</div><div class="line">var p2 = new Point.fromJson(&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;);</div></pre></td></tr></table></figure></p><p>有一些class会提供常量级的构造函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var p = const ImmutablePoint(2, 2);</div></pre></td></tr></table></figure></p><p>如果是常量级构造函数，那么其构造出来的对象是相同的。</p><h3 id="获取对象类型"><a href="#获取对象类型" class="headerlink" title="获取对象类型"></a>获取对象类型</h3><p>如果要在运行时获取对象类型，可以通过对象属性runtimeType，它会返回对象的类型。</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x; // Declare instance variable x, initially null.</div><div class="line">  num y; // Declare y, initially null.</div><div class="line">  num z = 0; // Declare z, initially 0.</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果没有初始化实例变量，那么默认的初始化值会是null<br>所有的实例变量都会有一个默认的get方法，如果这个类非final的，那么也会生成默认的set方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  Point(num x, num y) &#123;</div><div class="line">    // There&apos;s a better way to do this, stay tuned.</div><div class="line">    this.x = x;</div><div class="line">    this.y = y;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于构造函数，有一个比较简便的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  // Syntactic sugar for setting x and y</div><div class="line">  // before the constructor body runs.</div><div class="line">  Point(this.x, this.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>默认构造函数是无参的。构造函数不能被继承<br>使用命名的构造函数可以让类的创建更加清晰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  Point(this.x, this.y);</div><div class="line"></div><div class="line">  // Named constructor</div><div class="line">  Point.origin() &#123;</div><div class="line">    x = 0;</div><div class="line">    y = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="创建一个非默认的超类构造函数"><a href="#创建一个非默认的超类构造函数" class="headerlink" title="创建一个非默认的超类构造函数"></a>创建一个非默认的超类构造函数</h3><p>通常情况下，超类有一个未命名的构造函数，超类的构造函数是再子类构造函数开始的时候调用的，如果一个初始化的list开始使用，它将会经过下面的三个过程：</p><ul><li>initializer list</li><li>superclass’s no-arg constructor</li><li>main class’s no-arg constructor</li></ul><p>如果父类没有未命名的构造函数，那么我们需要显式的调用父类的构造函数。通过：来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Employee extends Person &#123;</div><div class="line">  Employee() : super.fromJson(getDefaultData());</div><div class="line">  // ···</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在构造函数后面显式的调用父类的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Point.fromJson(Map&lt;String, num&gt; json)</div><div class="line">    : x = json[&apos;x&apos;],</div><div class="line">      y = json[&apos;y&apos;] &#123;</div><div class="line">  print(&apos;In Point.fromJson(): ($x, $y)&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在构造函数的方法执行之前，使用:进行赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  final num x;</div><div class="line">  final num y;</div><div class="line">  final num distanceFromOrigin;</div><div class="line"></div><div class="line">  Point(x, y)</div><div class="line">      : x = x,</div><div class="line">        y = y,</div><div class="line">        distanceFromOrigin = sqrt(x * x + y * y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main() &#123;</div><div class="line">  var p = new Point(2, 3);</div><div class="line">  print(p.distanceFromOrigin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h3><p>用factory关键字标志，从cache中返回实例</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>实例方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &apos;dart:math&apos;;</div><div class="line"></div><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  Point(this.x, this.y);</div><div class="line"></div><div class="line">  num distanceTo(Point other) &#123;</div><div class="line">    var dx = x - other.x;</div><div class="line">    var dy = y - other.y;</div><div class="line">    return sqrt(dx * dx + dy * dy);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="重写get和set"><a href="#重写get和set" class="headerlink" title="重写get和set"></a>重写get和set</h3><p>我们可以利用get、set关键字重写get和set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">  num left, top, width, height;</div><div class="line"></div><div class="line">  Rectangle(this.left, this.top, this.width, this.height);</div><div class="line"></div><div class="line">  // Define two calculated properties: right and bottom.</div><div class="line">  num get right =&gt; left + width;</div><div class="line">  set right(num value) =&gt; left = value - width;</div><div class="line">  num get bottom =&gt; top + height;</div><div class="line">  set bottom(num value) =&gt; top = value - height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var rect = Rectangle(3, 4, 20, 15);</div><div class="line">  assert(rect.left == 3);</div><div class="line">  rect.right = 12;</div><div class="line">  assert(rect.left == -8);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>抽象方法只能存在于抽象类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abstract class Doer &#123;</div><div class="line">  // Define instance variables and methods...</div><div class="line"></div><div class="line">  void doSomething(); // Define an abstract method.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类都隐式定义一个接口，该接口包含该类的所有实例成员及其实现的任何接口。如果要在不继承B实现的情况下创建支持B类API的A类，则A类应实现B接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// A person. The implicit interface contains greet().</div><div class="line">class Person &#123;</div><div class="line">  // In the interface, but visible only in this library.</div><div class="line">  final _name;</div><div class="line"></div><div class="line">  // Not in the interface, since this is a constructor.</div><div class="line">  Person(this._name);</div><div class="line"></div><div class="line">  // In the interface.</div><div class="line">  String greet(String who) =&gt; &apos;Hello, $who. I am $_name.&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// An implementation of the Person interface.</div><div class="line">class Impostor implements Person &#123;</div><div class="line">  get _name =&gt; &apos;&apos;;</div><div class="line"></div><div class="line">  String greet(String who) =&gt; &apos;Hi $who. Do you know who I am?&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String greetBob(Person person) =&gt; person.greet(&apos;Bob&apos;);</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  print(greetBob(Person(&apos;Kathy&apos;)));</div><div class="line">  print(greetBob(Impostor()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>@verride注解表示复写</p><h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>operator关键字</p><h3 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h3><p>为了检测是否有地方尝试访问不存在的方法或者变量，我们可以复写noSuchMethod方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">  // Unless you override noSuchMethod, using a</div><div class="line">  // non-existent member results in a NoSuchMethodError.</div><div class="line">  @override</div><div class="line">  void noSuchMethod(Invocation invocation) &#123;</div><div class="line">    print(&apos;You tried to use a non-existent member: &apos; +</div><div class="line">        &apos;$&#123;invocation.memberName&#125;&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果有满足下面的地方，我们就能够调用一个未实现的方法</p><ul><li>接收者的类型是dynamic</li><li>接收者是静态类型，定义了未实现的方法，或者动态类型的接收者实现了 noSuchMethod()方法</li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum Color &#123; red, green, blue &#125;</div></pre></td></tr></table></figure><p>每一个枚举都有相应的位置，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">assert(Color.red.index == 0);</div><div class="line">assert(Color.green.index == 1);</div><div class="line">assert(Color.blue.index == 2);</div></pre></td></tr></table></figure></p><p>可以直接从枚举中获取出所有的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Color&gt; colors = Color.values;</div><div class="line">assert(colors[2] == Color.blue);</div></pre></td></tr></table></figure></p><p>获取出来就是一个list</p><h3 id="类的特性：-Mixins-混入"><a href="#类的特性：-Mixins-混入" class="headerlink" title="类的特性： Mixins- 混入"></a>类的特性： Mixins- 混入</h3><p>混入主要是用来重用代码的，我们可以使用with多个混入的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Musician extends Performer with Musical &#123;</div><div class="line">  // ···</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Maestro extends Person</div><div class="line">    with Musical, Aggressive, Demented &#123;</div><div class="line">  Maestro(String maestroName) &#123;</div><div class="line">    name = maestroName;</div><div class="line">    canConduct = true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了实现混入，我们需要创建一个没有构造函数的类，而且没有调用super的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">abstract class Musical &#123;</div><div class="line">  bool canPlayPiano = false;</div><div class="line">  bool canCompose = false;</div><div class="line">  bool canConduct = false;</div><div class="line"></div><div class="line">  void entertainMe() &#123;</div><div class="line">    if (canPlayPiano) &#123;</div><div class="line">      print(&apos;Playing piano&apos;);</div><div class="line">    &#125; else if (canConduct) &#123;</div><div class="line">      print(&apos;Waving hands&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">      print(&apos;Humming to self&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="类变量和方法"><a href="#类变量和方法" class="headerlink" title="类变量和方法"></a>类变量和方法</h3><p>静态变量，在类的外部也能够使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Queue &#123;</div><div class="line">  static const initialCapacity = 16;</div><div class="line">  // ···</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  assert(Queue.initialCapacity == 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>静态方法,内部不能使用this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import &apos;dart:math&apos;;</div><div class="line"></div><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line">  Point(this.x, this.y);</div><div class="line"></div><div class="line">  static num distanceBetween(Point a, Point b) &#123;</div><div class="line">    var dx = a.x - b.x;</div><div class="line">    var dy = a.y - b.y;</div><div class="line">    return sqrt(dx * dx + dy * dy);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var a = Point(2, 2);</div><div class="line">  var b = Point(4, 4);</div><div class="line">  var distance = Point.distanceBetween(a, b);</div><div class="line">  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);</div><div class="line">  print(distance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h3><p>跟java基本一致</p><h2 id="使用libraries"><a href="#使用libraries" class="headerlink" title="使用libraries"></a>使用libraries</h2><p>内置的包以dart:开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;dart:html&apos;;</div></pre></td></tr></table></figure></p><p>本地的包，以 package: scheme开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;package:test/test.dart&apos;;</div></pre></td></tr></table></figure></p><p>我们还可以给lib指定别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &apos;package:lib1/lib1.dart&apos;;</div><div class="line">import &apos;package:lib2/lib2.dart&apos; as lib2;</div><div class="line"></div><div class="line">// Uses Element from lib1.</div><div class="line">Element element1 = Element();</div><div class="line"></div><div class="line">// Uses Element from lib2.</div><div class="line">lib2.Element element2 = lib2.Element();</div></pre></td></tr></table></figure></p><p>我们还可以导入一个包的部分元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Import only foo.</div><div class="line">import &apos;package:lib1/lib1.dart&apos; show foo;</div><div class="line"></div><div class="line">// Import all names EXCEPT foo.</div><div class="line">import &apos;package:lib2/lib2.dart&apos; hide foo;</div></pre></td></tr></table></figure></p><p>我们还可以延迟加载包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;package:greetings/hello.dart&apos; deferred as hello;</div></pre></td></tr></table></figure></p><p>如果我们需要这个包，我们可以在代码中load这个包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Future greet() async &#123;</div><div class="line">  await hello.loadLibrary();</div><div class="line">  hello.printGreeting();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>async表示同步，await表示阻塞，Future对象出现再Dart的包中，通畅同步的的方法中会返回对象，如果一个future完成了，那么它的值就可以被使用了。<br>所以，Future会结合async和await使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Future checkVersion() async &#123;</div><div class="line">  var version = await lookUpVersion();</div><div class="line">  // Do something with version</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# A Tour of the Dart Language&lt;/p&gt;
&lt;p&gt;下面是一个比较基础的Dart的方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PathMeasure动画使用</title>
    <link href="https://xjlhhz.com/2018/07/29/20180729PathMeasure%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2018/07/29/20180729PathMeasure的动画使用/</id>
    <published>2018-07-29T05:14:00.000Z</published>
    <updated>2018-09-11T11:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>##PathMeasure的简单使用<br>pathMeasure是android给我们提供的一个用于自定义View的绘制的类。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public PathMeasure() &#123;</div><div class="line">       mPath = null;</div><div class="line">       native_instance = native_create(0, false);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>创建出一个空的pathMeasure对象，如果我们需要调用其中的方法，那么我们需要提前调用setPath</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public PathMeasure(Path path, boolean forceClosed) &#123;</div><div class="line">        // The native implementation does not copy the path, prevent it from being GC&apos;d</div><div class="line">        mPath = path;</div><div class="line">        native_instance = native_create(path != null ? path.readOnlyNI() : 0,</div><div class="line">                                        forceClosed);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>创建出一个带path的PathMeasure对象，forceClosed表示是否需要强制将path进行连接</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>获取当前的path的总长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the total length of the current contour, or 0 if no path is</div><div class="line"> * associated with this measure object.</div><div class="line"> */</div><div class="line">public float getLength() &#123;</div><div class="line">    return native_getLength(native_instance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取当前距离所在的坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean getPosTan(float distance, float pos[], float tan[]) &#123;</div><div class="line">        if (pos != null &amp;&amp; pos.length &lt; 2 ||</div><div class="line">            tan != null &amp;&amp; tan.length &lt; 2) &#123;</div><div class="line">            throw new ArrayIndexOutOfBoundsException();</div><div class="line">        &#125;</div><div class="line">        return native_getPosTan(native_instance, distance, pos, tan);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>获取两个指定点之间的片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Given a start and stop distance, return in dst the intervening</div><div class="line">    * segment(s). If the segment is zero-length, return false, else return</div><div class="line">    * true. startD and stopD are pinned to legal values (0..getLength()).</div><div class="line">    * If startD &gt;= stopD then return false (and leave dst untouched).</div><div class="line">    * Begin the segment with a moveTo if startWithMoveTo is true.</div><div class="line">    *</div><div class="line">    * &lt;p&gt;On &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; and earlier</div><div class="line">    * releases, the resulting path may not display on a hardware-accelerated</div><div class="line">    * Canvas. A simple workaround is to add a single operation to this path,</div><div class="line">    * such as &lt;code&gt;dst.rLineTo(0, 0)&lt;/code&gt;.&lt;/p&gt;</div><div class="line">    */</div><div class="line">   public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) &#123;</div><div class="line">       // Skia used to enforce this as part of it&apos;s API, but has since relaxed that restriction</div><div class="line">       // so to maintain consistency in our API we enforce the preconditions here.</div><div class="line">       float length = getLength();</div><div class="line">       if (startD &lt; 0) &#123;</div><div class="line">           startD = 0;</div><div class="line">       &#125;</div><div class="line">       if (stopD &gt; length) &#123;</div><div class="line">           stopD = length;</div><div class="line">       &#125;</div><div class="line">       if (startD &gt;= stopD) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return native_getSegment(native_instance, startD, stopD, dst.mutateNI(), startWithMoveTo);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>这个方法将会将指定点的距离路径set到传入的path中。</p><h2 id="圆环动画实现"><a href="#圆环动画实现" class="headerlink" title="圆环动画实现"></a>圆环动画实现</h2><p>对于一个圆环进度条动画，我们也可以通过这个PathMeasure来实现。</p><h3 id="创建圆环PathMeasure"><a href="#创建圆环PathMeasure" class="headerlink" title="创建圆环PathMeasure"></a>创建圆环PathMeasure</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private fun initPathMeasure() &#123;</div><div class="line">        pathMeasure = PathMeasure()</div><div class="line">    &#125;</div><div class="line">//创建circle</div><div class="line"> circlePath.addCircle(centerX, centerY, dip(35).toFloat(), Path.Direction.CW)</div><div class="line">//设置path</div><div class="line">pathMeasure.setPath(circlePath, false)</div></pre></td></tr></table></figure><h3 id="获取进度"><a href="#获取进度" class="headerlink" title="获取进度"></a>获取进度</h3><p>对于不同的业务场景下，我们可以通过不同的方式获取进度。</p><ul><li><p>通过ValueAnimator获取进度</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  private ValueAnimator initTranslateAnimator(final ImageView imageView) &#123;</div><div class="line"></div><div class="line">    ValueAnimator valueAnimator = ValueAnimator.ofFloat(0, 1);</div><div class="line">    valueAnimator.setDuration(VIEW_ANIMATION_DURING);</div><div class="line">    valueAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            float value = (float) animation.getAnimatedValue();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return valueAnimator;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  这个value就是获取到的实时进度</p></li><li><p>根据业务场景获取进度<br>  比如说我项目中的场景是一个录音的按钮，那么总的录制时长就是最大进度，当前的录制时长就是实时的进度</p></li></ul><h3 id="获取片段"><a href="#获取片段" class="headerlink" title="获取片段"></a>获取片段</h3><p>通过PathMeasure的getSegment获取当前的片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pathMeasure.getSegment(getDistance(getLastRecordTime()), getDistance(time), rPath, true)</div></pre></td></tr></table></figure></p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>在onDraw方法中绘制获取出来的path<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas?.drawPath(path, recordPaint)</div></pre></td></tr></table></figure></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="需要有暂停，并且暂停有间隔"><a href="#需要有暂停，并且暂停有间隔" class="headerlink" title="需要有暂停，并且暂停有间隔"></a>需要有暂停，并且暂停有间隔</h3><p>比如下面图片中的例子：<br><img src="http://onu21exz8.bkt.clouddn.com/record.jpeg" alt=""><br>这个动画需要可以暂停，然后每次暂停后都会有分隔符。<br>处理方案： 我们需要将path缓存起来，并且每次生成小间隔，在onDraw时先绘制之前缓存的path，在计算进度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//绘制之前的进度</div><div class="line">       destPathList.forEachIndexed &#123; index, path -&gt;</div><div class="line">           //0表示录音path，1表示间隔path</div><div class="line">           canvas?.drawPath(path, if (index % 2 == 0) recordPaint else dividerPaint)</div><div class="line">       &#125;</div><div class="line">       //需要先空出间隔的时间不绘制</div><div class="line">       if (durationStack.isEmpty()) &#123;</div><div class="line">           val path = Path()</div><div class="line">           pathMeasure.getSegment(getDistance(getLastRecordTime()), getDistance(currentTime + getLastRecordTime()), path, true)</div><div class="line">           canvas?.drawPath(path, recordPaint)</div><div class="line">       &#125; else if (currentTime &gt;= dividerStep) &#123;</div><div class="line">           //再进行此时的绘制, 肯定是录音绘制</div><div class="line">           val path = Path()</div><div class="line">           pathMeasure.getSegment(getDistance(getLastRecordTime()), getDistance(currentTime + getLastRecordTime() - dividerStep), path, true)</div><div class="line">           canvas?.drawPath(path, recordPaint)</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><h4 id="onDraw并没有手动执行"><a href="#onDraw并没有手动执行" class="headerlink" title="onDraw并没有手动执行"></a>onDraw并没有手动执行</h4><p>在设置的时候，发现onDraw方法在request或者invaliate方法触发下并不会执行，是因为ViewGroup默认情况下，出于性能考虑，会被设置成WILL_NOT_DROW，这样，ondraw就不会被执行了。<br>解决方案,在构造函数中，设置WILL_NOT_DROW为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setWillNotDraw（false）</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##PathMeasure的简单使用&lt;br&gt;pathMeasure是android给我们提供的一个用于自定义View的绘制的类。&lt;/p&gt;
&lt;h3 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ViewSwitcher的使用</title>
    <link href="https://xjlhhz.com/2018/07/18/20180718ViewSwitcher%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2018/07/18/20180718ViewSwitcher的使用/</id>
    <published>2018-07-18T05:14:00.000Z</published>
    <updated>2018-07-18T14:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ViewSwitcher简单使用"><a href="#ViewSwitcher简单使用" class="headerlink" title="ViewSwitcher简单使用"></a>ViewSwitcher简单使用</h2><p>ViewSwitcher，从字面的意义上来说，它就是一个基本View切换的动画实现，内部给我们封装了切换动画，我们只需要设置相应的动画及View的切换就可以了</p><h3 id="实现Factory接口"><a href="#实现Factory接口" class="headerlink" title="实现Factory接口"></a>实现Factory接口</h3><p>实现Factory接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates views in a ViewSwitcher.</div><div class="line">     */</div><div class="line">    public interface ViewFactory &#123;</div><div class="line">        /**</div><div class="line">         * Creates a new &#123;@link android.view.View&#125; to be added in a</div><div class="line">         * &#123;@link android.widget.ViewSwitcher&#125;.</div><div class="line">         *</div><div class="line">         * @return a &#123;@link android.view.View&#125;</div><div class="line">         */</div><div class="line">        View makeView();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这个工厂接口里面的makeView就是用来生产ViewSwitcher里的View的。这个是我们必须要实现的一个接口。返回相应的View。</p><h3 id="设置动画和工厂"><a href="#设置动画和工厂" class="headerlink" title="设置动画和工厂"></a>设置动画和工厂</h3><p>当我们实现完了Factory之后，只需要设置相应的参数就可以愉快的使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private fun initFrameSwitchView() &#123;</div><div class="line">        //设置对应的工厂</div><div class="line">        recordImageSwitch.setFactory(this)</div><div class="line">        //设置动画</div><div class="line">        recordImageSwitch.setInAnimation(this, R.anim.alpha_in)</div><div class="line">        recordImageSwitch.setOutAnimation(this, R.anim.alpha_out)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="切换View"><a href="#切换View" class="headerlink" title="切换View"></a>切换View</h3><p>设置完了View之后，我们只需要调用切换View的方法就可以看到相应的动画了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Manually shows the next child.</div><div class="line">     */</div><div class="line">    @android.view.RemotableViewMethod</div><div class="line">    public void showNext() &#123;</div><div class="line">        setDisplayedChild(mWhichChild + 1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Manually shows the previous child.</div><div class="line">     */</div><div class="line">    @android.view.RemotableViewMethod</div><div class="line">    public void showPrevious() &#123;</div><div class="line">        setDisplayedChild(mWhichChild - 1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h2 id="ViewSwitcher的原理"><a href="#ViewSwitcher的原理" class="headerlink" title="ViewSwitcher的原理"></a>ViewSwitcher的原理</h2><p>其实它的内部原理特别简单，就是在ViewSwitcher中构造了两个View，然后再我们调用切换View的方法的时候去调用设置的动画来进行切换。</p><h3 id="setFactory"><a href="#setFactory" class="headerlink" title="setFactory"></a>setFactory</h3><p>在我们初始化时，需要设置了工厂，在设置工厂的同时会初始化两个需要Switch的View。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void setFactory(ViewFactory factory) &#123;</div><div class="line">        mFactory = factory;</div><div class="line">        obtainView();</div><div class="line">        obtainView();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-----&gt;</div><div class="line">private View obtainView() &#123;</div><div class="line">        View child = mFactory.makeView();</div><div class="line">        LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">        if (lp == null) &#123;</div><div class="line">            lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</div><div class="line">        &#125;</div><div class="line">        addView(child, lp);</div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在obtainView中，首先会通过makeView这个方法，获取出相应的View，然后添加ViewGroup中。</p><h3 id="showNext"><a href="#showNext" class="headerlink" title="showNext"></a>showNext</h3><p>内部会调用DisplayedChild切换View。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public void setDisplayedChild(int whichChild) &#123;</div><div class="line">        //设置当前的子View id</div><div class="line">        mWhichChild = whichChild;</div><div class="line">        if (whichChild &gt;= getChildCount()) &#123;</div><div class="line">            //到了子view的最大值，那么清0返回</div><div class="line">            mWhichChild = 0;</div><div class="line">        &#125; else if (whichChild &lt; 0) &#123;</div><div class="line">            //到了子View的最小值，那么回到最大值</div><div class="line">            mWhichChild = getChildCount() - 1;</div><div class="line">        &#125;</div><div class="line">        boolean hasFocus = getFocusedChild() != null;</div><div class="line">        // This will clear old focus if we had it</div><div class="line">        showOnly(mWhichChild);</div><div class="line">        if (hasFocus) &#123;</div><div class="line">            // Try to retake focus if we had it</div><div class="line">            requestFocus(FOCUS_FORWARD);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-------&gt; showOnly</div><div class="line">void showOnly(int childIndex, boolean animate) &#123;</div><div class="line">        final int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            //获取子View</div><div class="line">            final View child = getChildAt(i);</div><div class="line">            if (i == childIndex) &#123;</div><div class="line">                //如果是当前要显示的View，那么需要执行入场动画</div><div class="line">                if (animate &amp;&amp; mInAnimation != null) &#123;</div><div class="line">                    child.startAnimation(mInAnimation);</div><div class="line">                &#125;</div><div class="line">                child.setVisibility(View.VISIBLE);</div><div class="line">                mFirstTime = false;</div><div class="line">            &#125; else &#123;</div><div class="line">                //出场的View，需要执行出场动画</div><div class="line">                if (animate &amp;&amp; mOutAnimation != null &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;</div><div class="line">                    child.startAnimation(mOutAnimation);</div><div class="line">                &#125; else if (child.getAnimation() == mInAnimation)</div><div class="line">                    child.clearAnimation();</div><div class="line">                child.setVisibility(View.GONE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h2 id="ViewSwitcher的扩展"><a href="#ViewSwitcher的扩展" class="headerlink" title="ViewSwitcher的扩展"></a>ViewSwitcher的扩展</h2><p>默认的实现的ImageView，我们可以扩展这个实现，比如说扩展为SimpleDreeViewSwitcher，再或者，我们可以扩展为ViewGroup。<br>比如我们添加了一个FrameLayout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">override fun makeView(): View &#123;</div><div class="line">        val layoutParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</div><div class="line">        val frameLayout = FrameLayout(this)</div><div class="line">        frameLayout.layoutParams = layoutParams</div><div class="line"></div><div class="line">        //中间SimpleDraweeView</div><div class="line">        val simple = SimpleDraweeView(this)</div><div class="line">        val centerLayoutParam = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT)</div><div class="line">        centerLayoutParam.gravity = Gravity.CENTER</div><div class="line">        simple.tag = 1</div><div class="line">        val hierarchy = simple.hierarchy</div><div class="line">        hierarchy.actualImageScaleType = ScalingUtils.ScaleType.FIT_XY</div><div class="line">        simple.hierarchy = hierarchy</div><div class="line">        simple.adjustViewBounds = true</div><div class="line">        simple.layoutParams = centerLayoutParam</div><div class="line"></div><div class="line">        //背景ImageView</div><div class="line">        val bgSimple = SimpleDraweeView(this)</div><div class="line">        val bgLayoutParam = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</div><div class="line">        bgSimple.tag = 2</div><div class="line">        val bgHierarchy = bgSimple.hierarchy</div><div class="line">        bgHierarchy.actualImageScaleType = ScalingUtils.ScaleType.CENTER_CROP</div><div class="line">        bgSimple.hierarchy = bgHierarchy</div><div class="line">        bgSimple.layoutParams = bgLayoutParam</div><div class="line"></div><div class="line"></div><div class="line">        frameLayout.addView(bgSimple)</div><div class="line">        frameLayout.addView(simple)</div><div class="line">        return frameLayout</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在代码中创建了一个FrameLayout，并且创建添加两个子View，设置tag。</p><p>在每次切换View之前，都需要对View进行相应的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun setImageUrl(imageUrl : String, scaleType: Int, isGif: Boolean) &#123;</div><div class="line">      val layout = this.nextView as FrameLayout</div><div class="line">      val centerSimpleDraweeView = layout.findViewWithTag&lt;SimpleDraweeView&gt;(1)</div><div class="line">      val bgSimpleDraweeView = layout.findViewWithTag&lt;SimpleDraweeView&gt;(2)</div><div class="line"></div><div class="line">      //对View进行处理</div><div class="line"></div><div class="line">      showNext()</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ViewSwitcher简单使用&quot;&gt;&lt;a href=&quot;#ViewSwitcher简单使用&quot; class=&quot;headerlink&quot; title=&quot;ViewSwitcher简单使用&quot;&gt;&lt;/a&gt;ViewSwitcher简单使用&lt;/h2&gt;&lt;p&gt;ViewSwitcher，从
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CoordinateLayout使用</title>
    <link href="https://xjlhhz.com/2018/05/12/20180512CoordinateLayout%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2018/05/12/20180512CoordinateLayout使用/</id>
    <published>2018-05-12T05:14:00.000Z</published>
    <updated>2018-05-13T10:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Material Design 是专为设计适用于多个平台和设备的视觉、运动与互动效果而制定的综合指南。 Android 现在已支持 Material Design 应用。 如果要在您的 Android 应用中使用 Material Design，请遵循Material Design 规范内定义的指导方针，并使用 Android 5.0（API 级别 21）及以上版本所提供的新组件和功能。</p><p>而CoordinateLayout就是其中一个比较难的组件。</p><h2 id="coordinateLayout"><a href="#coordinateLayout" class="headerlink" title="coordinateLayout"></a>coordinateLayout</h2><p>coordinateLayout作为一个功能较为强大的FrameLayout，但是它并没有直接继承于FrameLayout。而是作为ViewGroup的直接子类。主要用在以下的场景：</p><ul><li>作为一个顶层布局</li><li>需要与一个获多个子视图进行特殊交互，主要是指的滑动交互。</li></ul><p>可以通过Behaviors来指定子视图</p><h3 id="引入coordinateLayout"><a href="#引入coordinateLayout" class="headerlink" title="引入coordinateLayout"></a>引入coordinateLayout</h3><p>既然Material Design作为android的一个新特性，需要我们在gradle文件中引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &apos;com.android.support:design:&apos; + rootProject.supportLibVersion</div></pre></td></tr></table></figure></p><p>###基本使用</p><h4 id="coordinateLayout结合AppBarLayout"><a href="#coordinateLayout结合AppBarLayout" class="headerlink" title="coordinateLayout结合AppBarLayout"></a>coordinateLayout结合AppBarLayout</h4><p>AppBarLayout是具有Material Design特性的垂直的线性布局，直接继承于LinearLayout，需要作为coordinateLayout的直接子View才有作用，在appLayout中的子View将会依据scrollFlag随着滑动进行变化，可以通过scrollFlag属性来设置其中的子View来设置滑动特性，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//代码中</div><div class="line">appBarLayout.setScrollFlags(int)</div><div class="line">//xml中</div><div class="line">app:layout_scrollFlags</div></pre></td></tr></table></figure></p><h4 id="scrollFlag"><a href="#scrollFlag" class="headerlink" title="scrollFlag"></a>scrollFlag</h4><ul><li>scroll:值设为scroll的View会跟随滚动事件一起发生移动。就好像这个View也是列表的某个item，会随着滑动消失和出现</li><li>enterAlways：只要外部的scrollView或recyclerView有向下的滑动事件，那么这个View就有出现</li><li>exitUntilCollapsed：需要结合属性miniHeight使用，在滑动时，将会先将这个View滑动到指定的最低高度，再滑动recyclerView元素。</li><li>enterAlwaysCollapsed： 这个属性需要结合enterAlway和miniHeight使用，在recyclerView有向下滑动的时候，会先触发enterAlways，让这个View出现到最低高度，然后等到recyclerView向下滑到不能再滑动时，再滑动这个View到原始高度。</li><li>snap: 这个属性将会在滑动结束时，让这个View完全可见或者完全不可见。如果滑动结束后，这个View显示的高度低于0.25,那么这个View将会直接不可见，如果这个View显示的高度大于0.75,那么这个View将会完全可见</li></ul><p>###AppBarLayout结合CollapsingToolbarLayout<br>CollapsingToolbarLayout是一个折叠式的toolBar，直接继承于FrameLayout，需要作为AppBarLayout的直接子View，有下面几个特性供我们使用</p><ul><li>折叠标题： 标题布局在完全可见时更大，但随着屏幕滚动将会折叠并且变小，通过setTitle来设置标题，并且通过collapsedTextAppearance和expandedTextAppearance来改变标题外观</li><li>toolbar内容填充：当屏幕滚动至折叠到toolbar高度时，会给toolbard设置背景，通过setContentScrim(Drawable)设置</li><li>statusBar内容填充：当屏幕滚动至折叠到toolbar高度时，会给状态栏设置背景，通过setStatusBarScrim(Drawable)设置，只有在5.0以上起作用</li><li>滑动视差效果：子View的滑动可以和外部recylerView形成视察效果，通过设置子view的layout_collapseMode为parallax开启，通过setParallaxMultiplier(float)来设置视差的效果。</li><li>固定子view位置：在屏幕滚动时，如果我们设置了子view的layout_collapseMode为pin的话，那么这个子View将会固定在顶部，当然，我们可以同时设置多个子View为pin</li><li>我们最好不要在运行时动态的给toolbar添加子View，否则title的大小计算可能会出问题</li></ul><h3 id="xml例子"><a href="#xml例子" class="headerlink" title="xml例子"></a>xml例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;android.support.design.widget.CoordinateLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:id=&quot;@+id/main_layout&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;@color/color_F7F9FA&quot;&gt;</div><div class="line"></div><div class="line">    &lt;android.support.design.widget.AppBarLayout</div><div class="line">        android:id=&quot;@+id/app_bar_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:theme=&quot;@color/color_ffffff&quot;&gt;</div><div class="line"></div><div class="line">        &lt;android.support.design.widget.CollapsingToolbarLayout</div><div class="line">            android:id=&quot;@+id/collap_tool_bar_layout&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:background=&quot;@color/color_FFFFFF&quot;</div><div class="line">            app:contentScrim=&quot;@color/color_ffffff&quot;</div><div class="line">            app:expandedTitleGravity=&quot;center_horizontal&quot;</div><div class="line">            app:expandedTitleMarginEnd=&quot;64dp&quot;</div><div class="line">            app:expandedTitleMarginStart=&quot;48dp&quot;</div><div class="line">            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</div><div class="line">            app:scrimVisibleHeightTrigger=&quot;@dimen/dimens_80dp&quot;&gt;</div><div class="line"></div><div class="line">            &lt;com.facebook.drawee.view.SimpleDraweeView</div><div class="line">                android:id=&quot;@+id/bg_collaps&quot;</div><div class="line">                android:layout_width=&quot;match_parent&quot;</div><div class="line">                android:layout_height=&quot;375dp&quot;</div><div class="line">                android:scaleType=&quot;centerCrop&quot;</div><div class="line">                app:layout_collapseMode=&quot;parallax&quot; /&gt;</div><div class="line"></div><div class="line">            &lt;android.support.v7.widget.Toolbar</div><div class="line">                android:id=&quot;@+id/toolbar&quot;</div><div class="line">                android:layout_width=&quot;match_parent&quot;</div><div class="line">                android:layout_height=&quot;@dimen/toolbar_height&quot;</div><div class="line">                app:layout_collapseMode=&quot;pin&quot;</div><div class="line">                app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt;</div><div class="line"></div><div class="line">            &lt;/android.support.v7.widget.Toolbar&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</div><div class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</div><div class="line">    &lt;RecyclerView</div><div class="line">        android:id=&quot;@+id/recycler_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior</div><div class="line">        /&gt;</div><div class="line">&lt;/android.support.design.widget.CoordinateLayout&gt;</div></pre></td></tr></table></figure><p>上面这个就是简单的CoordinateLayout、AppBarLayout及CollapsingToolbarLayout的结合使用，只要记得它必须是直接子View，和使用一些特性的属性就行。<br>上面非常重要的一点时，如何让可滑动的View和CoordinateLayout这些View建立联系，能够监听其滑动？其实只需要一个属性，在上面的recyclerView中，添加了一个layout_behavior属性，这个属性就标识了appBarLayout将会依赖于这个RecyclerView的滑动做处理。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="layout-behavior绑定过程"><a href="#layout-behavior绑定过程" class="headerlink" title="layout_behavior绑定过程"></a>layout_behavior绑定过程</h4><p>既然AppBarLayout和recyclerView的滑动是通过app:layout_behavior这个属性维系的，那么它究竟是如何通过这个属性来绑定的,我们需要来看看CoordinateLayout的源码实现了，</p><h5 id="layout-behavior的创建"><a href="#layout-behavior的创建" class="headerlink" title="layout_behavior的创建"></a>layout_behavior的创建</h5><p>CoordinateLayout内部自定义了一个LayoutParam类，这个类包含了对Behavior的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">LayoutParams(Context context, AttributeSet attrs) &#123;</div><div class="line">            super(context, attrs);</div><div class="line"></div><div class="line">            final TypedArray a = context.obtainStyledAttributes(attrs,</div><div class="line">                    R.styleable.CoordinatorLayout_Layout);</div><div class="line">            ...</div><div class="line">            mBehaviorResolved = a.hasValue(</div><div class="line">                    R.styleable.CoordinatorLayout_Layout_layout_behavior);</div><div class="line">            if (mBehaviorResolved) &#123;</div><div class="line">                //如果存在layout_behavior属性，那么将会尝试解析behavior</div><div class="line">                mBehavior = parseBehavior(context, attrs, a.getString(</div><div class="line">                        R.styleable.CoordinatorLayout_Layout_layout_behavior));</div><div class="line">            &#125;</div><div class="line">            a.recycle();</div><div class="line"></div><div class="line">            if (mBehavior != null) &#123;</div><div class="line">                // 如果解析出behavior，那么将会绑定这个layoutParam</div><div class="line">                mBehavior.onAttachedToLayoutParams(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>在我们了解behavior的解析操作前，我们需要先了解一下app:layout_behavior的默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;string name=&quot;appbar_scrolling_view_behavior&quot; translatable=&quot;false&quot;&gt;android.support.design.widget.AppBarLayout$ScrollingViewBehavior&lt;/string&gt;</div></pre></td></tr></table></figure></p><p>通过parseBehavior创建Behavior实例，如果存在，那就直接复用，不存在就通过反射创建实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Behavior parseBehavior(Context context, AttributeSet attrs, String name) &#123;</div><div class="line">        if (TextUtils.isEmpty(name)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        //拼出全拼</div><div class="line">        final String fullName;</div><div class="line">        if (name.startsWith(&quot;.&quot;)) &#123;</div><div class="line">            // Relative to the app package. Prepend the app package name.</div><div class="line">            fullName = context.getPackageName() + name;</div><div class="line">        &#125; else if (name.indexOf(&apos;.&apos;) &gt;= 0) &#123;</div><div class="line">            // Fully qualified package name.</div><div class="line">            fullName = name;</div><div class="line">        &#125; else &#123;</div><div class="line">            // Assume stock behavior in this package (if we have one)</div><div class="line">            fullName = !TextUtils.isEmpty(WIDGET_PACKAGE_NAME)</div><div class="line">                    ? (WIDGET_PACKAGE_NAME + &apos;.&apos; + name)</div><div class="line">                    : name;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            //用threadLocal存储Behavior</div><div class="line">            Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get();</div><div class="line">            if (constructors == null) &#123;</div><div class="line">                constructors = new HashMap&lt;&gt;();</div><div class="line">                sConstructors.set(constructors);</div><div class="line">            &#125;</div><div class="line">            //判断是否已经有相应的behavior</div><div class="line">            Constructor&lt;Behavior&gt; c = constructors.get(fullName);</div><div class="line">            if (c == null) &#123;</div><div class="line">                //没有就创建，通过反射创建实例</div><div class="line">                final Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) context.getClassLoader()</div><div class="line">                        .loadClass(fullName);</div><div class="line">                c = clazz.getConstructor(CONSTRUCTOR_PARAMS);</div><div class="line">                c.setAccessible(true);</div><div class="line">                constructors.put(fullName, c);</div><div class="line">            &#125;</div><div class="line">            return c.newInstance(context, attrs);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new RuntimeException(&quot;Could not inflate Behavior subclass &quot; + fullName, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在创建后需要将behavior绑定layoutParam。<br>coordirnateLayout在传递事件时，如果子View存在Behavior，那么会将滑动事件和子View都交给behavior来处理。</p><h5 id="Behavior的事件"><a href="#Behavior的事件" class="headerlink" title="Behavior的事件"></a>Behavior的事件</h5><h6 id="Coordinatelayout-Behavior"><a href="#Coordinatelayout-Behavior" class="headerlink" title="Coordinatelayout.Behavior"></a>Coordinatelayout.Behavior</h6><p>在coordinateLyout中定义了一个Behavior的抽象类，所有的Behavior都需要继承于该类，我们看看一个最基本的Behavior具有比较重要的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//设置两个View的依赖        </div><div class="line">public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//依赖的View改变</div><div class="line">public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//依赖View的移除</div><div class="line">public void onDependentViewRemoved(CoordinatorLayout parent, V child, View dependency) &#123;&#125;</div><div class="line">//准备开始移动的回调</div><div class="line">public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                return onStartNestedScroll(coordinatorLayout, child, directTargetChild,</div><div class="line">                        target, axes);</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//滑动事件被接收的回调</div><div class="line">public void onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                onNestedScrollAccepted(coordinatorLayout, child, directTargetChild,</div><div class="line">                        target, axes);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">public void onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//停止滑动事件的回调</div><div class="line">public void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                onStopNestedScroll(coordinatorLayout, child, target);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">public void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//滑动事件的接收</div><div class="line">public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child,</div><div class="line">                @NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed,</div><div class="line">                        dxUnconsumed, dyUnconsumed);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child,</div><div class="line">                @NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                int dxUnconsumed, int dyUnconsumed) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//滑动事件前的回调</div><div class="line">public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child,</div><div class="line">                @NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                int dxUnconsumed, int dyUnconsumed) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">public void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, int dx, int dy, @NonNull int[] consumed) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//fling事件回调</div><div class="line">public boolean onNestedFling(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, float velocityX, float velocityY,</div><div class="line">                boolean consumed) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//fling事件前回调</div><div class="line">public boolean onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, float velocityX, float velocityY) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>AppBarLayout也有一个默认的behavior，我们不需要显示的指定这个Behavior的使用，因为AppBarLayout在代码中添加了注解，来给CoordinateLayout添加默认behavior。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)</div></pre></td></tr></table></figure></p><p>appBarLayout中用的behavior，同样的也是继承于CoordinateLayout中的behavior，通过重写其中的方法，来做相应的滑动处理。</p><h3 id="CoordinateLayout实现可放大的封面"><a href="#CoordinateLayout实现可放大的封面" class="headerlink" title="CoordinateLayout实现可放大的封面"></a>CoordinateLayout实现可放大的封面</h3><p>这个是参照的网上的实现</p><ul><li><p>设置需要传递放大的View，View的正常高度和可放大的最大高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void setPullZoom(View zoomView, int zoomViewHeight, int maxZoomViewHeight, IPullZoom pullZoom) &#123;</div><div class="line">        this.mZoomView = zoomView;</div><div class="line">        mZoomViewHeight = zoomViewHeight;</div><div class="line">        mZoomViewMaxHeight = maxZoomViewHeight;</div><div class="line">        mPullZoom = pullZoom;</div><div class="line">        //防止 onInterceptTouchEvent的ACTION_MOVE事件不执行，避免就是子view的down事件返回fasle</div><div class="line">        mZoomView.setClickable(true);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>重写事件拦截器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public boolean onInterceptTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (!isPullToZoomEnabled()) &#123;</div><div class="line">            //如果没有传入需要放大的view，那么不拦截</div><div class="line">            return super.onInterceptTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int action = event.getAction();</div><div class="line"></div><div class="line">        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123;</div><div class="line">            //如果是取消或者抬起事件，那么不拦截</div><div class="line">            mIsBeingDragged = false;</div><div class="line">            return super.onInterceptTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (action != MotionEvent.ACTION_DOWN &amp;&amp; mIsBeingDragged) &#123;</div><div class="line">            //如果已经处于放大中状态，且事件是down，那么直接拦截</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                //开始触发的放大的条件</div><div class="line">                if (isReadyForPullStart()) &#123;</div><div class="line">                    </div><div class="line">                    final float y = event.getY(), x = event.getX();</div><div class="line">                    final float diff, oppositeDiff, absDiff;</div><div class="line">                    // 计算此次位移的距离</div><div class="line">                    diff = y - mLastMotionY;</div><div class="line">                    oppositeDiff = x - mLastMotionX;</div><div class="line">                    absDiff = Math.abs(diff);</div><div class="line">                    </div><div class="line">                </div><div class="line">                    </div><div class="line">                    if (absDiff &gt; mTouchSlop &amp;&amp; absDiff &gt; Math.abs(oppositeDiff)) &#123;</div><div class="line">                        </div><div class="line">                        if (diff &gt;= 1f &amp;&amp; isReadyForPullStart()) &#123;</div><div class="line">                    //修改last位置，并且设置mIsBeingDragged为ture</div><div class="line">                            mLastMotionY = y;</div><div class="line">                            mLastMotionX = x;</div><div class="line">                            mIsBeingDragged = true;</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mIsBeingDragged = false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                if (isReadyForPullStart()) &#123;</div><div class="line">                    mLastMotionY = mInitialMotionY = event.getY();</div><div class="line">                    mLastMotionX = mInitialMotionX = event.getX();</div><div class="line">                    mIsBeingDragged = false;</div><div class="line">                &#125; else &#123;</div><div class="line">                    mIsBeingDragged = false;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //利用mIsBeingDragged标志是否拦截事件</div><div class="line">        return mIsBeingDragged || super.onInterceptTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>onTouchEvent做事件处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (!isPullToZoomEnabled()) &#123;</div><div class="line">            return super.onTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; event.getEdgeFlags() != 0) &#123;</div><div class="line">            return super.onTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                if (mIsBeingDragged) &#123;</div><div class="line">                    //开始进行拖动放大，通过pullEvent放大</div><div class="line">                    mLastMotionY = event.getY();</div><div class="line">                    mLastMotionX = event.getX();</div><div class="line">                    pullEvent();</div><div class="line">                    isZooming = true;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                if (isReadyForPullStart()) &#123;</div><div class="line">                    mLastMotionY = mInitialMotionY = event.getY();</div><div class="line">                    mLastMotionX = mInitialMotionX = event.getX();</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_CANCEL:</div><div class="line">            case MotionEvent.ACTION_UP: &#123;</div><div class="line">                if (mIsBeingDragged) &#123;</div><div class="line">                    mIsBeingDragged = false;</div><div class="line">                    // 如果up和cancel事件前，处于放大状态，那么需要还原到先前的位置</div><div class="line">                    if (isZooming()) &#123;</div><div class="line">                        //首先滑动到顶部</div><div class="line">                        smoothScrollToTop();</div><div class="line">                        if (onPullZoomListener != null) &#123;</div><div class="line">                            onPullZoomListener.onPullZoomEnd();</div><div class="line">                        &#125;</div><div class="line">                        if (mPullZoom != null) &#123;</div><div class="line">                            mPullZoom.onPullZoomEnd();</div><div class="line">                        &#125;</div><div class="line">                        isZooming = false;</div><div class="line">                        return true;</div><div class="line">                    &#125;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>放大的动画pullEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void pullEvent() &#123;</div><div class="line">        final int newScrollValue;</div><div class="line">        final float initialMotionValue, lastMotionValue;</div><div class="line"></div><div class="line">        //按下的位置，y</div><div class="line">        initialMotionValue = mInitialMotionY;</div><div class="line">        //此次滑动到的y坐标</div><div class="line">        lastMotionValue = mLastMotionY;</div><div class="line"></div><div class="line">        //计算新的scroll距离，距离/3</div><div class="line">        newScrollValue = Math.round(Math.min(initialMotionValue - lastMotionValue, 0) / FRICTION);</div><div class="line">        //做动画处理</div><div class="line">        pullHeaderToZoom(newScrollValue);</div><div class="line">        if (onPullZoomListener != null) &#123;</div><div class="line">            onPullZoomListener.onPullZooming(newScrollValue);</div><div class="line">        &#125;</div><div class="line">        if (mPullZoom != null) &#123;</div><div class="line">            mPullZoom.onPullZooming(newScrollValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>pullHeaderToZoom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void pullHeaderToZoom(int newScrollValue) &#123;</div><div class="line">        //放大动画是否结束，没结束先停止回到原始高度的动画</div><div class="line">        if (mScalingRunnable != null &amp;&amp; !mScalingRunnable.isFinished()) &#123;</div><div class="line">            mScalingRunnable.abortAnimation();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        ViewGroup.LayoutParams localLayoutParams = mZoomView.getLayoutParams();</div><div class="line">        //计算最新View的高度</div><div class="line">        int toHeight = Math.abs(newScrollValue) + mZoomViewHeight;</div><div class="line">        if (mZoomViewMaxHeight &gt; 0 &amp;&amp; toHeight &gt; mZoomViewMaxHeight) &#123;</div><div class="line">            toHeight = mZoomViewMaxHeight;</div><div class="line">        &#125;</div><div class="line">        localLayoutParams.height = toHeight;</div><div class="line">        mZoomView.setLayoutParams(localLayoutParams);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Material Design 是专为设计适用于多个平台和设备的视觉、运动与互动效果而制定的综合指南。 Android 现在已支持 Material Design 应用。 如果要在您的 Android 应用中使用 Material Design，请遵循Material De
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(6) - anko Layout绘制原理</title>
    <link href="https://xjlhhz.com/2018/05/10/20180510Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/05/10/20180510Kotlin入门记录/</id>
    <published>2018-05-10T05:14:00.000Z</published>
    <updated>2018-05-10T10:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ViewManager"><a href="#ViewManager" class="headerlink" title="ViewManager"></a>ViewManager</h2><p>在了解anko之前，我们必须要先了解一下ViewManager这个类，这个是一个接口，通过这个接口，我们可以在Activity中添加、移除和更新View，我们可以通过 Context.getSystemService()来或者这个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params);</div><div class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</div><div class="line">public void removeView(View view);</div></pre></td></tr></table></figure></p><p>也就是说，只有实现了这个接口的类才能够在activity中对view进行操作。系统的ViewGroup就实现了这个接口。</p><h2 id="AnkoContext"><a href="#AnkoContext" class="headerlink" title="AnkoContext"></a>AnkoContext</h2><p>在anko中，所有的View的操作是通过AnkoContext这个类来实现 的，所以，AnkoContext实现了ViewManager接口，但是AnkoContext只提供添加功能，不提供view的移除和更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">interface AnkoContext&lt;out T&gt; : ViewManager &#123;</div><div class="line">    val ctx: Context</div><div class="line">    val owner: T</div><div class="line">    val view: View</div><div class="line"></div><div class="line">    override fun updateViewLayout(view: View, params: ViewGroup.LayoutParams) &#123;</div><div class="line">        throw UnsupportedOperationException()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun removeView(view: View) &#123;</div><div class="line">        throw UnsupportedOperationException()</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>一旦我们调用了updateViewLayout或者removeView方法，那么将会抛异常，UnsupportedOperationException，不支持这种操作。<br>这个类中包含了下面的三个参数</p><ul><li>ctx: Context– 上下文信息</li><li>owner: T– 这个owner是这个UI的依附者，可能是Activity、fragment、viewHolder</li><li>view： View–AnkoComponent生成并返回的View<br>下面来看看ankoContext提供的几个静态方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">companion object &#123;</div><div class="line">        fun create(ctx: Context, setContentView: Boolean = false): AnkoContext&lt;Context&gt;</div><div class="line">                = AnkoContextImpl(ctx, ctx, setContentView)</div><div class="line"></div><div class="line">        fun createReusable(ctx: Context, setContentView: Boolean = false): AnkoContext&lt;Context&gt;</div><div class="line">                = ReusableAnkoContext(ctx, ctx, setContentView)</div><div class="line"></div><div class="line">        fun &lt;T&gt; create(ctx: Context, owner: T, setContentView: Boolean = false): AnkoContext&lt;T&gt;</div><div class="line">                = AnkoContextImpl(ctx, owner, setContentView)</div><div class="line"></div><div class="line">        fun &lt;T&gt; createReusable(ctx: Context, owner: T, setContentView: Boolean = false): AnkoContext&lt;T&gt;</div><div class="line">                = ReusableAnkoContext(ctx, owner, setContentView)</div><div class="line"></div><div class="line">        fun &lt;T: ViewGroup&gt; createDelegate(owner: T): AnkoContext&lt;T&gt; = DelegatingAnkoContext(owner)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>这4个方法返回的都是AnkoContext实体，那么区别是什么？</p><ul><li>create表示直接创建出AnkoContext，并且不能重用，一旦已经绑定了View，那么将抛出异常。</li><li>createReusable表示创建出可以复用的AnkoContext,如果一个AnkoContext已经添加了子View，那么它会重新add View</li><li>createDelegate；表示将view添加到相应的委托对象中，用来在自定义View中代替inflate方法。<br>我们来看看这几个方法的实现：<h3 id="AnkoContextImpl"><a href="#AnkoContextImpl" class="headerlink" title="AnkoContextImpl"></a>AnkoContextImpl</h3>create方法返回的是AnkoContextImpl<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">open class AnkoContextImpl&lt;T&gt;(</div><div class="line">        override val ctx: Context,</div><div class="line">        override val owner: T,</div><div class="line">        private val setContentView: Boolean</div><div class="line">) : AnkoContext&lt;T&gt; &#123;</div><div class="line">    private var myView: View? = null</div><div class="line"></div><div class="line">    override val view: View</div><div class="line">        get() = myView ?: throw IllegalStateException(&quot;View was not set previously&quot;)</div><div class="line"></div><div class="line">    //将View添加到context中</div><div class="line">    override fun addView(view: View?, params: ViewGroup.LayoutParams?) &#123;</div><div class="line">        </div><div class="line">        if (view == null) return</div><div class="line"></div><div class="line">        if (myView != null) &#123;</div><div class="line">            //如果myView！=null，表示已经添加了View了，如果是create方法调用的，那么将会抛出异常</div><div class="line">            alreadyHasView()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.myView = view</div><div class="line"></div><div class="line">        if (setContentView) &#123;</div><div class="line">            //如果需要setContentView，那么执行addView操作</div><div class="line">            doAddView(ctx, view)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun doAddView(context: Context, view: View) &#123;</div><div class="line">        when (context) &#123;</div><div class="line">            //找到activity，然后执行setContentView</div><div class="line">            is Activity -&gt; context.setContentView(view)</div><div class="line">            is ContextWrapper -&gt; doAddView(context.baseContext, view)</div><div class="line">            else -&gt; throw IllegalStateException(&quot;Context is not an Activity, can&apos;t set content view&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open protected fun alreadyHasView(): Unit = throw IllegalStateException(&quot;View is already set: $myView&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="ReusableAnkoContext"><a href="#ReusableAnkoContext" class="headerlink" title="ReusableAnkoContext"></a>ReusableAnkoContext</h3><p>createReusable返回的是ReusableAnkoContext实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">internal class ReusableAnkoContext&lt;T&gt;(</div><div class="line">        override val ctx: Context,</div><div class="line">        override val owner: T,</div><div class="line">        setContentView: Boolean</div><div class="line">) : AnkoContextImpl&lt;T&gt;(ctx, owner, setContentView) &#123;</div><div class="line">    override fun alreadyHasView() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为createReusable表示创建的是可重用布局，而AnkoContextImpl在已经绑定了View的时候，将会通过alreadyHasView抛出异常。所以ReusableAnkoContext通过复写alreadyHasView，并且来让布局可重用。</p><h3 id="DelegatingAnkoContext"><a href="#DelegatingAnkoContext" class="headerlink" title="DelegatingAnkoContext"></a>DelegatingAnkoContext</h3><p>createDelegate(owner: T)返回的是DelegatingAnkoContext实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">internal class DelegatingAnkoContext&lt;T: ViewGroup&gt;(override val owner: T): AnkoContext&lt;T&gt; &#123;</div><div class="line">    override val ctx: Context = owner.context</div><div class="line">    override val view: View = owner</div><div class="line"></div><div class="line">    override fun addView(view: View?, params: ViewGroup.LayoutParams?) &#123;</div><div class="line">        if (view == null) return</div><div class="line"></div><div class="line">        if (params == null) &#123;</div><div class="line">            owner.addView(view)</div><div class="line">        &#125; else &#123;</div><div class="line">            owner.addView(view, params)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>DelegatingAnkoContext会将view添加到owner上，而不是Activity。</p><h2 id="AnkoComponen"><a href="#AnkoComponen" class="headerlink" title="AnkoComponen"></a>AnkoComponen</h2><p>在Anko中，如果我们想要它的预览特性，那么我们就需要用到AnkoComponen，只有继承了AnkoComponen，并且结合anko support，就能�够预览了，我们需要在实现createView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface AnkoComponent&lt;in T&gt; &#123;</div><div class="line">    fun createView(ui: AnkoContext&lt;T&gt;): View</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们通过createView方法绘制我们想要的View并返回。AnkoComponent有一个扩展方法setContentView,是用来给Activity设置ContentView的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : Activity&gt; AnkoComponent&lt;T&gt;.setContentView(activity: T): View =</div><div class="line">        createView(AnkoContextImpl(activity, activity, true))</div></pre></td></tr></table></figure></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>AnkoContext内部添加了几个扩展函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline fun Context.UI(setContentView: Boolean, init: AnkoContext&lt;Context&gt;.() -&gt; Unit): AnkoContext&lt;Context&gt; =</div><div class="line">        createAnkoContext(this, init, setContentView)</div><div class="line"></div><div class="line">inline fun Context.UI(init: AnkoContext&lt;Context&gt;.() -&gt; Unit): AnkoContext&lt;Context&gt; =</div><div class="line">        createAnkoContext(this, init)</div><div class="line"></div><div class="line">inline fun Fragment.UI(init: AnkoContext&lt;Fragment&gt;.() -&gt; Unit): AnkoContext&lt;Fragment&gt; =</div><div class="line">        createAnkoContext(activity, init)</div></pre></td></tr></table></figure></p><p>在Activity和fragment中，可以直接通过UI的方式调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UI &#123; </div><div class="line">   .....</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>然后内部会调用createAnkoContext，将UI里面的View传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T&gt; T.createAnkoContext(</div><div class="line">           ctx: Context,</div><div class="line">           init: AnkoContext&lt;T&gt;.() -&gt; Unit,</div><div class="line">           setContentView: Boolean = false</div><div class="line">   ): AnkoContext&lt;T&gt; &#123;</div><div class="line">       val dsl = AnkoContextImpl(ctx, this, setContentView)</div><div class="line">       dsl.init()</div><div class="line">       return dsl</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>内部还是调用AnkoContextImpl，并且调用内部还是调用AnkoContextImpl的init方法，初始化UI，并添加ctx中.</p><h2 id="AnkoUI布局的动态创建"><a href="#AnkoUI布局的动态创建" class="headerlink" title="AnkoUI布局的动态创建"></a>AnkoUI布局的动态创建</h2><p>在了解AnkoUI的布局的创建之前，我们需要先了解一下anko支持的dsl.</p><h3 id="DSL-Domain-Specific-Language"><a href="#DSL-Domain-Specific-Language" class="headerlink" title="DSL(Domain-Specific-Language)"></a>DSL(Domain-Specific-Language)</h3><p>dsl指的是特定领域的语言，kotlin的DSL特性支持就是扩展，anko通过dsl，才有了anko layout库。</p><h3 id="带接收者的函数字面值"><a href="#带接收者的函数字面值" class="headerlink" title="带接收者的函数字面值"></a>带接收者的函数字面值</h3><p>在kotlin中，支持给函数指定接收者对象，而无需额外的限定符，有点类似于扩展函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init: (@AnkoViewDslMarker _RelativeLayout).() -&gt; Unit</div></pre></td></tr></table></figure></p><p>相当于() -&gt; Unit指定的接收者对象为_RelativeLayout<br>如果在函数体内部可以调用接收者对象的方法，那么假若这个方法又是带接收者类型的方法，那么就可以不断的往下调用了。</p><h3 id="anko布局"><a href="#anko布局" class="headerlink" title="anko布局"></a>anko布局</h3><p>下面是一个简单的anko布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">relativeLayout &#123;</div><div class="line">                imageView &#123;</div><div class="line">                    adjustViewBounds = true</div><div class="line">                    scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">                    imageResource = R.drawable.bg_members</div><div class="line">                &#125;.lparams(width = matchParent, height = matchParent)</div><div class="line">                statusBar = view &#123;</div><div class="line">                    id = statusBarHolder</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>anko给ViewManager添加了大部分组件的扩展函数,这个根节点relativeLayout将会调用到扩展函数中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">inline fun ViewManager.relativeLayout(): android.widget.RelativeLayout = relativeLayout() &#123;&#125;</div><div class="line">inline fun ViewManager.relativeLayout(init: (@AnkoViewDslMarker _RelativeLayout).() -&gt; Unit): android.widget.RelativeLayout &#123;</div><div class="line">    return ankoView(`$$Anko$Factories$Sdk15ViewGroup`.RELATIVE_LAYOUT, theme = 0) &#123; init() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面这个relativeLayout方法中，接收一个() -&gt; Unit的lambada表达式，这个表达式限定于relativeLayout，所以这个参数就是relativelayout里面的元素,在上面的例子就是这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">imageView &#123;</div><div class="line">        adjustViewBounds = true</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        imageResource = R.drawable.bg_members</div><div class="line">        &#125;.lparams(width = matchParent, height =matchParent)&#123;</div><div class="line">            statusBar = view &#123;</div><div class="line">            id = statusBarHolder</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>有一个注解AnkoViewDslMarker，这个参数会给对应_RelativeLayout的View对象扩展一个applyRecursively方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@DslMarker</div><div class="line">@Target(AnnotationTarget.TYPE)</div><div class="line">annotation class AnkoViewDslMarker</div><div class="line"></div><div class="line">/**</div><div class="line"> * Apply [f] to this [View] and to all of its children recursively.</div><div class="line"> * </div><div class="line"> * @return the receiver.</div><div class="line"> */</div><div class="line">inline fun &lt;T : View&gt; T.applyRecursively(noinline f: (View) -&gt; Unit): T &#123;</div><div class="line">    AnkoInternals.applyRecursively(this, f)</div><div class="line">    return this</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>applyRecursively扩展T对象，并且接收一个f函数，在这里指的是View的init方法，会先执行f方法，然后遍历所有的子元素，并进行创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fun applyRecursively(v: View, style: (View) -&gt; Unit) &#123;</div><div class="line">       //执行init方法，创建对象</div><div class="line">       style(v)</div><div class="line">       if (v is ViewGroup) &#123;</div><div class="line">       //如果是ViewGroup，那么可以添加子View，看看是否有子View</div><div class="line">           val maxIndex = v.childCount - 1</div><div class="line">           for (i in 0 .. maxIndex) &#123;</div><div class="line">               //对子View执行applyRecursively方法</div><div class="line">               v.getChildAt(i)?.let &#123; applyRecursively(it, style) &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>将会调用ViewManager的ankoView方法。</p><h4 id="anko默认支持的工厂"><a href="#anko默认支持的工厂" class="headerlink" title="anko默认支持的工厂"></a>anko默认支持的工厂</h4><p>我们上面的用的构造工厂是sdk15提供的工厂，我们看看工厂里面的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">internal object `$$Anko$Factories$Sdk15ViewGroup` &#123;</div><div class="line">    val APP_WIDGET_HOST_VIEW = &#123; ctx: Context -&gt; _AppWidgetHostView(ctx) &#125;</div><div class="line">    val ABSOLUTE_LAYOUT = &#123; ctx: Context -&gt; _AbsoluteLayout(ctx) &#125;</div><div class="line">    val FRAME_LAYOUT = &#123; ctx: Context -&gt; _FrameLayout(ctx) &#125;</div><div class="line">    val GALLERY = &#123; ctx: Context -&gt; _Gallery(ctx) &#125;</div><div class="line">    val GRID_LAYOUT = &#123; ctx: Context -&gt; _GridLayout(ctx) &#125;</div><div class="line">    val GRID_VIEW = &#123; ctx: Context -&gt; _GridView(ctx) &#125;</div><div class="line">    val HORIZONTAL_SCROLL_VIEW = &#123; ctx: Context -&gt; _HorizontalScrollView(ctx) &#125;</div><div class="line">    val IMAGE_SWITCHER = &#123; ctx: Context -&gt; _ImageSwitcher(ctx) &#125;</div><div class="line">    val LINEAR_LAYOUT = &#123; ctx: Context -&gt; _LinearLayout(ctx) &#125;</div><div class="line">    val RADIO_GROUP = &#123; ctx: Context -&gt; _RadioGroup(ctx) &#125;</div><div class="line">    val RELATIVE_LAYOUT = &#123; ctx: Context -&gt; _RelativeLayout(ctx) &#125;</div><div class="line">    val SCROLL_VIEW = &#123; ctx: Context -&gt; _ScrollView(ctx) &#125;</div><div class="line">    val TABLE_LAYOUT = &#123; ctx: Context -&gt; _TableLayout(ctx) &#125;</div><div class="line">    val TABLE_ROW = &#123; ctx: Context -&gt; _TableRow(ctx) &#125;</div><div class="line">    val TEXT_SWITCHER = &#123; ctx: Context -&gt; _TextSwitcher(ctx) &#125;</div><div class="line">    val VIEW_ANIMATOR = &#123; ctx: Context -&gt; _ViewAnimator(ctx) &#125;</div><div class="line">    val VIEW_SWITCHER = &#123; ctx: Context -&gt; _ViewSwitcher(ctx) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于每一个View，内部都有一个相对应的构建方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">open class _RelativeLayout(ctx: Context): RelativeLayout(ctx) &#123;</div><div class="line">     ...</div><div class="line">     inline fun &lt;T: View&gt; T.lparams(</div><div class="line">            width: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">            height: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">            init: RelativeLayout.LayoutParams.() -&gt; Unit</div><div class="line">    ): T &#123;</div><div class="line">        val layoutParams = RelativeLayout.LayoutParams(width, height)</div><div class="line">        layoutParams.init()</div><div class="line">        this@lparams.layoutParams = layoutParams</div><div class="line">        return this</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个_RelativeLayout内部都是重载的lparams，也就是通过这个方法来创建布局的param属性。</p><h3 id="ankoView的实现"><a href="#ankoView的实现" class="headerlink" title="ankoView的实现"></a>ankoView的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T : View&gt; ViewManager.ankoView(factory: (ctx: Context) -&gt; T, theme: Int, init: T.() -&gt; Unit): T &#123;</div><div class="line">    //获取需要依附的context对象</div><div class="line">    val ctx = AnkoInternals.wrapContextIfNeeded(AnkoInternals.getContext(this), theme)</div><div class="line">    //通过工厂模式返回View</div><div class="line">    val view = factory(ctx)</div><div class="line">    view.init()</div><div class="line">    //添加View，并返回</div><div class="line">    AnkoInternals.addView(this, view)</div><div class="line">    return view</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个ankoView将会接收工厂方法，返回View，然后执行init方法。这个init方法就行上面的工厂对象的构造函数。下面看看View添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : View&gt; addView(manager: ViewManager, view: T) = when (manager) &#123;</div><div class="line">      //针对于根节点下的View</div><div class="line">      is ViewGroup -&gt; manager.addView(view)</div><div class="line">      //针对于根节点</div><div class="line">      is AnkoContext&lt;*&gt; -&gt; manager.addView(view, null)</div><div class="line">      else -&gt; throw AnkoException(&quot;$manager is the wrong parent&quot;)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>将会直接添加到parent节点或者context下。</p><p>下面是一个自己理解的ankoView的绘制步骤:<br><img src="http://onu21exz8.bkt.clouddn.com/ankoView.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ViewManager&quot;&gt;&lt;a href=&quot;#ViewManager&quot; class=&quot;headerlink&quot; title=&quot;ViewManager&quot;&gt;&lt;/a&gt;ViewManager&lt;/h2&gt;&lt;p&gt;在了解anko之前，我们必须要先了解一下ViewManager这个类
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(5) - anko Layout使用</title>
    <link href="https://xjlhhz.com/2018/05/08/20180508Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/05/08/20180508Kotlin入门记录/</id>
    <published>2018-05-08T05:14:00.000Z</published>
    <updated>2018-05-10T10:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anko"><a href="#anko" class="headerlink" title="anko"></a>anko</h2><p>Anko 是一个用 Kotlin 写的Android DSL (Domain-Specific Language)。 内部提供很多工具，详情可点<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">https://github.com/Kotlin/anko</a><br>在这里我们主要涉及的是anko的layout部分，长久以来，Android视图都是用XML来完成布局的。用xml写布局有下面这些缺点：</p><ul><li>不是类型安全的;</li><li>不是null-safe;</li><li>强迫你对每个layout编写几乎相同的代码;</li><li>在设备上解析XML费电费CPU;</li><li>最惨的是代码不可复用<br>所以，如果可以，我们可以尝试用anko来绘制布局。</li></ul><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>因为anko版本发布的并不是很多，用户量也不是很多，所有网上能找到的资源是非常少的，所以配置的时候总会出现许许多多的问题。现在android studio默认已经集成了kotlin了，我们需要配置的就是anko support，也就是anko preview，用来预览anko写的ui布局的工具。</p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><h5 id="as联网下载"><a href="#as联网下载" class="headerlink" title="as联网下载"></a>as联网下载</h5><p>我们可以从android studio内置的下载器中下载，从Preference-&gt;Plugins中搜索Anko Support，并进行下载。<br><img src="http://onu21exz8.bkt.clouddn.com/as%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6" alt=""></p><h5 id="官网下载导入"><a href="#官网下载导入" class="headerlink" title="官网下载导入"></a>官网下载导入</h5><p>我们也能够从官网中下载指定的anko support版本，点击<a href="https://plugins.jetbrains.com/plugin/7734-anko-support，选择指定版本进行下载，然后在as导入。" target="_blank" rel="external">https://plugins.jetbrains.com/plugin/7734-anko-support，选择指定版本进行下载，然后在as导入。</a><br><img src="http://onu21exz8.bkt.clouddn.com/as%E5%AF%BC%E5%85%A5%E6%8F%92%E4%BB%B6" alt=""><br>在android选择项目的页面，选择configuration-&gt;plugins-&gt;install plugin from disk,选择相应的plugin包导入。</p><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p>目前官网最新的anko support插件版本是0.10.5,如果我们的as版本是3.0，那么还是将会出现anko preview不能预览的情况，报错情况为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Anko Support threw an uncaught NoSuchMethodError</div></pre></td></tr></table></figure></p><p>这个是因为as3.0的问题不支持anko support，这个时候我们只需要更新as的版本到3.1之后，anko support就能够使用了。</p><h2 id="开始使用anko"><a href="#开始使用anko" class="headerlink" title="开始使用anko"></a>开始使用anko</h2><p>首先需要先引入anko依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &quot;org.jetbrains.anko:anko:0.10.5&quot;</div></pre></td></tr></table></figure></p><p>这个是anko给我们集成的一个包含anko所有功能的库，包含了</p><ul><li>anko commons： 一些常用的扩展函数，包括intent、dialog、log、resources等</li><li>ankoLayout： anko布局</li><li>ankoSqlite： anko优化的数据库操作</li><li>anko Coroutines: anko对于kotlin协程的扩展</li></ul><p>如果我们需要大部分的anko的功能，我们可以直接这么引入，否则我们需要单独引入每一个功能的依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    // Anko Commons</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-commons:$anko_version&quot;</div><div class="line"></div><div class="line">    // Anko Layouts</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-sdk25:$anko_version&quot; // sdk15, sdk19, sdk21, sdk23 are also available</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-appcompat-v7:$anko_version&quot;</div><div class="line"></div><div class="line">    // Coroutine listeners for Anko Layouts</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-sdk25-coroutines:$anko_version&quot;</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version&quot;</div><div class="line"></div><div class="line">    // Anko SQLite</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-sqlite:$anko_version&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们只需要从中引入我们所必须的库就ok了。在这里我们需要注意的是anko-sdk的引入需要和我们build.gradle中的minSdkVersion做下适配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">org.jetbrains.anko:anko-sdk15 ： 15 &lt;= minSdkVersion &lt; 19</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk19 ： 19 &lt;= minSdkVersion &lt; 21</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk21 ： 21 &lt;= minSdkVersion &lt; 23</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk23 ： 23 &lt;= minSdkVersion &lt; 25</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk25 ： 25 &lt;= minSdkVersion</div></pre></td></tr></table></figure></p><p>如果没有按照要求做sdk适配，那么一旦运行在不符合的版本，将会直接崩溃～切记</p><h3 id="AnkoComponent"><a href="#AnkoComponent" class="headerlink" title="AnkoComponent"></a>AnkoComponent</h3><p>我们可以在activity的onCreate、fragemnt的onCreateView中直接绘制ui，但是这样就让ui绘制代码�与activity、fragment代码有了耦合了。所有我们可以将Anko代码定义到另外一个class中，作为对应的UiClass，这就需要AnkoComponent。</p><h4 id="定义UIClass"><a href="#定义UIClass" class="headerlink" title="定义UIClass"></a>定义UIClass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MemberCenterActivityUI : AnkoComponent&lt;MemberCenterActivity&gt; &#123;</div><div class="line">        override fun createView(ui: AnkoContext&lt;MemberCenterActivity&gt;) : View = with(ui)&#123;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>在我们定义了相应的uiclass之后，我们需要实现其中的oncreateView方法，这个类的返回就是一个View，就是我们anko绘制的布局。<br>添加上with(ui)，是为了让dsl代码块能够以this的形式持有AnkoContext，这个AnkoContext是一个非常有用的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val ctx: Context</div><div class="line">val owner: T</div><div class="line">val view: View</div></pre></td></tr></table></figure></p><p>ctx就是上下文信息，owner就是uiclass依附的类的实例，在这个例子里面指的是MemberCenterActivity，我们可以通过owner调用MemberCenterActivity的任意public方法。</p><h4 id="绘制布局"><a href="#绘制布局" class="headerlink" title="绘制布局"></a>绘制布局</h4><h5 id="所有布局"><a href="#所有布局" class="headerlink" title="所有布局"></a>所有布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">relativeLayout &#123;</div><div class="line">    imageView &#123;</div><div class="line">        adjustViewBounds = true</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        imageResource = R.drawable.bg_members</div><div class="line">    &#125;.lparams(width = matchParent, height = matchParent)</div><div class="line">    statusBar = view &#123;</div><div class="line">        id = statusBarHolder</div><div class="line">    &#125;.lparams &#123;</div><div class="line">        height = statusBarHeight(ctx)</div><div class="line">        width = matchParent</div><div class="line">    &#125;</div><div class="line">    toolbar &#123;</div><div class="line"></div><div class="line">        id = toolbarId</div><div class="line">        backgroundColor = R.color.color_00000000</div><div class="line"></div><div class="line">        imageView &#123;</div><div class="line">            imageResource = R.drawable.ic_arrow_back_white</div><div class="line">            onClick &#123;</div><div class="line">                owner.finish()</div><div class="line">            &#125;</div><div class="line">        &#125;.lparams(height = wrapContent, width = wrapContent) &#123;</div><div class="line">            padding = dip(5)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        textView(&quot;会员中心&quot;) &#123;</div><div class="line">            textColor = R.color.color_ffffff</div><div class="line">            textSize = R.dimen.dimens_18sp.toFloat()</div><div class="line">        &#125;.lparams(width = wrapContent, height = wrapContent) &#123;</div><div class="line">            gravity = Gravity.CENTER</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;.lparams(height = dip(50), width = matchParent) &#123;</div><div class="line">        below(statusBar)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memberRv = recyclerView &#123;</div><div class="line">        itemAnimator.changeDuration = 0</div><div class="line">        layoutManager = LinearLayoutManager(context)</div><div class="line">        adapter = MemberCenterAdapter(context, null)</div><div class="line">        memberAdapter = adapter as MemberCenterAdapter</div><div class="line">    &#125;.lparams(width = matchParent, height = matchParent) &#123;</div><div class="line">        below(toolbarId)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每一个anko布局，最多只能有一个根节点，在这个例子中最外层的根节点就是relativelayout，这个组件的名称都是以小写字母开头的，就是anko给java的View多包装了一层，以便在dsl使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">imageView &#123;</div><div class="line">       ....</div><div class="line">       &#125;.lparams(width = matchParent, height = matchParent)&#123;</div><div class="line">       .....</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>控件直接包含的区域是添加控件的直接参数的，比如说imageView的src，scaleType，TextView的text，textSize，textColor等。而lparams是用来定义组件的大小，布局、位置属性的，包括height、width、gravity等等。<br>当然，我们也可以不指定lparams，这样的话，它会有默认的宽高,即wrap_content。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T: View&gt; T.lparams(</div><div class="line">            width: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">            height: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT</div><div class="line">    ): T &#123;</div><div class="line">        val layoutParams = FrameLayout.LayoutParams(width, height)</div><div class="line">        this@lparams.layoutParams = layoutParams</div><div class="line">        return this</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>整个imageView域是有返回值的，返回的就是这个imageView实体，我们也可以理解成这个域创建了imageView实体并返回。</p><h5 id="anko扩展View"><a href="#anko扩展View" class="headerlink" title="anko扩展View"></a>anko扩展View</h5><p>当我们想要用自定义View或者anko没有支持的View，我们可以扩展ankoView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">inline fun ViewManager.mapView() = mapView(theme = 0) &#123;&#125;</div><div class="line"></div><div class="line">inline fun ViewManager.mapView(init: MapView.() -&gt; Unit): MapView &#123;</div><div class="line">    return ankoView(&#123; MapView(it) &#125;, theme = 0, init = init)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个mapView就是我们想要扩展的View，这个是官网给的例子，下面我们来扩展fresco的simpledraweeView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">inline fun ViewManager.simpleDraweeView(theme: Int = 0) = simpleDraweeView(theme) &#123;&#125;</div><div class="line">inline fun ViewManager.simpleDraweeView(theme: Int = 0, init: SimpleDraweeView.() -&gt; Unit) : SimpleDraweeView &#123;</div><div class="line">    return ankoView(&#123; SimpleDraweeView(it) &#125;, theme, init)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样我们就能在anko dsl中直接使用simpleDraweeView了</p><h5 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a>onclick</h5><p>anko中已经给我们添加了onclick方法，我们可以在每个View中添加onClick，并且指定其实现，anko将会给这个View设置listener<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun android.view.View.onClick(</div><div class="line">        context: CoroutineContext = UI,</div><div class="line">        handler: suspend CoroutineScope.(v: android.view.View?) -&gt; Unit</div><div class="line">) &#123;</div><div class="line">    setOnClickListener &#123; v -&gt;</div><div class="line">        launch(context) &#123;</div><div class="line">            handler(v)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="一些小点"><a href="#一些小点" class="headerlink" title="一些小点"></a>一些小点</h5><ul><li>用了anko之后，我们如果需要对于id的诉求只有一个，那就是在relativelayout中指定位置时，需要通过id，才指定below、above、left、right的位置，对于id的设置，我们需要自己定义Id的int值，我们得保证它不会重复。</li><li>对于imageView，不再有src属性，因为anko内部其实是动态代码创建view，所有对于这个src，替代的就是在代码中指定的imageResouce</li><li>对于color，需要的就是color的值，而非项目中的colorId</li><li>对于textView，它的textSize指定为f，而非sp</li><li>如果我们想要用recyclerView，那么我们需要引入anko的依赖库，或者直接扩展ankoView</li><li>对于dp计算，anko内部给我们实现了dip方法计算。</li></ul><h4 id="anko-preivew"><a href="#anko-preivew" class="headerlink" title="anko preivew"></a>anko preivew</h4><p>对于anko support，虽然可能它的代码效率比较高，但是它在预览的时候并没有办法做到像在xml里面实时预览，只有在代码build之后才能够看到预览页面，而且每次修改都必须要进行rebuild，这个是一个非常让人无法接受的点，刚开始效率肯定会低，但是随着代码的熟练，效率还是会有所提升的，毕竟anko的ui绘制效率要笔xml高。可以通过command+f9进行build。</p><h4 id="ankoComponent元素的调用"><a href="#ankoComponent元素的调用" class="headerlink" title="ankoComponent元素的调用"></a>ankoComponent元素的调用</h4><p>我们免不了需要在activity，framgent等类中更新uiClass的元素的状态。所以了解uiClass与activity，fragment及viewHolder的绑定及调用还是有必要的。</p><h5 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h5><h6 id="activity"><a href="#activity" class="headerlink" title="activity"></a>activity</h6><p>activity绑定ankoComponent可以通过下面这种方式来绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MemberCenterActivityUI().setContentView();</div></pre></td></tr></table></figure></p><h6 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val view = MemberCenterFragmentUI().createView(AnkoContext.create(ctx, MemberCenterFragment()))</div></pre></td></tr></table></figure><p>在onCreateView中返回这个View，就和fragment进行绑定了。</p><h6 id="viewHolder"><a href="#viewHolder" class="headerlink" title="viewHolder"></a>viewHolder</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MemberCenterItemUI().createView(AnkoContext.create(context, parent)</div></pre></td></tr></table></figure><h5 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h5><p>在自定义View中，对于anko来说是一个比较不方便的使用，因为在anko support的支持预览的前提是使用AnkoComponent，而自定义View的View绑定却不通过AnkoComponent，也有可能是我现在没发现，目前发现的支持绑定的方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  constructor(context: Context) : super(context) &#123;</div><div class="line">        initView()</div><div class="line">    &#125;</div><div class="line"> private fun initView() = AnkoContext.createDelegate(this).apply &#123;</div><div class="line">...init anko view</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在java的自定义View中，是通过构造函数调用inflate方法，来将xml设置到该自定义View中。<br>在anko中，利用AnkoContext.createDelegate(this).apply来替代inflate。</p><p>我们可以先通过AnkoComponent来预览界面，然后预览完成之后再将anko代码放在AnkoContext.createDelegate(this).apply中。</p><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>对于三者的调用其实都是一致的，我们只需要缓存AnkoComponent类的实例就能够通过这个实例引用其内部的ui组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//in activity</div><div class="line">mainUI = MemberCenterActivityUI()</div><div class="line">    mainUI.setContentView(this)</div><div class="line">    </div><div class="line"> TextUtils.isEmpty(chargeTip?.chargeButtonDesc).yes &#123;</div><div class="line">                mainUI.bottomMemberOpenDesc.visibility = View.GONE</div><div class="line">            &#125;.no &#123;</div><div class="line">                mainUI.bottomMemberOpenDesc.visibility = View.VISIBLE</div><div class="line">                mainUI.bottomMemberOpenDesc.text = chargeTip?.chargeButtonDesc</div><div class="line">            &#125;</div><div class="line">            TextUtils.isEmpty(chargeTip?.chargeButtonUrl).yes &#123;</div><div class="line">                mainUI.btnOpenViewIcon.visibility = View.GONE</div><div class="line">            &#125;.no &#123;</div><div class="line">                mainUI.btnOpenViewIcon.visibility = View.VISIBLE</div><div class="line">                KKGifPlayer</div><div class="line">                        .with(this)</div><div class="line">                        .load(chargeTip?.chargeButtonUrl)</div><div class="line">                        .playPolicy(KKGifPlayer.PlayPolicy.Auto_Always)</div><div class="line">                        .into(openViewIcon)</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;anko&quot;&gt;&lt;a href=&quot;#anko&quot; class=&quot;headerlink&quot; title=&quot;anko&quot;&gt;&lt;/a&gt;anko&lt;/h2&gt;&lt;p&gt;Anko 是一个用 Kotlin 写的Android DSL (Domain-Specific Language)。 内部提
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(4)</title>
    <link href="https://xjlhhz.com/2018/05/07/20180507Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/05/07/20180507Kotlin入门记录/</id>
    <published>2018-05-07T05:14:00.000Z</published>
    <updated>2018-05-05T15:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="onAttachedToWindow和onDetachedFromWindow"><a href="#onAttachedToWindow和onDetachedFromWindow" class="headerlink" title="onAttachedToWindow和onDetachedFromWindow"></a>onAttachedToWindow和onDetachedFromWindow</h2><p>这个是无关kotlin的，只是刚好在写kt代码时遇到的一个问题，<br>关于onAttachedToWindow和onDetachedFromWindow的触发时机，</p><h3 id="onAttachedToWindow就是在这个View被添加到Window时触发的"><a href="#onAttachedToWindow就是在这个View被添加到Window时触发的" class="headerlink" title="onAttachedToWindow就是在这个View被添加到Window时触发的"></a>onAttachedToWindow就是在这个View被添加到Window时触发的</h3><p>顾名思义，onAttachedToWindow就是在这个View被添加到Window时触发的，通过了dispatchAttachedToWindow这个方法触发的，那么View被添加到window的时机又是什么，其实就是对应的activity在生命周期onResume的时候调用的，activity对应的view在onResume的时候被添加添加到window。且每一个view都只会被调用一次，父view调用在前，不论view的visibility状态都会被调用，适合做些view特定的初始化操作；</p><h3 id="onDetachedFromWindow"><a href="#onDetachedFromWindow" class="headerlink" title="onDetachedFromWindow"></a>onDetachedFromWindow</h3><p>onDetachedFromWindow方法是在activity的生命周期destroy的时候被调用的，也就是act对应的view从window中移除的时候，且每个view只会被调用一次，父view的调用在后，也不论view的visibility状态都会被调用，适合做最后的清理操作；</p><h2 id="kotlin类的继承性"><a href="#kotlin类的继承性" class="headerlink" title="kotlin类的继承性"></a>kotlin类的继承性</h2><p>java的class默认都是可以继承的，只有在声明为final的class才是不可继承的。而kotlin却是相反的，默认的类都是不可继承的，也就是默认的修饰符为final，只有显式的声明为open的类才是可以继承的。而对于抽象类，java和kotlin默认都是可以继承的，但是子类必须是抽象类或者实现了该类的所有抽象方法。</p><h2 id="kotlin扩展函数的java调用方式"><a href="#kotlin扩展函数的java调用方式" class="headerlink" title="kotlin扩展函数的java调用方式"></a>kotlin扩展函数的java调用方式</h2><p>kotlin中的扩展函数是非常方便的，刚开始以为在java中不能够调用到kotlin中的扩展函数，后面发现不是的，对于我们定义的扩展函数类，在java中有相应的使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//KotlinExt.kt</div><div class="line">fun Int.dp2px(context: Context?): Int &#123;</div><div class="line">    val scale = context?.resources?.displayMetrics?.density?.toInt()</div><div class="line">    return (this * (scale ?: 2) + 0.5f).toInt()</div><div class="line">&#125;</div><div class="line">//java中调用</div><div class="line">KotlinExtKt.dp2px(2, getContext());</div></pre></td></tr></table></figure></p><p>我们只需要import相应的kotlinExt文件，然后就可以调用其中的方法，但使用方式和kotlin有不一致的地方，对于kt的扩展函数的接收者，也就是上面的Int，在java中会被认为是第一个入参， 如果扩展函数接受的是普通参数，那么这个参数就直接作为后续的入参。<br>如果扩展数据的第二个参数是lambda表达式，那么有java相应的生成方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//KotlinExt.kt</div><div class="line">inline fun &lt;T&gt; Boolean.yes(action: () -&gt; T): Boolean &#123;</div><div class="line">    if (this) action()</div><div class="line">    return this</div><div class="line">&#125;</div><div class="line">//java中调用</div><div class="line">KotlinExtKt.yes(true, new Function0&lt;Object&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Object invoke() &#123;</div><div class="line">                        return null;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p><p>上面的Boolean的扩展yes方法，接收一个高阶函数，kt中用lambda表示，而在java中，需要以一个匿名内部类的方式替代，</p><h2 id="kotlin中内部类"><a href="#kotlin中内部类" class="headerlink" title="kotlin中内部类"></a>kotlin中内部类</h2><p>在java中，如果定义一个非静态类内部类，默认将会持有外部类的引用，经常会造成外部类无法被回收，导致内存泄漏，而kotlin中，内部类默认不会持有外部类的引用，只有添加上inner关键字修饰，才会持有外部引用。</p><h2 id="kotlin-密封类"><a href="#kotlin-密封类" class="headerlink" title="kotlin 密封类"></a>kotlin 密封类</h2><p>kotlin的密封类是java所没有的，在kotlin中，如果一个类被标明为密封类，那么其所有的子类都需要在父类中列出，作为密封类的嵌套内部类</p><h2 id="kotlin中的惰性集合操作"><a href="#kotlin中的惰性集合操作" class="headerlink" title="kotlin中的惰性集合操作"></a>kotlin中的惰性集合操作</h2><p>kotlin中一些集合操作，比如说map和filter，对于我们来说是非常方便的，比如说筛选一个人群的年龄大于30的人的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.map(it.name).filter&#123;it.age &gt; 30&#125;</div></pre></td></tr></table></figure></p><p>但是上面这种方式，在链式调用的链足够长时，将会产生性能问题，因为链式调用的每一个步骤都会创建一个中间集合，用来存储中间结果，也就是说，每一个步骤的结果都存储在另外一个变量中。所以，kotlin给我们提供了另外一种使用方式，来避免创建中间对象。也就是惰性集合。sequencez作为惰性集合操作，可以优化map和filter等操作，将不会生成任何中间对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.asSequence().map(people.name).filter(it.startWith(&quot;a&quot;)).toList()</div></pre></td></tr></table></figure></p><p>sequencez会将元数据生成一个流式对象，对于集合的每一个元素利用iterator遍历，执行map和filter，筛选出符合条件的数据。<br>惰性集合的操作包含了中间操作和末端操作，中间操作就是转换操作，末端操作就是筛选操作，在上面的例子里面，map是中间操作，filter是末端操作，如果没有末端操作，那么，中间操作也不会执行，既然这样，如果我们末端操作停止了，中间操作也会停止，也就是说，并不会保证所有的中间操作都能够执行。</p><h2 id="butterknife库的使用"><a href="#butterknife库的使用" class="headerlink" title="butterknife库的使用"></a>butterknife库的使用</h2><p>在java中，butterknife库是一个众所周知的代替findViewId操作的库，如果我们直接在kotlin中想要使用butterknife这个库，那还是需要一些额外的操作的。</p><h3 id="引入KotterKnife或者自己提供extension"><a href="#引入KotterKnife或者自己提供extension" class="headerlink" title="引入KotterKnife或者自己提供extension"></a>引入KotterKnife或者自己提供extension</h3><p>这个是butterknife作者提供的另外一个kotlin版本的替代库。使用方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val updateTime by bind&lt;TextView&gt;(R.id.update_time)</div></pre></td></tr></table></figure></p><p>虽然我没看KotterKnife内部实现，但是应该跟我们自己提供扩展函数的实现方式是一样的，我们可以通过自己提供扩展函数来设置做这些操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : View&gt; Activity.bind(@IdRes idRes: Int): Lazy&lt;T&gt; &#123;</div><div class="line">    return lazy &#123; findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T : View&gt; View.bind(@IdRes idRes: Int): Lazy&lt;T&gt; &#123;</div><div class="line">    return lazy &#123; findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T : View&gt; android.support.v7.widget.RecyclerView.ViewHolder.bind(@IdRes idRes: Int): Lazy&lt;T&gt; &#123;</div><div class="line">    return lazy &#123; this.itemView.findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T : View&gt; Fragment.bind(@IdRes idRes: Int): Lazy&lt;T?&gt; &#123;</div><div class="line">    return lazy &#123; this.view?.findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个扩展数据其实就是代替我们执行findViewById操作，虽然我们是在初始化的时候定义了View的对象，但是它并不会马上执行，lazy关键字修饰的对象将会等到使用时再执行相应方法。也就是说，这个findViewById将会在setContentView之后执行，因为我们使用这个对象肯定是在其之后的。</p><h3 id="仍然使用butterknife"><a href="#仍然使用butterknife" class="headerlink" title="仍然使用butterknife"></a>仍然使用butterknife</h3><p>其实在kotlin中，我们还是可以使用butterknife的，只是我们需要将butterknife的注解解释器替换为kotlin annotation Processor tool，这样，在kt文件中就能够使用butterknife的注解了，我们不需要担心会对之前的注解产生影响，因为kapt是兼容了annotationProcessor的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</div><div class="line">====&gt;</div><div class="line">kapt &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</div></pre></td></tr></table></figure></p><p>替换了kapt之后，就可以进行第二步了,在kt中利用laterinit修饰对象，来保证view对象可以在通过butterknife库赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@BindView(R.id.user_v_layout)</div><div class="line">   lateinit var vLayout: ImageView</div><div class="line">   @BindView(R.id.comment_user_icon)</div><div class="line">   lateinit var userIconIV: ImageView</div><div class="line">   @BindView(R.id.comment_user_name)</div><div class="line">   lateinit var userNameTV: TextView</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;onAttachedToWindow和onDetachedFromWindow&quot;&gt;&lt;a href=&quot;#onAttachedToWindow和onDetachedFromWindow&quot; class=&quot;headerlink&quot; title=&quot;onAttachedToWi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(3)</title>
    <link href="https://xjlhhz.com/2018/04/21/20180421Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/04/21/20180421Kotlin入门记录/</id>
    <published>2018-04-21T05:14:00.000Z</published>
    <updated>2018-05-05T15:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="todo标注"><a href="#todo标注" class="headerlink" title="todo标注"></a>todo标注</h2><p>在java中，使用todo标识并不会出现什么问题，在kotlin中，一旦我们实现了接口或者抽象类，那么我们自动生成的实现方法，将会带上kotlin的todo标注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override fun refreshServerTime(time: Long?) &#123;</div><div class="line">        TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>如果我们没有删除掉todo这行代码，那么kotlin将会直接报错，kotlin.NotImplementedError，因为这个todo是kotlin默认我们将会删除掉的，如果在运行时还存在，那么执行到todo，并不会跳过，而是会执行，然后报错。</p><h2 id="kotlin标注"><a href="#kotlin标注" class="headerlink" title="kotlin标注"></a>kotlin标注</h2><p>在kotlin中，如果需要在kotlin的高阶函数表达式返回，而不需要直接在外层函数中返回，或者嵌套循环，想从内层循环终止外层循环等，这种时候我们就需要用到kotlin的label了。比如说下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private fun canAutoContinue(pos: Int): Boolean &#123;</div><div class="line">        if (commonGoodList == null || continueGoodList == null || commonGoodList!!.size &lt; pos) &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">        val commonGood: RechargeGood? = commonGoodList!![pos]</div><div class="line"></div><div class="line">        continueGoodList!!.forEach &#123;</div><div class="line">            if (it.upRenewId == commonGood?.id) &#123;</div><div class="line">                return true</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(&quot;1111&quot;)</div><div class="line">        return false</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>上面的在forEach中，return的执行将会直接将会结束掉canAutoContinue方法，如果我们只想结束掉forEach，我们可以像下面这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private fun canAutoContinue(pos: Int): Boolean &#123;</div><div class="line">        if (commonGoodList == null || continueGoodList == null || commonGoodList!!.size &lt; pos) &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">        val commonGood: RechargeGood? = commonGoodList!![pos]</div><div class="line"></div><div class="line">        continueGoodList!!.forEach lit@&#123;</div><div class="line">            if (it.upRenewId == commonGood?.id) &#123;</div><div class="line">                return@lit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(&quot;1111&quot;)</div><div class="line">        return false</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>如上面的lit label，那么这样return将会结束lit所指定的lable循环，从而继续往下执行。<br>比如说for循环嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">outFor@ for(x in 1..5) &#123;</div><div class="line">            for (y in 1..6) &#123;</div><div class="line">                if(x == y) &#123;</div><div class="line">                    break@outFor</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>一旦满足了x==y，然么将会直接跳出外层的for循环，否则一般的break，只会中断内层的for循环。要为一个表达式加标签，我们只要在其前加标签即可。<br>在返回和跳转语句中，可以指定标签来表示结束哪个标签对应的代码段<br>如果需要在lambda表达式</p><h2 id="kotlin-定义属性时的get和set方法"><a href="#kotlin-定义属性时的get和set方法" class="headerlink" title="kotlin 定义属性时的get和set方法"></a>kotlin 定义属性时的get和set方法</h2><p>kotlin定义属性时，可以同时定义get和set方法，而不需要再重新定义方法去赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private var delayTime: Long</div><div class="line">        private set(value) &#123;</div><div class="line">            delayTime = value</div><div class="line">        &#125;</div><div class="line">        get() &#123;</div><div class="line">            return KKConfigManager.getInstance().</div><div class="line">                    getConfig(KKConfigManager.ConfigType.GET_RECHARGE_ORDER_DELAY)</div><div class="line">                    .toLongOrNull() ?: 1000</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>而且，可以添加上访问限定符。而这个get和set方法的设置，主要是通过代码中的位置来标示修饰的哪个变量。</p><h2 id="kotlin的幕后字段"><a href="#kotlin的幕后字段" class="headerlink" title="kotlin的幕后字段"></a>kotlin的幕后字段</h2><p>Kotlin 中的类不能有字段， 然而我们在有时在自定义访问器时，也就是get和set方法时，需要又一个幕后字段，这个字段是kotlin提供的，field,我们可以直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var counter = 0 // 注意:这个初始器直接为幕后字段赋值 set(value) &#123;</div><div class="line">if (value &gt;= 0) field = value &#125;</div><div class="line"></div><div class="line"></div><div class="line">val nameHash:Int = 3</div><div class="line">        get() &#123;</div><div class="line">            field = 5</div><div class="line">            return 10</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>有可能我们需要临时缓存变量的值，因为可能其变量的值可能和返回的值不一致，所以一旦我们需要知道变量的值，我们便可以通过幕后字段来访问。</p><h2 id="kotlin的幕后属性"><a href="#kotlin的幕后属性" class="headerlink" title="kotlin的幕后属性"></a>kotlin的幕后属性</h2><p>幕后属性主要用于外部只能读，内部可以读写的需求下出现的。例如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val counter get() = _counter</div><div class="line">private var _counter = 0</div></pre></td></tr></table></figure></p><p>这个_counter就是counter的幕后属性，外部只能访问counter，不能访问_counter，而counter的值又是_counter来指定的。</p><h2 id="kotlin的扩展"><a href="#kotlin的扩展" class="headerlink" title="kotlin的扩展"></a>kotlin的扩展</h2><p>在kotlin中，if else的三目运算符如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(a) x else y</div></pre></td></tr></table></figure></p><p>而我们也能通过扩展函数来扩展boolean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T&gt; Boolean.yes(action: () -&gt; T): Boolean &#123;</div><div class="line">    if (this) action()</div><div class="line">    return this</div><div class="line">&#125;</div><div class="line"></div><div class="line">inline fun &lt;T&gt; Boolean.no(action: () -&gt; T): Boolean &#123;</div><div class="line">    if (!this) action()</div><div class="line">    return this</div></pre></td></tr></table></figure></p><p>这样，我们在kt文件中，只要引入相应的类，定义在文件内，而非class下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import com.kuaikan.community.extend.yes</div></pre></td></tr></table></figure></p><p>扩展函数是静态解析的，所以不能够进行重载，这就意味着我们，我们不能重载类原有的方法，比如说collection的add方法等..<br>对于扩展函数还有一个非常好用的东西，被扩展的类型可以为空，被称为可空接收者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun Any?.toString(): String &#123;</div><div class="line">if (this == null) return &quot;null&quot;</div><div class="line">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数</div><div class="line">return toString()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="kotlin的扩展属性"><a href="#kotlin的扩展属性" class="headerlink" title="kotlin的扩展属性"></a>kotlin的扩展属性</h2><p>既然kotlin支持扩展函数，当然也支持扩展属性了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</div><div class="line">   get() = size - 1</div></pre></td></tr></table></figure></p><p>这样就给了List的一个属性lastIndex</p><h2 id="kotlin的范型"><a href="#kotlin的范型" class="headerlink" title="kotlin的范型"></a>kotlin的范型</h2><p>关于out和in这两个关键字，out是用来输出的，也就是生产者，所以只能作为返回类型，相当于java中的extends，用来界定类型上限；in是用来输入的，所以只能作为消费类型，in类似于java中的super，用来界定类型下限</p><h2 id="kotlin的单例"><a href="#kotlin的单例" class="headerlink" title="kotlin的单例"></a>kotlin的单例</h2><p>在kotlin中，声明单例变得非常简单，只需要一个关键字object用来修饰对象，就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句右边，对象的初始化是线程安全的。如果需要引用该对象，我们只需要通过其名称来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object DataProviderManager &#123;</div><div class="line">fun registerDataProvider(provider: DataProvider) &#123;</div><div class="line">// ......</div><div class="line">&#125;</div><div class="line">val allDataProviders: Collection&lt;DataProvider&gt; get() = // ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">DataProviderManager.registerDataProvider(......)</div></pre></td></tr></table></figure></p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>类内部的伴生对象的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123; </div><div class="line">    companion object &#123; &#125;</div><div class="line">&#125;</div><div class="line">val x = MyClass.Companion</div></pre></td></tr></table></figure></p><p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface Factory&lt;T&gt; &#123; fun create(): T</div><div class="line">&#125;</div><div class="line">class MyClass &#123;</div><div class="line">companion object : Factory&lt;MyClass&gt; &#123;</div><div class="line">override fun create(): MyClass = MyClass() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果我们想将伴生对象的成员生成为真正的静态方法和字段，我们我们可以使用@JvmStatic注解</p><h2 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h2><p>对象表达式和对象声明之间有一个重要的语义差别:</p><ul><li>对象表达式是在使用他们的地方立即执行(及初始化)的;</li><li>对象声明是在第一次被访问到时延迟初始化的;</li><li>伴生对象的初始化是在相应的类被加载(解析)时，与 Java 静态初始化器的语义相匹配。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;todo标注&quot;&gt;&lt;a href=&quot;#todo标注&quot; class=&quot;headerlink&quot; title=&quot;todo标注&quot;&gt;&lt;/a&gt;todo标注&lt;/h2&gt;&lt;p&gt;在java中，使用todo标识并不会出现什么问题，在kotlin中，一旦我们实现了接口或者抽象类，那么我们自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(2)</title>
    <link href="https://xjlhhz.com/2018/04/11/20180411Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/04/11/20180411Kotlin入门记录/</id>
    <published>2018-04-11T05:14:00.000Z</published>
    <updated>2018-04-11T14:35:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>kotlin中当含有非空的构造函数得继承，有以下这几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class MemberCenterAdapter(context: Context?, mixFindInfoList: ArrayList&lt;MixFindInfo&gt;?) : TopicTabListAdapter(context, mixFindInfoList)</div></pre></td></tr></table></figure></p><p>相当于子类的构造器声明就放在了class的定义上，然后会对应父类相应的构造器。还有另外一种实现方式，主要用于多个构造器的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor(context: Context?, mixFindInfoList: ArrayList&lt;MixFindInfo&gt;?): super(context, mixFindInfoList)</div></pre></td></tr></table></figure></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表元素访问"><a href="#列表元素访问" class="headerlink" title="列表元素访问"></a>列表元素访问</h3><p>在kotlin中，推荐我们使用下标的方式来访问元素，就像在访问数组一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private var itemTypeList: ArrayList&lt;Int&gt; = ArrayList()</div><div class="line">itemTypeList[2] = ITEM_TYPE_ACTIVITY</div></pre></td></tr></table></figure></p><h3 id="列表元素遍历"><a href="#列表元素遍历" class="headerlink" title="列表元素遍历"></a>列表元素遍历</h3><p>对于kotlin中的列表遍历，增加了许多遍历方式。最简单的如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//kotlin </div><div class="line">for (i in startIndex..mixFindInfoList!!.size )</div><div class="line">//java</div><div class="line">for(int i = startIndex; i &lt; mixFindInfoList.size(); i++)</div></pre></td></tr></table></figure></p><p>在kotlin中，推荐我们使用until的方式进行遍历，这样，我们处理起来也就像是在处理流一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// a until b表示从a到b进行遍历，并且将遍历的值传递给下游，</div><div class="line">// map将上游传递过来的值进行转化，并传递给下游</div><div class="line">// forEach对转化后的值进行处理</div><div class="line">(startIndex until mixFindInfoList!!.size)</div><div class="line">                .map &#123; mixFindInfoList[it] &#125;</div><div class="line">                .forEach &#123;</div><div class="line">                    itemTypeList.add(it.item_type)</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>之前在java中用惯了三目运算符，看着kotlin的三目运算符挺不习惯的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//java, 如果a为true，则取b，否则取c </div><div class="line">a ? b : c</div><div class="line">//kotlin, 利用if else组成三目运算符，但是不需要括号</div><div class="line">if(a) b else c</div></pre></td></tr></table></figure></p><h2 id="函数中流程语句的返回值"><a href="#函数中流程语句的返回值" class="headerlink" title="函数中流程语句的返回值"></a>函数中流程语句的返回值</h2><p>在kotlin中，如果多个分支语句都返回值，那么我们可以将返回值放在分支语句的外侧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//最原始的版本</div><div class="line">when (position) &#123;</div><div class="line">    0, 2 -&gt; return null</div><div class="line">    1 -&gt; return Utility.getSafely(mixFindInfoList, 0)</div><div class="line">    else -&gt; &#123;</div><div class="line">        return Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)</div><div class="line">            &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>优化后的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">return when (position) &#123;</div><div class="line">    0, 2 -&gt; null</div><div class="line">    1 -&gt; Utility.getSafely(mixFindInfoList, 0)</div><div class="line">    else -&gt; &#123;</div><div class="line">    Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)                &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>这种时候，就能够返回每一个when分支对应的值<br>对于if else语句也能这么使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">return if (activityListExist()) &#123;</div><div class="line">           if (vipBannerExist()) &#123;</div><div class="line">               when (position) &#123;</div><div class="line">                   0, 2 -&gt; null</div><div class="line">                   1 -&gt; Utility.getSafely(mixFindInfoList, 0)</div><div class="line">                   else -&gt; &#123;</div><div class="line">                       Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; else &#123;</div><div class="line">               if (position == 0 || position == 1) &#123;</div><div class="line">                   null</div><div class="line">               &#125; else &#123;</div><div class="line">                   Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           if (position == 0) &#123;</div><div class="line">               null</div><div class="line">           &#125; else &#123;</div><div class="line">               Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 1)</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>这种时候，每一种判断的分支对应一个值，返回命中的分支对应的值</p><h2 id="类型判断和类型转换"><a href="#类型判断和类型转换" class="headerlink" title="类型判断和类型转换"></a>类型判断和类型转换</h2><p>java中类型判断和转化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (holder instance of MemberVipHeaderHolder) &#123;</div><div class="line">    ((MemberVipHeaderHolder)holder).bindData(title, TYPE_VIP_HEADER, isVip, isBtnShow);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>java中利用instance of进行类型判断，然后直接通过(type)instance进行类型强转，将instance转化为type类型的实例。如果instance不是type类型，那么将会抛出类型转化异常。<br>而在kotlin中，可以通过as和is关键字进行类型判断和转化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123;</div><div class="line">        when (getItemViewType(position)) &#123;</div><div class="line">            ITEM_TYPE_ACTIVITY -&gt; &#123;</div><div class="line">                if (holder is MemberAssignViewHolder) &#123;</div><div class="line">                    holder.bindData(activityList)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ITEM_TYPE_MEMBER_INFO_CARD -&gt; &#123;</div><div class="line">                if (holder is MemberInfoCardViewHolder) &#123;</div><div class="line">                    holder.bindData()</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else -&gt; &#123;</div><div class="line">                holder.itemView.setPadding(0, 0, 0, if (position == itemCount - 1) UIUtil.dp2px(40f) else 0)</div><div class="line">                if (holder is BaseViewHolder) &#123;</div><div class="line">                    holder.holderType = BaseViewHolder.TYPE_MEMBER</div><div class="line">                &#125;</div><div class="line">                super.onBindViewHolder(holder, position)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>利用 a is type 来判断a是否是type类型，如果是type类型的话，那么kotlin将会自动为我们将a转化为type类型，而不需要我们再手动的利用as进行类型转化。如果kotlin直接利用as进行类型转化的话，如果类型不一致或者a为null时，也会抛出异常，但是kotlin提供了类型不一致时的安全转化，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val x: String ?= y as? String</div></pre></td></tr></table></figure></p><p>上面的例子中，as?是一个安全转化符，如果失败，将会返回null，而不会直接进行类型转化。</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>在java中，需要升级到java8才支持lambda表达，而kotlin天生支持lambda表达式，lambda表达式的完成语法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val sum = &#123; x: Int, y: Int -&gt; x + y &#125;</div></pre></td></tr></table></figure></p><p>上面的例子定义了一个函数，求得sum = x + y,lambda表达式总是括在大括号中，完整的参数声明和表达式都放在大括号内，函数体在-&gt;之后，-&gt;之前都是参数，并且可能有类型标注，如果推断出该lambda的返回值类型不是Unit，也就是返回值不为空，那么该lambda主体的最后一个表达式将被视为返回值<br>下面是某一个lambda的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FindExchangeManager.getInstance().loadExchangeData(mContext, findInfo.discoveryModuleId,</div><div class="line">                    holder.adapterPosition, findInfo, FindExchangeManager.ExchangeCallback &#123; data, position, discoveryModuleId -&gt;</div><div class="line">                if (Utility.isEmpty(mContext)) &#123;</div><div class="line">                    return@ExchangeCallback</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                val info = getMixInfoFromPosition(position)</div><div class="line">                if (data != null &amp;&amp; info != null) &#123;</div><div class="line">                    info.topics = data</div><div class="line">                    notifyItemChanged(position)</div><div class="line">                &#125;</div><div class="line">            &#125;)</div></pre></td></tr></table></figure></p><p>如果在lambda表达式中调用return，将会直接return掉整个上层函数，因为lambda表达式只是一个代码块，虽然看起来功能像是函数，不过也不能说在lambda表达式中不能够return，只要给return指定一个标签，就会结束掉标签所指定的代码块，就像上面的例子，这个lambda表达式是在ExchangeCallback中使用的，如果要结束这个lambda，那么只需要在lambda中return代码添加上@ExchangeCallback标签就行，就绘结束掉ExchangeCallback的这个方法。</p><h2 id="ViewHolder中使用kotlin-extension"><a href="#ViewHolder中使用kotlin-extension" class="headerlink" title="ViewHolder中使用kotlin extension"></a>ViewHolder中使用kotlin extension</h2><p>kotlin extension的使用需要先导入相应的xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在上一篇的activity中</div><div class="line">import kotlinx.android.synthetic.main.activity_member_center.*</div><div class="line"></div><div class="line">//在这个viewHolder中</div><div class="line">import kotlinx.android.synthetic.main.listitem_assign.view.*</div></pre></td></tr></table></figure></p><p>对于这个导包操作，需要注意的是，kotlinx.android.synthetic.main是固定前缀，后面的是当前页面的layout文件名称，如果是activity，只需要再在后面添加上.<em>，那就能够在activity中直接以id的形式调用对应的View。如果是在viewHolder中，那么还需要添加上.view,在添加.</em>才能够使用，而且在viewHolder中，需要以其itemView为持有者来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">init &#123;</div><div class="line">        context = itemView.context</div><div class="line">        itemView.btn_get_gift.setOnClickListener(this)</div><div class="line">        itemView.btn_not_gift.setOnClickListener(this)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>如上所示，利用itemView来持有其中的view的id，并直接调用。<br>这个init块，通常都是来做类的初始化的，在构造器执行完之后，会调用这个init块，我们如果有什么需要做初始化的，只需要放在这个init块中</p><h2 id="String-转其他类型"><a href="#String-转其他类型" class="headerlink" title="String 转其他类型"></a>String 转其他类型</h2><p>java中String转long类型的话，需要调用Long.paras(string)进行转化，如果string不是相应的的类型，那么将会抛出异常。而在kotlin中也有这个方法，不过还新增了几个转化的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//如果string不是一个合法的类型，那么将会抛出异常NumberFormatException</div><div class="line">string.toLong()</div><div class="line"></div><div class="line">//如果string不是一个合法的类型，那么将会返回null</div><div class="line">string.toLongOrNull()</div></pre></td></tr></table></figure></p><h2 id="结合rxjava"><a href="#结合rxjava" class="headerlink" title="结合rxjava"></a>结合rxjava</h2><p>kotlin中有专门的rx-kotlin库，刚开始并没有引入这个库，所以尝试着还是使用rxjava<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.timer(getDelayTime(), TimeUnit.MILLISECONDS)</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(&#123;</div><div class="line">                    getGrabResult(activityId, thirdId)</div><div class="line">                &#125;)</div></pre></td></tr></table></figure></p><p>还是一样的用法，不过好的一点是可以使用lambda表达式了，subscribe({})中间的花括号就是lambda表达式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;kotlin中当含有非空的构造函数得继承，有以下这几种方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(1)</title>
    <link href="https://xjlhhz.com/2018/04/09/20180409Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/04/09/20180409Kotlin入门记录/</id>
    <published>2018-04-09T05:14:00.000Z</published>
    <updated>2018-04-11T14:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h1><p>随着google将kotlin捧为官方语言，众多的app从java开始迁移到kotlin的大军中，我也想用kotlin开发android，虽然团队中的其他人并没有这个想法，我还是想试试，所以从今天起，开始学习kotlin。</p><h2 id="我的kotlin学习"><a href="#我的kotlin学习" class="headerlink" title="我的kotlin学习"></a>我的kotlin学习</h2><p>我用了很少的时间看了kotlin的基本语法，存粹的做语法笔记似乎对我来说并没有什么用途，所以我打算通过我日常写的项目中的java文件，将其一步一步转为kotlin，并且记录一些未知的点，因为只有来自于实践的学习才能更深入，记得更久</p><h2 id="将一个activity的java文件转为kotlin文件"><a href="#将一个activity的java文件转为kotlin文件" class="headerlink" title="将一个activity的java文件转为kotlin文件"></a>将一个activity的java文件转为kotlin文件</h2><h3 id="最简单的转化方式"><a href="#最简单的转化方式" class="headerlink" title="最简单的转化方式"></a>最简单的转化方式</h3><p>android stutdio支持一键转化的方式，通过快捷键ctrl +alt + shift + k将整个java文件转化为kt文件，不过可能需要自己解决一些代码不一致的冲突，而且有些时候转化后的代码和我们直接写的代码还是有差别的。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="kotlin库引入"><a href="#kotlin库引入" class="headerlink" title="kotlin库引入"></a>kotlin库引入</h4><p>android studio3.0默认支持kotlin，虽然是默认支持kotlin，但也是需要增加一些配置，不过这个as已经给我们做好了智能提示和自动添加的功能。在我们第一次创建出kt文件的时候，将会有一个kotlin的配置提示，我们只需要点击configure，然后选择全局配置，那么as将会在gradle中添加上kotlin的依赖<br><img src="http://onu21exz8.bkt.clouddn.com/%E9%85%8D%E7%BD%AEkotlin.jpeg" alt=""><br>gradle文件如下所示:<br><img src="http://onu21exz8.bkt.clouddn.com/kotlin%E7%9A%84gradle%E4%BF%AE%E6%94%B9.jpeg" alt=""><br>这样我们就使用kotlin的代码库了。</p><h4 id="kotlin-extension库引入"><a href="#kotlin-extension库引入" class="headerlink" title="kotlin extension库引入"></a>kotlin extension库引入</h4><p>之前项目中用的是view的绑定库是ButterKnife，就个人而言，还是觉得挺好用的，毕竟绑定View的代码都能自动生成，不过如果在kt文件中，不能直接引入这个库，需要重新引入kotlin中的ButterKnife库<a href="https://github.com/JakeWharton/kotterknife，不过我们可以不用这个库了，因为kotlin给我们提供了一套更为简便的库，我们只需要在gradle中引入kotlin-extension，并且在kt文件中import相对应的xml，就能直接通过id的方式引用view。" target="_blank" rel="external">https://github.com/JakeWharton/kotterknife，不过我们可以不用这个库了，因为kotlin给我们提供了一套更为简便的库，我们只需要在gradle中引入kotlin-extension，并且在kt文件中import相对应的xml，就能直接通过id的方式引用view。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在kt文件中</div><div class="line">import kotlinx.android.synthetic.main.activity_member_center.*</div><div class="line"></div><div class="line">//在gradle文件中</div><div class="line">apply plugin: &apos;kotlin-android-extensions&apos;</div></pre></td></tr></table></figure></p><p>比如说我们在xml中有这样一个View：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;android.support.v7.widget.RecyclerView</div><div class="line">       android:id=&quot;@+id/memberRv&quot;</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;match_parent&quot;</div><div class="line">       android:layout_below=&quot;@+id/member_center_tool_bar&quot;</div><div class="line">       android:layout_centerHorizontal=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure></p><p>这样我们在kt文件中，可以像下面的方式这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private fun initRv() &#123;</div><div class="line">        adapter = MemberInfoAdapter(this, null)</div><div class="line">        memberRv.layoutManager = LinearLayoutManager(this)</div><div class="line">        memberRv.itemAnimator?.changeDuration = 0</div><div class="line">        memberRv.adapter = adapter</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这个memberRv就是RecyclerView在xml中指定的id。</p><h3 id="一些常用用法"><a href="#一些常用用法" class="headerlink" title="一些常用用法"></a>一些常用用法</h3><h4 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h4><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>在kotlin中，声明所有变量都需要3个关键字修饰，var、val和const。在kotlin中是没有final修饰符的，final修饰符在kotlin中其实就相当于val</p><ul><li>var:主要是用来修饰可变变量的。</li><li><p>val：主要是用来修饰不可变变量的，其实也不能说是不可变，更好的称呼是叫做只读变量，val在修饰变量的时候可以不初始化，但是它不能被赋值，在java中，用final修饰的变量必须要初始化，否则编译不能通过。举个val修饰不初始化的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class a &#123;</div><div class="line">var c = 1;</div><div class="line">val b: String</div><div class="line">fun getB(): String &#123;</div><div class="line">    return c &gt; 3 ? &quot;haha&quot; : &quot;xixi&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun add() &#123;</div><div class="line">    c++</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>const:其实const就和java中的static final一致了，不能放在局部方法中，在编译期间必须确定变量值。</p><h5 id="静态变量及静态方法"><a href="#静态变量及静态方法" class="headerlink" title="静态变量及静态方法"></a>静态变量及静态方法</h5><p>在java中，静态属性和静态方法只需要一个static属性就能搞定了，但是在kotlin，它有一个单独的块来标识静态块的初始化，companion object:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">companion object &#123;</div><div class="line">        val intentFrom: String = &quot;intent_extra&quot;</div><div class="line">        fun startMemberCenterActivity(context: Context,                 launchMemberCenter: LaunchMemberCenter) &#123;</div><div class="line">            var intent = Intent(context, TestAc::class.java)</div><div class="line">            intent.putExtra(intentFrom, launchMemberCenter)</div><div class="line">            if (context is Activity) &#123;</div><div class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</div><div class="line">            &#125;</div><div class="line">            context.startActivity(intent)</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>这个代码块有几个需要注意的点，</p><ul><li>在kt定义Intent中，class的指定需要已类名::class.java的方式指定，否则在log中会提示找不到activity</li><li>在这个静态块中，定义的变量和方法都是静态的</li><li>在外部如果需要访问这个块的方法，如果是kotlin文件访问，可以直接通过类名.的方式调用，如果是java文件访问，需要通过类名.companion.的方式调用:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//在java文件中调用</div><div class="line">public void start() &#123;</div><div class="line">       TestAc.Companion.startMemberCenterActivity(context, this);</div><div class="line">   &#125;</div><div class="line">//在kt文件中调用</div><div class="line">public void start() &#123;</div><div class="line">       TestAc.startMemberCenterActivity(context, this);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ul><h5 id="kotlin的空指针安全"><a href="#kotlin的空指针安全" class="headerlink" title="kotlin的空指针安全"></a>kotlin的空指针安全</h5><p>在变量定义时，我们可以通过kotlin特有的方式来标识变量是否可空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private var adapter: MemberInfoAdapter? = null</div></pre></td></tr></table></figure></p><p>只需要的变量类型后面添加?，就表示这个变量是可以为null的，如果不添加，默认这个变量不能为null。一旦我们添加了?，在后续的代码中，如果有引用到这个变量的地方，如果没有做判空处理将会编译不过，这个判空处理还是挺方便的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override fun refreshDiscoveryList(mixFindInfoList: MutableList&lt;MixFindInfo&gt;?) &#123;</div><div class="line">       adapter?.notifyMixFindInfoChange(mixFindInfoList)</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>Equality check should be used instead of elvis for nullable boolean check<br>在调用时，如果adaper为空了，将不会执行后续的操作。<br>今天遇到了一个符号:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var xie = a ?: &quot;&quot;</div></pre></td></tr></table></figure></p><p>这个?:是kotlin的elvis用法，属于两目运算符，就是简单的if、else缩写，<br>当a不为null，取a的值，当a为null，取””</p><h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><p>kotlin接口和java接口的使用区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class TestAc : BaseMvpActivity&lt;MemberCenterPresent&gt;(), MemberCenterPresent.MemberInfoChange,</div><div class="line">        KKAccountManager.KKAccountChangeListener, View.OnClickListener &#123;</div></pre></td></tr></table></figure></p><p>其中BaseMvpActivity继承，而其他三个都是接口继承。</p><ul><li>java接口需要用implements关键字实现，而kotlin实现的方式和继承一样</li><li><p>java接口能够直接通过匿名内部类创建出来，而kotlin也需要先将接口对象创建出来</p><h4 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h4><p>在kotlin中，用when表达式将将java中的switch替换掉了。<br>最简单的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">override fun onClick(v: View?) &#123;</div><div class="line">      when (v?.id) &#123;</div><div class="line">          R.id.icBack -&gt; finish()</div><div class="line">          R.id.btnOpenLayout -&gt; btnOpenLayoutClick()</div><div class="line">          else -&gt; &#123;</div><div class="line">          </div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>而且，when里面的条件判断可以加入比较复杂的判断，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> when (x) &#123;</div><div class="line">    in 1..10 -&gt; print(&quot;x is in the range&quot;)</div><div class="line">    in validNumbers -&gt; print(&quot;x is valid&quot;)</div><div class="line">    !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</div><div class="line">    else -&gt; print(&quot;none of the above&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kotlin&quot;&gt;&lt;a href=&quot;#kotlin&quot; class=&quot;headerlink&quot; title=&quot;kotlin&quot;&gt;&lt;/a&gt;kotlin&lt;/h1&gt;&lt;p&gt;随着google将kotlin捧为官方语言，众多的app从java开始迁移到kotlin的大军中，我也想用k
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BlockCanary解析</title>
    <link href="https://xjlhhz.com/2018/02/11/0211BlockCanary%E8%A7%A3%E6%9E%90/"/>
    <id>https://xjlhhz.com/2018/02/11/0211BlockCanary解析/</id>
    <published>2018-02-11T05:14:00.000Z</published>
    <updated>2018-02-11T13:25:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blockCanary"><a href="#blockCanary" class="headerlink" title="blockCanary"></a>blockCanary</h1><p>对于android里面的性能优化，最主要的问题就是UI线程的阻塞导致的，对于如何准确的计算UI的绘制所耗费的时间，是非常有必要的，blockCanary是基于这个需求出现的，同样的，也是基于LeakCanary，和LeakCanary有着显示页面和堆栈信息。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>它的内部原理特别简单，简单到不能再简单了。<br>UI线程的Looper只有一个，也就是所有的handler最后都会走到这个地方，我们看看其消息的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">    ...</div><div class="line">    for (;;) &#123;</div><div class="line">        ...</div><div class="line">        // This must be in a local variable, in case a UI event sets the logger</div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                    msg.callback + &quot;: &quot; + msg.what);</div><div class="line">        &#125;</div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>在上面的loop循环的代码中，msg.target.dispatchMessage就是我们UI线程收到每一个消息需要执行的操作，都在其内部执行。系统也在其执行的前后都添加上了log的输出，所以只要我们在运行的前后都添加一个时间戳，用运行后的时间减去运行前的时间，一旦这个时间超过了我们设定的阈值，那么就可以说这个操作卡顿，阻塞了UI线程，通过dump出此时的各种信息，来分析各种性能瓶颈，这就是这个工具的实现原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;blockCanary&quot;&gt;&lt;a href=&quot;#blockCanary&quot; class=&quot;headerlink&quot; title=&quot;blockCanary&quot;&gt;&lt;/a&gt;blockCanary&lt;/h1&gt;&lt;p&gt;对于android里面的性能优化，最主要的问题就是UI线程的阻塞导致
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leedcode多数之和的解法</title>
    <link href="https://xjlhhz.com/2018/02/01/0201Leetcode%E5%A4%9A%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98%E8%A7%A3%E6%B3%95/"/>
    <id>https://xjlhhz.com/2018/02/01/0201Leetcode多数之和问题解法/</id>
    <published>2018-02-01T05:14:00.000Z</published>
    <updated>2018-02-02T03:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="twoSum问题"><a href="#twoSum问题" class="headerlink" title="twoSum问题"></a>twoSum问题</h1><h2 id="题目：从一个有序数组里面，找到和为指定值的两个数-假设有唯一解-的index值。"><a href="#题目：从一个有序数组里面，找到和为指定值的两个数-假设有唯一解-的index值。" class="headerlink" title="题目：从一个有序数组里面，找到和为指定值的两个数(假设有唯一解)的index值。"></a>题目：从一个有序数组里面，找到和为指定值的两个数(假设有唯一解)的index值。</h2><h3 id="解法1-暴力求解O-n-2"><a href="#解法1-暴力求解O-n-2" class="headerlink" title="解法1.暴力求解O(n^2)"></a>解法1.暴力求解O(n^2)</h3><p>通过两层循环，两层for循环求值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">  for(int j = i +1; j &lt; nums.length; j++) &#123;</div><div class="line">     if(num[i] + num[j] == target) &#123;</div><div class="line">        //找到该值</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="解法2-暴力解法优化O-nlgn"><a href="#解法2-暴力解法优化O-nlgn" class="headerlink" title="解法2.暴力解法优化O(nlgn)"></a>解法2.暴力解法优化O(nlgn)</h3><p>第一层外部循环通过遍历，第二层循环，因为是有序数组，所以可以通过二分查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> int j = nums.length / 2;</div><div class="line"> for (int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">     if (nums[i] + nums[j] &gt; target) &#123;</div><div class="line">          j--;</div><div class="line">     &#125; else if (nums[i] + nums[j] &lt; target) &#123;</div><div class="line">          j++;</div><div class="line">     &#125; else &#123;</div><div class="line">           //find it;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="解法3-hashMap存值-O-n"><a href="#解法3-hashMap存值-O-n" class="headerlink" title="解法3.hashMap存值.O(n)"></a>解法3.hashMap存值.O(n)</h3><p>每次都遍历新值，将没找到的值和index存入hashMap，直到找到为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</div><div class="line">      for (int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">          if (!map.containsValue(target - nums[i])) &#123;</div><div class="line">              map.put(i, nums[i]);</div><div class="line">          &#125; else &#123;</div><div class="line">              //find it</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><h1 id="3Sum问题"><a href="#3Sum问题" class="headerlink" title="3Sum问题"></a>3Sum问题</h1><h2 id="题目：在一个数组中找到所有3数和为0的列表，需要保证去重。"><a href="#题目：在一个数组中找到所有3数和为0的列表，需要保证去重。" class="headerlink" title="题目：在一个数组中找到所有3数和为0的列表，需要保证去重。"></a>题目：在一个数组中找到所有3数和为0的列表，需要保证去重。</h2><h3 id="解法1-暴力解法，三层遍历，然后去重复-O-n-3"><a href="#解法1-暴力解法，三层遍历，然后去重复-O-n-3" class="headerlink" title="解法1:暴力解法，三层遍历，然后去重复,O(n^3)"></a>解法1:暴力解法，三层遍历，然后去重复,O(n^3)</h3><h3 id="解法2-将3数和转化为2数和，再进行求解O-n-2"><a href="#解法2-将3数和转化为2数和，再进行求解O-n-2" class="headerlink" title="解法2:将3数和转化为2数和，再进行求解O(n^2)"></a>解法2:将3数和转化为2数和，再进行求解O(n^2)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">  Arrays.sort(nums);</div><div class="line">       List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">       for (int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">   //if判断去重复，保证每一个同样的数值只计算一次</div><div class="line">          if (i == 0 || nums[i] &gt; nums[i - 1]) &#123;</div><div class="line">               int targets = -nums[i];</div><div class="line">              int left = i + 1;</div><div class="line">              int right = nums.length - 1;</div><div class="line">              while (left &lt; right) &#123;</div><div class="line">                  if (nums[left] + nums[right] &gt; targets) &#123;</div><div class="line">                      left++;</div><div class="line">                  &#125; else if (nums[left] + nums[right] &lt; targets) &#123;</div><div class="line">                      right--;</div><div class="line">                  &#125; else &#123;</div><div class="line">                      List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</div><div class="line">                      list1.add(nums[i]);</div><div class="line">                      list1.add(nums[left]);</div><div class="line">                      list1.add(nums[right]);</div><div class="line">                      list.add(list1);</div><div class="line">                      left++;</div><div class="line">                      right--;</div><div class="line">       //去重复，保证每个同样的left和right只计算一次</div><div class="line">                      while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123;</div><div class="line">                          left++;</div><div class="line">                      &#125;</div><div class="line">                      while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123;</div><div class="line">                          right--;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">       return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="3clostSum问题"><a href="#3clostSum问题" class="headerlink" title="3clostSum问题"></a>3clostSum问题</h1><h2 id="题目：求一个列表里面最接近指定数值的和，假设最接近的数值只会有一个。"><a href="#题目：求一个列表里面最接近指定数值的和，假设最接近的数值只会有一个。" class="headerlink" title="题目：求一个列表里面最接近指定数值的和，假设最接近的数值只会有一个。"></a>题目：求一个列表里面最接近指定数值的和，假设最接近的数值只会有一个。</h2><h3 id="解法：将3数和转化为2数和。与上面的三数和类似"><a href="#解法：将3数和转化为2数和。与上面的三数和类似" class="headerlink" title="解法：将3数和转化为2数和。与上面的三数和类似"></a>解法：将3数和转化为2数和。与上面的三数和类似</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">       Arrays.sort(nums);</div><div class="line">//定义一个最大值，</div><div class="line">       int minSum = Integer.MAX_VALUE;</div><div class="line">       for (int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">   //遍历并去重复</div><div class="line">          if (i == 0 || nums[i] &gt; nums[i - 1]) &#123;</div><div class="line">       //求剩余两数的目标和</div><div class="line">              int targets = target - nums[i];</div><div class="line">              int left = i + 1;</div><div class="line">       int ret = 0;</div><div class="line">              int right = nums.length - 1;</div><div class="line">              while (left &lt; right) &#123;</div><div class="line">   //求和并比较，</div><div class="line">                  int sum = nums[i] + nums[left] + nums[right];</div><div class="line">                  if (Math.abs(sum - target) &lt; minSum) &#123;</div><div class="line">      //找到更临近的</div><div class="line">                      minSum = Math.abs(sum - target);</div><div class="line">       ret = sum;</div><div class="line">                  &#125;</div><div class="line">                  if (nums[left] + nums[right] &gt; targets) &#123;</div><div class="line">                      left++;</div><div class="line">                  &#125; else if (nums[left] + nums[right] &lt; targets) &#123;</div><div class="line">                      right--;</div><div class="line">                  &#125; else &#123;</div><div class="line">                    return sum;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">       &#125;</div><div class="line">       return ret;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h1 id="4Sum问题"><a href="#4Sum问题" class="headerlink" title="4Sum问题"></a>4Sum问题</h1><p>4数和为问题可以转化为3数和来求解，最外层加个for循环，然后完善下3sum的逻辑判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</div><div class="line">      Arrays.sort(nums);</div><div class="line">      List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">      for (int i = 0; i &lt; nums.length; i++) &#123;</div><div class="line">          for (int j = i + 1; j &lt; nums.length; j++) &#123;</div><div class="line">  //对j相等的值去重复</div><div class="line">                if (nums[j] == nums[j - 1] &amp;&amp; j - 1 &gt; i) &#123;</div><div class="line">                  continue;</div><div class="line">              &#125;</div><div class="line">//对i相等的值去重复</div><div class="line">              if (i == 0 || nums[i] &gt; nums[i - 1]) &#123;</div><div class="line">                  int target1 = target - nums[i] - nums[j];</div><div class="line">                  int left = j + 1;</div><div class="line">                  int right = nums.length - 1;</div><div class="line">                  while (left &lt; right) &#123;</div><div class="line">                      if (nums[left] + nums[right] &lt; target1) &#123;</div><div class="line">                          left++;</div><div class="line">                      &#125; else if (nums[left] + nums[right] &gt; target1) &#123;</div><div class="line">                          right--;</div><div class="line">                      &#125; else &#123;</div><div class="line">                          List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</div><div class="line">                          integers.add(nums[i]);</div><div class="line">                          integers.add(nums[j]);</div><div class="line">                          integers.add(nums[left]);</div><div class="line">                          integers.add(nums[right]);</div><div class="line">                          list.add(integers);</div><div class="line">                          left++;</div><div class="line">                          right--;</div><div class="line">    //对left和right去重复</div><div class="line">                          while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123;</div><div class="line">                              left++;</div><div class="line">                          &#125;</div><div class="line">                          while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123;</div><div class="line">                              right--;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">          return list;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;twoSum问题&quot;&gt;&lt;a href=&quot;#twoSum问题&quot; class=&quot;headerlink&quot; title=&quot;twoSum问题&quot;&gt;&lt;/a&gt;twoSum问题&lt;/h1&gt;&lt;h2 id=&quot;题目：从一个有序数组里面，找到和为指定值的两个数-假设有唯一解-的index值。&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个简单的mvp框架</title>
    <link href="https://xjlhhz.com/2018/01/24/0124%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVP%E6%A1%86%E6%9E%B6/"/>
    <id>https://xjlhhz.com/2018/01/24/0124一个简单的MVP框架/</id>
    <published>2018-01-24T05:14:00.000Z</published>
    <updated>2018-04-08T08:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android中的各种框架"><a href="#android中的各种框架" class="headerlink" title="android中的各种框架"></a>android中的各种框架</h1><p>在主流的开发框架中，目前比较流行的框架有MVC，MVP，MVVM框架。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC框架算是比较常见的一种开发框架了，即模型-视图-控制器，model用来存储数据，view来做界面的显示与绘制，控制器用来处理逻辑，处理Model和View之间的交互，当然view和model之间还有交互，view可以直接从model类存取数据，model也能够直接改变view的显示。<br><img src="http://onu21exz8.bkt.clouddn.com/mvc.jpeg" alt=""></p><p>###优点-缺点：<br>相较于没有框架来说，有了部分解耦，把业务逻辑和展示逻辑区分开，但是仍然耦合严重，在android中，一个activity几乎担任了view和control的职责，和model耦合很重。</p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>在android中，mvp框架应该是目前用的较为广泛的，即模型-视图-Present，对于android来说，视图就是activity或者fragment及view，而present完全负责了view和model的逻辑交互。view只负责UI显示，present通过接口的形式，将处理完的逻辑调用接口改变UI。而model和view之间完全解耦，没有任何交互。<br><img src="http://onu21exz8.bkt.clouddn.com/mvp.jpeg" alt=""></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>mvp相较于mvc来说，对于view和model是完全解耦了，model只负责自身的数据处理，所有的逻辑处理的放在了present，大大减少了android中view的逻辑处理。因为解耦，所以整个项目结构会比较清晰，也比较易于维护。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个是解耦的设计的通病，一旦解耦了，代码量就上去了，而且文件数添加特别多，对于每一次改动，我们都需要改动inteface和inteface所对应的实现，但是为了项目的维护，这个应该是值得的。</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>这个是最近几年刚提出的框架，通过xml和java代码的自动生成，来实现数据源与view的绑定与监听。一旦数据发生改变，view也会相应的作出改变。这个要了解的话可以看看我之前的一篇文章。</p><h1 id="light-mvp框架的使用"><a href="#light-mvp框架的使用" class="headerlink" title="light-mvp框架的使用"></a>light-mvp框架的使用</h1><p>这个框架是我在项目开发中写的，自己觉得挺方便的，所以分享一下。下面来看看这个mvp框架的简单使用。</p><h2 id="present"><a href="#present" class="headerlink" title="present"></a>present</h2><p>首先创建相应业务的present,内部定义了相应View需要实现的接口，prensent通过这个接口来改变UI<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class ExamPresent extends BasePresent &#123;</div><div class="line">     public interface InterA &#123;</div><div class="line">       void change();</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     @BindV</div><div class="line">     InterA interA;</div><div class="line">     .....</div><div class="line"> &#125;</div></pre></td></tr></table></figure><br>present需要添加@BindV注解,而且需要实现BasePresent</p><h2 id="activity-or-fragment"><a href="#activity-or-fragment" class="headerlink" title="activity or fragment"></a>activity or fragment</h2><p>对于activity和fragment来说，实现绑定present的逻辑是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//activity</div><div class="line">public class ExamActivity extends BaseActivity implement ExamPresent.InterA &#123;</div><div class="line">  </div><div class="line">  ....</div><div class="line">  @BindP</div><div class="line">  ExamPresent present</div><div class="line">  </div><div class="line">  &#125;</div><div class="line"></div><div class="line">//fragment</div><div class="line">public class ExamFragment extends BaseFragment implement ExamPresent.InterA &#123;</div><div class="line">  </div><div class="line">  ....</div><div class="line">  @BindP</div><div class="line">  ExamPresent present</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure><br>对于activity来说，需要实现BaseActivity，而fragment需要实现BaseFragment，然后需要实现对应的present指定的接口，最后通过@BindP注解相应的present，一旦完成了这两步，view和present就绑定了</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>present生命周期随着fragment的oncreateView方法和activity的onCreate方法创建。 随着fragment的onDestoryView方法和activity的onDestory方法销毁。<br> 一个fragment和acitivty支持绑定多个present， 一个present实例只支持绑定一个view</p><h1 id="light-mvp实现原理"><a href="#light-mvp实现原理" class="headerlink" title="light-mvp实现原理"></a>light-mvp实现原理</h1><h2 id="注解绑定V和P"><a href="#注解绑定V和P" class="headerlink" title="注解绑定V和P"></a>注解绑定V和P</h2><p>先来看看两个注解的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//BindP</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(ElementType.FIELD)</div><div class="line">public @interface BindP &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">//BindV</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(ElementType.FIELD)</div><div class="line">public @interface BindV &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><br>这两个注解并没有参数，仅仅只是标识了变量的类型，以便于我们在反射中取值与赋值。<br>下面来看看activity绑定p的过程，fragment绑定p的过程基本类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">   public static void parasBindPresent(BaseMvpActivity activity) &#123;</div><div class="line">       Class clazz = activity.getClass();</div><div class="line">//遍历当前类以及其父类，看是否存在BindP注解</div><div class="line">       while (!(clazz.equals(Object.class) )) &#123;</div><div class="line">           parasBindPresent(activity, clazz);</div><div class="line">           clazz = clazz.getSuperclass();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">  //绑定入口</div><div class="line">   private static void parasBindPresent(BaseMvpActivity&lt;BasePresent&gt; activity, Class clazz) &#123;</div><div class="line">       //获取当前baseMvpActivity的成员变量，</div><div class="line"> Field[] fields = clazz.getDeclaredFields();</div><div class="line">       for (Field f : fields) &#123;</div><div class="line">           //遍历所有的成员变量，找到添加了BindP注解的成员</div><div class="line">           if (f.isAnnotationPresent(BindP.class)) &#123;</div><div class="line">               try &#123;</div><div class="line">    //获取Present的类型</div><div class="line">                   Class&lt;?&gt; c = f.getType();</div><div class="line">     //创建Present对象</div><div class="line">                   Object t = c.newInstance();</div><div class="line">                  </div><div class="line">    f.setAccessible(true);</div><div class="line">    //给activity中的present变量赋值为t，也就是我们刚创建出来的present对象</div><div class="line">                   f.set(activity, t);</div><div class="line">    </div><div class="line">    //为了生命周期处理，需要对BasePresent和BaseMvpActivity互相引用</div><div class="line">    //所有的BasePresent定义了attachView方法，</div><div class="line">                   ((BasePresent) t).attachView(activity);</div><div class="line">    //activity添加present</div><div class="line">                   activity.addPresent((BasePresent) t);</div><div class="line">     //因为绑定是双向绑定，既然v已经绑定了p，那么接下来需要做的就是p绑定v</div><div class="line">                   ParasBindVAnnotation.parasBindView(t, activity);</div><div class="line">               &#125; catch (InstantiationException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125; catch (IllegalAccessException e) &#123;</div><div class="line">                   e.printStackTrace();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>上面的代码无非就是通过反射，进行v绑定p，下面看看p绑定v<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void parasBindView(Object t, BaseMvpActivity activity) &#123;</div><div class="line">//这个t就是上面创建出来present对象</div><div class="line">        Field[] fields = t.getClass().getDeclaredFields();</div><div class="line">        for (Field f : fields) &#123;</div><div class="line">    //遍历所有方法，寻找添加了BindV注解的变量</div><div class="line">            if (f.isAnnotationPresent(BindV.class)) &#123;</div><div class="line">                try &#123;</div><div class="line">    //对present对象中添加了BindV注解的变量赋值</div><div class="line">                    f.setAccessible(true);</div><div class="line">                    f.set(t, activity);</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>这样，一个p和v的绑定就完成了，当然这个只是两个对象的绑定。我们还需要看看两个Base类的实现，以及这个注解绑定何时调用，何时解绑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public abstract class BaseMvpActivity&lt;T extends BasePresent&gt; extends GestureBaseActivity implements BaseView &#123;</div><div class="line"></div><div class="line">    private List&lt;T&gt; presentList = new CopyOnWriteArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        ParasBindPAnnotation.parasBindPresent(this);</div><div class="line"></div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onCreate(savedInstanceState);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStart() &#123;</div><div class="line">        super.onStart();</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onStart();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResume() &#123;</div><div class="line">        super.onResume();</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onResume();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onNewIntent(Intent intent) &#123;</div><div class="line">        super.onNewIntent(intent);</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onNewIntent(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">        super.onSaveInstanceState(outState);</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onSaveInstance(outState);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onRestart() &#123;</div><div class="line">        super.onRestart();</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onRestart();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPause() &#123;</div><div class="line">        super.onPause();</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onPause();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onStop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        for (T present : presentList) &#123;</div><div class="line">            if (present != null) &#123;</div><div class="line">                present.onDestroy();</div><div class="line">                presentList.remove(present);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void addPresent(T t) &#123;</div><div class="line">        if (t != null) &#123;</div><div class="line">            presentList.add(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Context getCtx() &#123;</div><div class="line">        return this;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public &lt;T&gt; LifecycleTransformer&lt;T&gt; bindUntilEve() &#123;</div><div class="line">        return bindUntilEvent(ActivityEvent.DESTROY);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><br>从这个BaseMvpActivity类中，我们能够知道，它内部维持了一个present列表，这就是为什么它能够同时绑定多个的原因。ParasBindPAnnotation.parasBindPresent调用是在activity的oncreate方法中调用，也就是activity在onCreate方法中进行的p和v的绑定，绑定的同时会将这个present添加到presentList中，然后在activity的生命周期中，都会回调present的相应的生命周期。然后在这个activity的onDestory中，也就是即将销毁时会进行解绑，调用present的onDestory方法，并从列表中移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class BasePresent &#123;</div><div class="line"></div><div class="line">    protected BaseView mvpView;</div><div class="line"></div><div class="line">    public BasePresent() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void attachView(BaseView mvpView) &#123;</div><div class="line">        this.mvpView = mvpView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void detach() &#123;</div><div class="line">        this.mvpView = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onCreate(Bundle saveInstanceState) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onResume() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onNewIntent(Intent intent) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onPause() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onStart() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onStop() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onDestroy() &#123;</div><div class="line">        detach();</div><div class="line">        ParasBindVAnnotation.detachView(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void onRestart() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onSaveInstance(Bundle state) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void onRestoreSavedInstance(Bundle saveInstance) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><br>在这个BasePresent中，我们可以先看到attachView这个方法，这个方法是在paraseBindPAnatation中调用的，这个BaseMvp是一些通用的mvp需要的方法，也就是在BaseMvp已经实现好了的。然后在ondestory方法中，首先会执行detach方法，将这个mvpView置为null，然后通过注解移除自身对activity或者fragment的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void detachView(Object t) &#123;</div><div class="line">        Field[] fields = t.getClass().getDeclaredFields();</div><div class="line">        for (Field f : fields) &#123;</div><div class="line">    //对这个BindV的注解，做清空操作，即赋值为null</div><div class="line">            if (f.isAnnotationPresent(BindV.class)) &#123;</div><div class="line">                try &#123;</div><div class="line">                    f.setAccessible(true);</div><div class="line">                    f.set(t, null);</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>这样，整个mvp的绑定与解绑的流程就走完了。目前只支持fragment和activity的present绑定，后续还会添加上view的绑定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android中的各种框架&quot;&gt;&lt;a href=&quot;#android中的各种框架&quot; class=&quot;headerlink&quot; title=&quot;android中的各种框架&quot;&gt;&lt;/a&gt;android中的各种框架&lt;/h1&gt;&lt;p&gt;在主流的开发框架中，目前比较流行的框架有MVC，MV
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android启动优化</title>
    <link href="https://xjlhhz.com/2018/01/19/0119android%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://xjlhhz.com/2018/01/19/0119android启动优化/</id>
    <published>2018-01-19T05:14:00.000Z</published>
    <updated>2018-01-24T14:06:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="android-简单启动流程"><a href="#android-简单启动流程" class="headerlink" title="android 简单启动流程"></a>android 简单启动流程</h1><p>对于android的启动流程，有三种启动方式，分别冷启动，温启动和热启动。如果我们想要优化启动速度，我们需要先了解下这三种启动方式的不同区别。</p><h2 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h2><p>冷启动通常是app启动耗时最长的一种启动方式，因为它涉及了application的初始化。它是app从无到有的过程。一旦系统杀掉了app进程，那么下次点开桌面icon启动app的启动方式就是冷启动了。</p><h3 id="涉及到的启动过程"><a href="#涉及到的启动过程" class="headerlink" title="涉及到的启动过程"></a>涉及到的启动过程</h3><p>首先是app进程的创建过程</p><ul><li>加载并启动app文件</li><li>在app的启动过程中展示空白的加载页面</li><li>创建app进程</li></ul><p>然后是app的Activity的初始化过程</p><ul><li>创建app对象</li><li>启动app的主线程</li><li>创建第一个acitivty</li><li>inflate View</li><li>计算view的位置</li><li>在页面中绘制</li></ul><p>这些过程都是在android开发者文档有提到的，地址为- <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="external">https://developer.android.com/topic/performance/launch-time.html</a><br>其中有一张启动的过程图。<br><img src="http://onu21exz8.bkt.clouddn.com/app_launch_time.jpeg" alt=""></p><h4 id="application的启动"><a href="#application的启动" class="headerlink" title="application的启动"></a>application的启动</h4><p>当我们的application启动时，在系统进程第一次启动这个app时，也就是从无到有的创建过程时，将会出现一个空白的页面。在这个过程中，将会调用到application的oncreate方法，然后创建主线程，也就是我们所熟知的ui线程，通过它来创建我们的页面。</p><h4 id="activity的启动"><a href="#activity的启动" class="headerlink" title="activity的启动"></a>activity的启动</h4><p>acitivty的创建包括了下面几个过程：</p><ul><li>初始化参数</li><li>调用构造函数</li><li>回调生命周期方法，比如说oncreate方法，正常来说，oncreate方法是需要比较长的加载时间，因为它需要加载和inflate View，初始化对象。</li></ul><h2 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h2><p>在温启动中，系统将我们的页面置于后台，但是我们的应用仍然存在于内存中，在重新唤醒app时，我们不需要重复的进行对象初始化，layout映射。不过一旦我们内存不足，比如说回调了onTrimMemory，一些缓存的对象将会被回收，在下一次重启时将需要重新创建。温启动有一些表现与冷启动相似，系统进程将会有一个空白页面的时期，直到app恢复了被回收的页面。</p><h2 id="暖启动"><a href="#暖启动" class="headerlink" title="暖启动"></a>暖启动</h2><p>暖启动是一个时间比较短的时期，有下面几种场景将被认为是暖启动：</p><ul><li>用户将app置于后台，不过马上启动它，这个app将会继续运行，不过这个app将会重建退回后台时的acitivity栈顶的页面，并回调onCreate方法</li><li>系统将我们的app从内存中移除，然后用户重新启动app，这个app进程和activity需要重新创建，不过这个时候会存储一些被移除的信息，从onSaveInstance中恢复。</li></ul><h1 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h1><p>通过上述的3个启动方式，我们最优化的点就是app的冷启动过程，大部分app会接入众多的第三方库，并且这些第三方库都会要求放在app启动时做初始化，一旦application的onCreate的方法聚集了大量的初始化操作之后，整个app的启动将会变得缓慢，导致在整个启动页面的过程中先卡在了application的onCreate方法，这个时候，页面的显示如果不做任何的处理，将会是白屏状态，这种用户体验非常的不友好。所以首先要解决的就是application的onCreate方法启动慢的情况。然后对于我们第一activity页面的启动，也会做一些相关的初始化操作，对于activity来说，初始化不仅仅只是回调了onCreate方法里面的操作，而且还需要绘制View，这也是一个比较耗时的操作，所以我们也需要对这个过程做一个优化。</p><h2 id="消灭白屏"><a href="#消灭白屏" class="headerlink" title="消灭白屏"></a>消灭白屏</h2><p>在google开发者文旦中，它也推荐我们将app启动时的等待白屏替换为我们的开屏页面。所以这个优化点是我们必须要先实现。</p><h3 id="利用layer-list创建我们的启动页面"><a href="#利用layer-list创建我们的启动页面" class="headerlink" title="利用layer-list创建我们的启动页面"></a>利用layer-list创建我们的启动页面</h3><p>因为我们的启动页通常不只是一张图片，而是一个xml文件，而在指定等待页面的时候，只能指定一个drawable文件，而不能指定一个xml。所以，我们需要将xml的启动页转化成已drawable引用的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:opacity=&quot;opaque&quot;&gt;</div><div class="line">    &lt;item&gt;</div><div class="line">//设置整个页面的背景，为纯白</div><div class="line">        &lt;shape android:shape=&quot;rectangle&quot;&gt;</div><div class="line">            &lt;size</div><div class="line">                android:width=&quot;@dimen/screen_width&quot;</div><div class="line">                android:height=&quot;@dimen/screen_height&quot; /&gt;</div><div class="line">            &lt;solid android:color=&quot;@color/color_FFFFFF&quot; /&gt;</div><div class="line">        &lt;/shape&gt;</div><div class="line"></div><div class="line">    &lt;/item&gt;</div><div class="line">    &lt;item android:top=&quot;@dimen/dimens_200dp&quot;&gt;</div><div class="line">        &lt;!-- 中间的图片 --&gt;</div><div class="line">//设置距离顶部200dp的logo</div><div class="line">        &lt;bitmap</div><div class="line">            android:gravity=&quot;top|center_horizontal&quot;</div><div class="line">            android:scaleType=&quot;center&quot;</div><div class="line">            android:src=&quot;@drawable/ic_launch_logo&quot; /&gt;</div><div class="line">    &lt;/item&gt;</div><div class="line">    &lt;item android:bottom=&quot;@dimen/dimens_15dp&quot;&gt;</div><div class="line">        //设置距离底部15dp的图片</div><div class="line">        &lt;bitmap</div><div class="line">            android:gravity=&quot;bottom|center_horizontal&quot;</div><div class="line">            android:scaleType=&quot;center&quot;</div><div class="line">            android:src=&quot;@drawable/ic_copy_right&quot; /&gt;</div><div class="line">    &lt;/item&gt;</div><div class="line"></div><div class="line">&lt;/layer-list&gt;</div></pre></td></tr></table></figure><br>这样，我们的启动页的layer-list就成功了。对于layer-list来说，每一个item都不干扰，后面的item将会置于上面item顶部，和FrameLayout类似。。</p><h3 id="建立启动页相关的style"><a href="#建立启动页相关的style" class="headerlink" title="建立启动页相关的style"></a>建立启动页相关的style</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Appwelcome&quot; parent=&quot;Theme.Base&quot;&gt;</div><div class="line">        &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;false&lt;/item&gt; //等待页面非透明</div><div class="line">        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg_launcher&lt;/item&gt;//等待页背景，也就是上面写的启动页的layer-list</div><div class="line">        &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;//等待页全屏</div><div class="line">    &lt;/style&gt;</div></pre></td></tr></table></figure><h3 id="Manifest文件中指定style，Activity恢复style"><a href="#Manifest文件中指定style，Activity恢复style" class="headerlink" title="Manifest文件中指定style，Activity恢复style"></a>Manifest文件中指定style，Activity恢复style</h3><p>在manifest中，我们需要对第一个启动的activity指定我们设置的style，这个等待时的白屏，将会被我们这个style替换掉。当然，我们不能对application的节点设置，因为一旦我们对application节点设置这个style，影响的将会是内部的所有activity，我们只会在启动时用到，所以设置给第一个activity即可，通常都会是launchActivity。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;activity ...</div><div class="line">android:theme=&quot;@style/Appwelcome&quot; /&gt;</div></pre></td></tr></table></figure><p>然后在第一个activity的onCreate方法，调用的setContentView之前，调用下setTheme，设置为默认的style。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class LaunchActivity extends AppCompatActivity &#123;</div><div class="line">  @Override</div><div class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    // Make sure this is before calling super.onCreate</div><div class="line">    setTheme(R.style.Theme_MyApp);</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    // ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样，我们就会发现我们app启动时的白屏已经不存在了。</p><h2 id="application的初始化流程优化"><a href="#application的初始化流程优化" class="headerlink" title="application的初始化流程优化"></a>application的初始化流程优化</h2><p>对于application的初始化，无非就是延迟初始化和异步初始化，但是这些都需要针对于具体的业务来做处理，因为有些操作在application做初始化，而一进activity就需要使用了，这种时候需要保证application初始化完毕时这些操作也已经完成。在这里有个思路，对在application中异步初始化的类，都提供一个统一管理的类。来保证类的成功初始化。<br>如果是一启动就必须使用，比如说常用的imageLoad、网络类的初始化，那么只能尽可能的在这个类的初始化中只完成一些必要的事情，然后这些类的初始化还是在onCreate方法中执行。<br>如果是非必须的，但是优先级较高的，那么可以通过异步初始化，比如asyncTask使用。<br>如果是非必须的，而且优先级比较低的，那么可以通过延迟初始化，在需要使用的时候才进行初始化。</p><h2 id="Activity延迟初始化"><a href="#Activity延迟初始化" class="headerlink" title="Activity延迟初始化"></a>Activity延迟初始化</h2><p>如果在Activity的onCreate方法中做初始化，那么activity的UI绘制和初始化将会同时执行，这样，我们的初始化操作将会阻塞UI初始化。所以，这种时候我们应该将我们的操作放在UI绘制完毕之后做初始化。这里有个通用延迟初始化方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getWindow().getDecorView().post(new Runnable() &#123; </div><div class="line">...</div><div class="line">...</div><div class="line">...</div><div class="line">&#125;);</div></pre></td></tr></table></figure><br>通过getDecorView的post方法，将会将这个runnable post到这个Ui的消息队列最后面，直到UI的消息绘制完毕，才会获取包含这个runable的消息执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;android-简单启动流程&quot;&gt;&lt;a href=&quot;#android-简单启动流程&quot; class=&quot;headerlink&quot; title=&quot;android 简单启动流程&quot;&gt;&lt;/a&gt;android 简单启动流程&lt;/h1&gt;&lt;p&gt;对于android的启动流程，有三种启动方式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rxjava简单了解</title>
    <link href="https://xjlhhz.com/2018/01/11/0111rxJava%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <id>https://xjlhhz.com/2018/01/11/0111rxJava简单了解/</id>
    <published>2018-01-11T05:14:00.000Z</published>
    <updated>2018-01-13T04:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rxjava"><a href="#rxjava" class="headerlink" title="rxjava"></a>rxjava</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>  其实rxjava入门并没有想象中的难，常用的简单方法就几个。我们来看一个最简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</div><div class="line">                e.onNext(1);</div><div class="line">                e.onComplete();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(Integer integer) throws Exception &#123;</div><div class="line">                LogUtil.i(&quot;XJL&quot;, &quot;1&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure><br>这个例子就是利用create创建出来一个被观察者，这个被观察者仅仅只是发送了个数字便结束了，我们需要注意的是，在我们创建出来这个被观察者时，如果没有明确指定一创建就执行的话，它并不会马上执行，只有在subcribe调用时，也就是有观察者进行订阅时才会执行。其中，subscribeOn用来指定被观察者的执行线程，它对前面的被观察者起作用。而observeOn方法用来指定观察者的执行线程，它对后面的subscribe方法起作用。subscribe用来设置我们的观察者，也就是我们对于被观察者发射的数据的处理方法。<br>当然我们也能够通过rxjava提供的更为便捷的创建方法创建Observable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(1, 2, 3).subscribeOn(Schedulers.io())</div><div class="line">              .observeOn(AndroidSchedulers.mainThread())</div><div class="line">              .subscribe(new Consumer&lt;Integer&gt;() &#123;</div><div class="line">                  @Override</div><div class="line">                  public void accept(Integer integer) throws Exception &#123;</div><div class="line">                      Log.i(&quot;XJL&quot;, &quot;=====&gt;&quot; + integer );     </div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure><br>这个just就是rxjava提供的遍历函数，它会将我们给定的参数按序发送给下游，类似这样的函数还有很多，这个就是rxjava的简单使用。</p><h2 id="rxjava结合retrofit的使用"><a href="#rxjava结合retrofit的使用" class="headerlink" title="rxjava结合retrofit的使用"></a>rxjava结合retrofit的使用</h2><p>retrofit作为现在android开发者的利器，当然也和rxjava能够互通有无。下面我们来看看retrofit如何结合rxjava来使用。</p><h3 id="retrofit配置"><a href="#retrofit配置" class="headerlink" title="retrofit配置"></a>retrofit配置</h3><p>首先我们需要在项目中的build.gradle中引入rxjava依赖，和jakewharton提供的rxjava2和retrofit完美结合的插件。因为retrofit现在还没有完全兼容刚升级不久的rxjava2。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">  compile &apos;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&apos;</div><div class="line">  compile &apos;android.arch.persistence.room:rxjava2:1.0.0&apos;</div><div class="line">...</div></pre></td></tr></table></figure><br>然后我们需要在构造retrofit实体的时候，添加rxjavaAdapter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">return new Retrofit.Builder()</div><div class="line">                .baseUrl(baseUrl)</div><div class="line">                .client(createOkHttpClient())</div><div class="line">                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">                .addConverterFactory(GsonConverterFactory.create(createGsonConverter()))</div><div class="line">                .build();</div></pre></td></tr></table></figure><br>这个RxJava2CallAdapterFactory就是com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0这个依赖库中所提供的插件。这样，我们最基础的配置就完成了。<br>对于我们的Interface，最初的使用是返回的OkHttp所需的Call<t>,现在引入了rxjava2，我们可以将返回类型替换为Observable<t>,对于这个Observable的生成是在网络返回时，在adapterFactory通过我们前面配置的rxjavaAdapter来进行转化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//原始的retrofit请求</div><div class="line"> @GET(&quot;commonUrl&quot;)</div><div class="line"> Call&lt;T&gt; getT();</div><div class="line"></div><div class="line">//Rxjava的retrofit请求</div><div class="line">@GET(&quot;commonUrl&quot;)</div><div class="line"> Obserable&lt;T&gt; getT();</div><div class="line"></div></pre></td></tr></table></figure><br>然后在最外层的调用可以直接通过获取到这个Obserable进行相应的处理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Client.getT().subscribeOn(Schedulers.io())..observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer&lt;T&gt;() &#123;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onSubscribe(Disposable d) &#123;</div><div class="line">               </div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onNext(T o) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onError(Throwable e) &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void onComplete() &#123;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;);</div></pre></td></tr></table></figure><br>其中onSubscribe回调是在我们执行了subscribe方法之后的回调，onNext是成功返回的回调，onError是网络错误的回调，onComplete是整个流程结束后的返回。</t></t></p><h2 id="rxjava订阅流程解析"><a href="#rxjava订阅流程解析" class="headerlink" title="rxjava订阅流程解析"></a>rxjava订阅流程解析</h2><h3 id="Observable-create方法"><a href="#Observable-create方法" class="headerlink" title="Observable.create方法"></a>Observable.create方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123;</div><div class="line">       //将会返回一个ObservableCreate，封装了原始的Observable，</div><div class="line">       return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个create方法接收一个ObservableOnSubscribe参数，这个ObservableOnSubscribe提供了我们需要的常规操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface ObservableOnSubscribe&lt;T&gt; &#123;</div><div class="line">    //通过subscribe的参数ObservableEmitter来发送消息</div><div class="line">    void subscribe(@NonNull ObservableEmitter&lt;T&gt; e) throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>ObservableOnSubscribe是一个接口，需要实现它的subscribe方法，我们在被观察者里面做的操作都是在这个方法里面做处理的，包括了onNext方法，onError，和onComplete的发射。所以，这个方法需要接收一个发射器的参数，我们通过这个发射器来发射数据。这个发射器就是Emitter，ObservableEmitter继承于Emitter，并且提供了几个需要的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//Emitter</div><div class="line">public interface Emitter&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    //onNext事件，能够有多个</div><div class="line">    void onNext(@NonNull T value);</div><div class="line"></div><div class="line">    //onError事件，仅能有一个，一旦有这个事件，将不会再收到onNext或者onComplete事件</div><div class="line">    void onError(@NonNull Throwable error);</div><div class="line"></div><div class="line">    //onComplete事件，仅能有一个，一旦有这个事件，将不会再收到onNext或者onError事件</div><div class="line">    void onComplete();</div><div class="line">&#125;</div><div class="line"></div><div class="line">//ObservableEmitter</div><div class="line">public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123;</div><div class="line"></div><div class="line">   //这个发射器的使能开关</div><div class="line">    void setDisposable(@Nullable Disposable d);</div><div class="line"></div><div class="line">   //这个发射器是否可以取消</div><div class="line">    void setCancellable(@Nullable Cancellable c);</div><div class="line"></div><div class="line">   //停止这个序列</div><div class="line">    boolean isDisposed();</div><div class="line"></div><div class="line">    //序列化这个发射器</div><div class="line">    @NonNull</div><div class="line">    ObservableEmitter&lt;T&gt; serialize();</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>对于rxjava的执行，每次执行了一个操作符，都会对原始的Observable做一次封装。比如说create方法，传入ObservableOnSubscribe，经过封装之后，返回的是ObservableCreate类。对于每一个封装类，都需要实现相应的调用方法，也就是当被订阅时需要实现的方法subscribeActual(),这个方法是在Observable中定义的抽象方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123;</div><div class="line">       this.source = source;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">       CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</div><div class="line">       //回调observer的onSubscribe方法</div><div class="line">observer.onSubscribe(parent);</div><div class="line"></div><div class="line">       try &#123;</div><div class="line">    //原始observer订阅被观察者</div><div class="line">           source.subscribe(parent);</div><div class="line">       &#125; catch (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           parent.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在这个subscribeActual方法中，将会创建出CreateEmitter类，这个类是用来发射我们定义的发射数据的，然后将被观察者和观察者建立联系。</p><h3 id="Observable-subscribeOn"><a href="#Observable-subscribeOn" class="headerlink" title="Observable.subscribeOn"></a>Observable.subscribeOn</h3><p>对于rxjava中的线程切换，那是非常方便的，subscribeOn就是其中的一个线程切换的方法，subscribeOn是用来指定被观察者执行的线程的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123;</div><div class="line">       return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>这个方法同样的会返回一个关于线程切换的封装类ObservableSubscribeOn。首先，我们先来了解一下rxjava常用的线程Scheduler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static &#123;</div><div class="line">        SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask()); //指定单个调度线程</div><div class="line"></div><div class="line">        COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask()); //主要用于复杂计算</div><div class="line"></div><div class="line">        IO = RxJavaPlugins.initIoScheduler(new IOTask()); //主要用于网络请求或者IO操作</div><div class="line"></div><div class="line">        TRAMPOLINE = TrampolineScheduler.instance();</div><div class="line"></div><div class="line">        NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask()); //创建出一个新的线程</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>其中最经常用到的就是IO线程了，网络请求推荐使用IO线程，本地数据操作推荐使用IO线程。假如我们对同一个Observable进行多次切换线程，起作用的只有第一个切换的线程。这个的原理就要看看ObservableSubscribeOn的实现了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123;</div><div class="line">        super(source);</div><div class="line">        this.scheduler = scheduler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void subscribeActual(final Observer&lt;? super T&gt; s) &#123;</div><div class="line">        //创建出SubscribeOnObserver</div><div class="line">        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);</div><div class="line">        </div><div class="line">//回调onSubscribe方法</div><div class="line">        s.onSubscribe(parent);</div><div class="line"></div><div class="line">//设置Disposable</div><div class="line">        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>上面的几步最重要的就是scheduler.scheduleDirect(new SubscribeTask(parent))，这个方法首先会创建SubscribeTask，这个其实就是就是一个runnable，在run方法中进行订阅操作，订阅操作执行的就是我们定义发射方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final class SubscribeTask implements Runnable &#123;</div><div class="line">       private final SubscribeOnObserver&lt;T&gt; parent;</div><div class="line"></div><div class="line">       SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</div><div class="line">           this.parent = parent;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       @Override</div><div class="line">       public void run() &#123;</div><div class="line">           source.subscribe(parent);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>一旦我们执行了scheduleDirect方法之后，就会马上执行SubscribeTask的run方法。那么一旦我们切换了多个被观察者的执行线程，比如下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable.interval(1000, TimeUnit.MICROSECONDS)</div><div class="line">                .subscribeOn(Schedulers.io()).subscribeOn(Schedulers.newThread())</div><div class="line">                .subscribeOn(Schedulers.computation());</div></pre></td></tr></table></figure><br>首先会经过第一层封装，在io线程的SubscribeTask中执行原始的Observable定义的发射方法。然后经过第二层封装，在newThread中执行第一层封装后的方法，最后经过computation的封装，在computation指定的线程中执行第二层封装的方法，由此可见，最后执行原始Observable的线程还是在第一个指定的线程中执行。再举个更简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">new Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        new Thread &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                //执行原始被观察者的发射方法</div><div class="line">...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>不管外部包了多少层，最终执行原始被观察者的发射方法的线程也都是在最内部的线程执行的。</p><h3 id="Obserable-observeOn"><a href="#Obserable-observeOn" class="headerlink" title="Obserable.observeOn"></a>Obserable.observeOn</h3><p>rxjava中，用observeOn指定后面的观察者的执行线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123;</div><div class="line">//bufferSize为默认的缓存区大小，为BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128))</div><div class="line">        return observeOn(scheduler, false, bufferSize());</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line"> public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123;</div><div class="line">        return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>执行了observeOn方法时，会将先前的Observable封装成ObservableObserveOn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) &#123;</div><div class="line">       super(source);</div><div class="line">       this.scheduler = scheduler;</div><div class="line">       this.delayError = delayError;</div><div class="line">       this.bufferSize = bufferSize;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">   protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">       if (scheduler instanceof TrampolineScheduler) &#123;</div><div class="line">           source.subscribe(observer);</div><div class="line">       &#125; else &#123;</div><div class="line">    //创建出一个Work线程，这个是当前执行线程的事件Looper，每一个需要执行的操作都需要在这个Looper中排队，等待执行。</div><div class="line">           Scheduler.Worker w = scheduler.createWorker();</div><div class="line">    //订阅ObserveOnObserver</div><div class="line">           source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在ObserveOnServer方法中，将会维护这个looper，对于每一个emitter发射出来的事件，都会将其置于looper中执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    @Override</div><div class="line">        public void onNext(T t) &#123;</div><div class="line">    ...</div><div class="line">            schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onError(Throwable t) &#123;</div><div class="line">           ... </div><div class="line">   schedule();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onComplete() &#123;</div><div class="line">          ...  </div><div class="line">  schedule();</div><div class="line">        &#125;</div><div class="line">=====&gt;</div><div class="line"> void schedule() &#123;</div><div class="line">            if (getAndIncrement() == 0) &#123;</div><div class="line">                worker.schedule(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>对于rxjava设置的observeOn方法，只有最后一个会生效，这个原因是因为每执行一次，都会将其放置在工作Looper执行。比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.interval(1000, TimeUnit.MICROSECONDS)</div><div class="line">                .subscribeOn(Schedulers.io()).subscribeOn(Schedulers.newThread())</div><div class="line">                .subscribeOn(Schedulers.computation())</div><div class="line">                .observeOn(Schedulers.computation())</div><div class="line">                .observeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">.subscribe(...);</div></pre></td></tr></table></figure><br>首先会将原始的Observable放在computation线程中执行，io线程封装computation线程，最后主线程封装io线程。因为observeOn对后面的obsever起作用，所以最后subscribe执行的线程将会是最外层的线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> new Thread &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        new Thread &#123;</div><div class="line">             @Override</div><div class="line">             public void run() &#123;</div><div class="line">                //执行原始被观察者的发射方法</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">     //执行observer的方法</div><div class="line">     ...</div><div class="line">    &#125;</div><div class="line">&#125;  </div></pre></td></tr></table></figure><br>其实subscribe和observeOn比较类似，只是两个起作用的区域不一样，subscribe对前面起作用，所以最后执行的线程是最内层的。observeOn对后面起作用，所以最后执行到的线程是在最外层的线程。</p><h3 id="Observable-subscribe"><a href="#Observable-subscribe" class="headerlink" title="Observable.subscribe"></a>Observable.subscribe</h3><p>这个是rxjava订阅的入口，如果未指明创建立即执行的话，默认是在订阅方法执行时执行。这个方法接收一个Observer，也就是观察者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext) &#123;</div><div class="line">        return subscribe(onNext, Functions.ON_ERROR_MISSING, Functions.EMPTY_ACTION, Functions.emptyConsumer());</div><div class="line">    &#125;</div><div class="line">=====》</div><div class="line">public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,</div><div class="line">            Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) &#123;</div><div class="line">//封装程lambdaObserver</div><div class="line">        LambdaObserver&lt;T&gt; ls = new LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe);</div><div class="line">//订阅入口</div><div class="line">        subscribe(ls);</div><div class="line"></div><div class="line">        return ls;</div><div class="line">    &#125;</div><div class="line">=====》subscribe</div><div class="line"> public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    ...</div><div class="line">            subscribeActual(observer);</div><div class="line">    ...  </div><div class="line">&#125;</div></pre></td></tr></table></figure><br>对于这个subscribeActual我们应该很熟悉，对于每一个Observable都需要实现这个方法。这个方法是在Observable定义的抽象方法。这样，就会调用到特定Observable的subscribeActual，逐层调用，最后调用到原始的Observable的emitter方法，发射数据。</p><h2 id="rxjava常用的操作符"><a href="#rxjava常用的操作符" class="headerlink" title="rxjava常用的操作符"></a>rxjava常用的操作符</h2><p>比较常用的有merge、zip、concat、takeUntil、concat，详情可见官方的中文使用文档<a href="https://github.com/mcxiaoke/RxDocs" target="_blank" rel="external">https://github.com/mcxiaoke/RxDocs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rxjava&quot;&gt;&lt;a href=&quot;#rxjava&quot; class=&quot;headerlink&quot; title=&quot;rxjava&quot;&gt;&lt;/a&gt;rxjava&lt;/h1&gt;&lt;h2 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>intentService实现原理</title>
    <link href="https://xjlhhz.com/2017/09/13/0914IntentService%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2017/09/13/0914IntentService使用/</id>
    <published>2017-09-13T05:14:00.000Z</published>
    <updated>2017-09-14T09:59:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IntentService用法"><a href="#IntentService用法" class="headerlink" title="IntentService用法"></a>IntentService用法</h1><p>其实IntentService被我们熟知的就是它有一个自己的工作线程，当需要执行的任务完成之后，工作线程会自动关闭，不需要我们做额外的处理。对于我们使用，只需要继承IntentService，实现相应的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class InitOperationService extends IntentService &#123;</div><div class="line"></div><div class="line">    //必须有一个空的构造函数，并且在内部调用super的时候指定handleThrad的Name</div><div class="line">    public InitOperationService() &#123;</div><div class="line">        super(&quot;initService&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //在onHandleIntent执行相应的处理操作</div><div class="line">    @Override</div><div class="line">    protected void onHandleIntent(@Nullable Intent intent) &#123;</div><div class="line">        LogUtil.i(&quot;InitOperationService&quot;, &quot;open InitOperationService, start init operation......&quot;);</div><div class="line">        initThirdService(KKMHApp.getInstance());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        LogUtil.i(&quot;InitOperationService&quot;, &quot;init operation complete, destroy InitOperationService......&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initThirdService(Context context) &#123;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>然后在Manifest里面添加指定Service。调用时直接利用Intent携带该Service参数，使用startService方法开启。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(this, InitOperationService.class);</div><div class="line">        startService(intent);</div></pre></td></tr></table></figure></p><h1 id="IntentService实现原理"><a href="#IntentService实现原理" class="headerlink" title="IntentService实现原理"></a>IntentService实现原理</h1><p>简单的来说，IntentService是一个<br>在我们构造IntentService时，需要为IntentService传入一个name作为参数，这个参数是作为内部的HandleThread的名称来使用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public IntentService(String name) &#123;</div><div class="line">       super();</div><div class="line">       mName = name;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在我们调用startService时，开始进入service生命周期函数。Service有两种初始化的生命周期。对于IntentService的使用方式，生命周期如下：onCreate-&gt;onStartCommand-&gt;onStopService-&gt;onDestory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void onCreate() &#123;</div><div class="line"></div><div class="line">       super.onCreate();</div><div class="line">//创建出handler线程，线程名称为构造函数指定的名称</div><div class="line">       HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);</div><div class="line">       //开启线程</div><div class="line">thread.start();</div><div class="line"></div><div class="line">       //获取handler线程的looper，将这个looper设置给ServiceHandler，这样这个handler就能读取这个looper的消息。</div><div class="line">       mServiceLooper = thread.getLooper();</div><div class="line">       mServiceHandler = new ServiceHandler(mServiceLooper);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>这个工作线程是intentService独有的，主要是用这个线程处理我们要执行操作，在线程开启时，将会在开启looper，也就是looper.loop方法执行循环读取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void run() &#123;</div><div class="line">       mTid = Process.myTid();</div><div class="line">       Looper.prepare();</div><div class="line">       synchronized (this) &#123;</div><div class="line">           mLooper = Looper.myLooper();</div><div class="line">           notifyAll();</div><div class="line">       &#125;</div><div class="line">       Process.setThreadPriority(mPriority);</div><div class="line">       onLooperPrepared();</div><div class="line">       Looper.loop();</div><div class="line">       mTid = -1;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>ServiceHandler处理将会处理从handlerThread收到的消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private final class ServiceHandler extends Handler &#123;</div><div class="line">      public ServiceHandler(Looper looper) &#123;</div><div class="line">          super(looper);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public void handleMessage(Message msg) &#123;</div><div class="line">   //当收到消息时，会调用OnHandleIntent方法执行。</div><div class="line">          onHandleIntent((Intent)msg.obj);</div><div class="line">       //处理完毕之后，关闭自身线程</div><div class="line">          stopSelf(msg.arg1);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><br>接下来进入生命周期的onStartCommand方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123;</div><div class="line">      onStart(intent, startId);</div><div class="line">      return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><br>在这个方法中，intentService会将参数传递onStart方法，在onStart方法去执行相关操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void onStart(@Nullable Intent intent, int startId) &#123;</div><div class="line">       Message msg = mServiceHandler.obtainMessage();</div><div class="line">       msg.arg1 = startId;</div><div class="line">       msg.obj = intent;</div><div class="line">       mServiceHandler.sendMessage(msg);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在onStart方法中，封装好message消息，然后利用handler将待处理的消息post到工作线程中。最后在serviceHandler的handleMessage方法执行onHandleIntent去执行。</p><h1 id="intentService流程"><a href="#intentService流程" class="headerlink" title="intentService流程"></a>intentService流程</h1><p>startService -&gt; onCreate(创建工作线程和handler) -&gt; onStartCommand -&gt; onStart(将intent和消息post到工作线程的handler中) -&gt; onHandleIntent(执行service中相应的操作) -&gt; stopSelf(关闭线程) -&gt; onDestory</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IntentService用法&quot;&gt;&lt;a href=&quot;#IntentService用法&quot; class=&quot;headerlink&quot; title=&quot;IntentService用法&quot;&gt;&lt;/a&gt;IntentService用法&lt;/h1&gt;&lt;p&gt;其实IntentService被我们
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微信tinker接入尝试详解</title>
    <link href="https://xjlhhz.com/2017/09/03/0903%E5%BE%AE%E4%BF%A1Tinker%E5%B0%9D%E8%AF%95/"/>
    <id>https://xjlhhz.com/2017/09/03/0903微信Tinker尝试/</id>
    <published>2017-09-03T05:14:00.000Z</published>
    <updated>2017-09-10T05:39:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>#tinker接入过程<br>其实tinker接入对于一些第三方sdk接入来说算是一个比较复杂了。但是照着tinker团队提供的文档去实现，还是一件比较轻松的事情。</p><h2 id="gradle修改"><a href="#gradle修改" class="headerlink" title="gradle修改"></a>gradle修改</h2><h3 id="gradle引入依赖修改"><a href="#gradle引入依赖修改" class="headerlink" title="gradle引入依赖修改"></a>gradle引入依赖修改</h3><p>通过gradle的方式引入tinker是最简单不过的了。首先通过在项目的根目录的build.gradle中添加依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath (&apos;com.tencent.tinker:tinker-patch-gradle-plugin:1.8.1&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>然后在app下的build.gradle也添加依赖和apply。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    //optional, help to generate the final application </div><div class="line">    provided(&apos;com.tencent.tinker:tinker-android-anno:1.8.1&apos;)</div><div class="line">    //tinker&apos;s main Android lib</div><div class="line">    compile(&apos;com.tencent.tinker:tinker-android-lib:1.8.1&apos;)</div><div class="line">&#125;</div><div class="line">...</div><div class="line">...</div><div class="line">apply plugin: &apos;com.tencent.tinker.patch&apos;</div></pre></td></tr></table></figure><br>这样，就在项目中引入了tinker了。</p><h3 id="gradle添加生成patch文件的task任务"><a href="#gradle添加生成patch文件的task任务" class="headerlink" title="gradle添加生成patch文件的task任务"></a>gradle添加生成patch文件的task任务</h3><p>这里直接参照tinker给的example来阅读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div></pre></td><td class="code"><pre><div class="line">//为了保证每一个需要打patch的版本不重复，tinker推荐每次打包生成的sha值都从git上拉取最新的提交。</div><div class="line">def gitSha() &#123;</div><div class="line">    try &#123;</div><div class="line">        String gitRev = &apos;git rev-parse --short HEAD&apos;.execute(null, project.rootDir).text.trim()</div><div class="line">        if (gitRev == null) &#123;</div><div class="line">            throw new GradleException(&quot;can&apos;t get git rev, you should add git to system path or just input test value, such as &apos;testTinkerId&apos;&quot;)</div><div class="line">        &#125;</div><div class="line">        return gitRev</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new GradleException(&quot;can&apos;t get git rev, you should add git to system path or just input test value, such as &apos;testTinkerId&apos;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//我们需要打开multiDexEnable开关。</div><div class="line">multiDexEnabled true</div><div class="line">        buildConfigField &quot;String&quot;, &quot;TINKER_ID&quot;, &quot;\&quot;$&#123;getTinkerIdValue()&#125;\&quot;&quot;</div><div class="line">        buildConfigField &quot;String&quot;, &quot;PLATFORM&quot;,  &quot;\&quot;all\&quot;&quot;</div><div class="line">    &#125;</div><div class="line">   ....</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义生成的apk文件夹，buildDir就是我们项目中的output文件夹。</div><div class="line">def bakPath = file(&quot;$&#123;buildDir&#125;/bakApk/&quot;)</div><div class="line"></div><div class="line">//tinker相关的配置</div><div class="line">ext &#123;</div><div class="line">    //启用tinker</div><div class="line">    tinkerEnabled = true</div><div class="line">    tinkerOldApkPath = &quot;$&#123;bakPath&#125;/app-debug-1018-17-32-47.apk&quot;</div><div class="line">    tinkerApplyMappingPath = &quot;$&#123;bakPath&#125;/app-debug-1018-17-32-47-mapping.txt&quot;</div><div class="line">    tinkerApplyResourcePath = &quot;$&#123;bakPath&#125;/app-debug-1018-17-32-47-R.txt&quot;</div><div class="line">    tinkerBuildFlavorDirectory = &quot;$&#123;bakPath&#125;/app-1018-17-32-47&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">def getOldApkPath() &#123;</div><div class="line">    return hasProperty(&quot;OLD_APK&quot;) ? OLD_APK : ext.tinkerOldApkPath</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getApplyMappingPath() &#123;</div><div class="line">    return hasProperty(&quot;APPLY_MAPPING&quot;) ? APPLY_MAPPING : ext.tinkerApplyMappingPath</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getApplyResourceMappingPath() &#123;</div><div class="line">    return hasProperty(&quot;APPLY_RESOURCE&quot;) ? APPLY_RESOURCE : ext.tinkerApplyResourcePath</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getTinkerIdValue() &#123;</div><div class="line">    return hasProperty(&quot;TINKER_ID&quot;) ? TINKER_ID : gitSha()</div><div class="line">&#125;</div><div class="line"></div><div class="line">def buildWithTinker() &#123;</div><div class="line">    return hasProperty(&quot;TINKER_ENABLE&quot;) ? TINKER_ENABLE : ext.tinkerEnabled</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getTinkerBuildFlavorDirectory() &#123;</div><div class="line">    return ext.tinkerBuildFlavorDirectory</div><div class="line">&#125;</div><div class="line"></div><div class="line">//tinker相关操作</div><div class="line">if (buildWithTinker()) &#123;</div><div class="line">    apply plugin: &apos;com.tencent.tinker.patch&apos;</div><div class="line"></div><div class="line">    tinkerPatch &#123;</div><div class="line">        //指定oldApk地址，这个apk地址将会与新apk做对比生成差异化的dex包</div><div class="line">oldApk = &quot;/Users/xie/AndroidProject/tinker/tinker-sample-android/app/build/bakApk/app-debug-0522-10-24-41.apk&quot;</div><div class="line">        //是否忽略部分警告</div><div class="line">        ignoreWarning = true</div><div class="line">//patch文件是否需要添加签名</div><div class="line">        useSign = true</div><div class="line"></div><div class="line">        //是否开启tinker</div><div class="line">        tinkerEnable = buildWithTinker()</div><div class="line"></div><div class="line">        buildConfig &#123;</div><div class="line">            //如果我们利用tinkerpatch生成apk，那么我们最好能够利用old apk的mapping file</div><div class="line">            applyMapping = getApplyMappingPath()</div><div class="line">            applyResourceMapping = getApplyResourceMappingPath()</div><div class="line">    //获取tinkerId，为了保证效率，并不会对apk进行md5校验，这里会对apk做一个独特的id用于标识。</div><div class="line">            tinkerId = getTinkerIdValue()</div><div class="line">    //打开这个开关将会降低dex文件的大小。</div><div class="line">            keepDexApply = false</div><div class="line"></div><div class="line">            //当开启了这个开关之后，patch info的文件将会包含所有的diff文件。</div><div class="line">            isProtectedApp = false</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        dex &#123;</div><div class="line">    //支持的dex文件格式，可以为raw或者jar</div><div class="line">            dexMode = &quot;jar&quot;</div><div class="line">    //apk中的dex期待的格式</div><div class="line">            pattern = [&quot;classes*.dex&quot;,</div><div class="line">                       &quot;assets/secondary-dex-?.jar&quot;]</div><div class="line">    //这个非常重要，通过class不会在patch文件中改变，因此他们会从patch的dex文件中移除</div><div class="line">            loader = [</div><div class="line">                      &quot;tinker.sample.android.app.BaseBuildInfo&quot;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lib &#123;</div><div class="line">    //tinkerpatch支持的lib文件格式</div><div class="line">            pattern = [&quot;lib/*/*.so&quot;]</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        res &#123;</div><div class="line">    //项目中所有的资源文件，只有指定了之后，才会在新apk中生成</div><div class="line">            pattern = [&quot;res/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]</div><div class="line">            ignoreChange = [&quot;assets/sample_meta.txt&quot;]</div><div class="line">            largeModSize = 100</div><div class="line">        &#125;</div><div class="line">//我们生成的patch文件为7zip格式</div><div class="line">sevenZip &#123;</div><div class="line">           zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;String&gt; flavors = new ArrayList&lt;&gt;();</div><div class="line">    project.android.productFlavors.each &#123;flavor -&gt;</div><div class="line">        flavors.add(flavor.name)</div><div class="line">    &#125;</div><div class="line">    //生成的apk文件添加date后缀来标识</div><div class="line">    boolean hasFlavors = flavors.size() &gt; 0</div><div class="line">    def date = new Date().format(&quot;MMdd-HH-mm-ss&quot;)</div><div class="line"></div><div class="line">    android.applicationVariants.all &#123; variant -&gt;</div><div class="line">        def taskName = variant.name</div><div class="line">//在这里定义了打包任务</div><div class="line">        tasks.all &#123;</div><div class="line">    //如果打包生成的文件与这个任务名称一致，那么需要做额外的处理</div><div class="line">            if (&quot;assemble$&#123;taskName.capitalize()&#125;&quot;.equalsIgnoreCase(it.name)) &#123;</div><div class="line"></div><div class="line">                it.doLast &#123;</div><div class="line">                    copy &#123;</div><div class="line">                        def fileNamePrefix = &quot;$&#123;project.name&#125;-$&#123;variant.baseName&#125;&quot;</div><div class="line">                        def newFileNamePrefix = hasFlavors ? &quot;$&#123;fileNamePrefix&#125;&quot; : &quot;$&#123;fileNamePrefix&#125;-$&#123;date&#125;&quot;</div><div class="line">//将生成的文件移动到bakapk下</div><div class="line">                        def destPath = hasFlavors ? file(&quot;$&#123;bakPath&#125;/$&#123;project.name&#125;-$&#123;date&#125;/$&#123;variant.flavorName&#125;&quot;) : bakPath</div><div class="line">                        from variant.outputs.outputFile</div><div class="line">                        into destPath</div><div class="line">                        rename &#123; String fileName -&gt;</div><div class="line">    //重命名</div><div class="line">                            fileName.replace(&quot;$&#123;fileNamePrefix&#125;.apk&quot;, &quot;$&#123;newFileNamePrefix&#125;.apk&quot;)</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        from &quot;$&#123;buildDir&#125;/outputs/mapping/$&#123;variant.dirName&#125;/mapping.txt&quot;</div><div class="line">                        into destPath</div><div class="line">                        rename &#123; String fileName -&gt;</div><div class="line">                            fileName.replace(&quot;mapping.txt&quot;, &quot;$&#123;newFileNamePrefix&#125;-mapping.txt&quot;)</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        from &quot;$&#123;buildDir&#125;/intermediates/symbols/$&#123;variant.dirName&#125;/R.txt&quot;</div><div class="line">                        into destPath</div><div class="line">                        rename &#123; String fileName -&gt;</div><div class="line">                            fileName.replace(&quot;R.txt&quot;, &quot;$&#123;newFileNamePrefix&#125;-R.txt&quot;)</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //在打包任务执行完成之后，</div><div class="line">    project.afterEvaluate &#123;</div><div class="line">//如果这个打包包含渠道，那么对于所有渠道生成执行patch更新。</div><div class="line">        if (hasFlavors) &#123;</div><div class="line">    //对release包进行patch生成</div><div class="line">            task(tinkerPatchAllFlavorRelease) &#123;</div><div class="line">                group = &apos;tinker&apos;</div><div class="line">//获取oldApk文件</div><div class="line">                def originOldPath = getTinkerBuildFlavorDirectory()</div><div class="line">                for (String flavor : flavors) &#123;</div><div class="line">    //执行前面定义的tinkerPatch任务</div><div class="line">                    def tinkerTask = tasks.getByName(&quot;tinkerPatch$&#123;flavor.capitalize()&#125;Release&quot;)</div><div class="line">                    dependsOn tinkerTask</div><div class="line">                    def preAssembleTask = tasks.getByName(&quot;process$&#123;flavor.capitalize()&#125;ReleaseManifest&quot;)</div><div class="line">                    preAssembleTask.doFirst &#123;</div><div class="line">                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)</div><div class="line">                        project.tinkerPatch.oldApk = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-release.apk&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-release-mapping.txt&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyResourceMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-release-R.txt&quot;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            task(tinkerPatchAllFlavorDebug) &#123;</div><div class="line">                group = &apos;tinker&apos;</div><div class="line">                def originOldPath = getTinkerBuildFlavorDirectory()</div><div class="line">                for (String flavor : flavors) &#123;</div><div class="line">                    def tinkerTask = tasks.getByName(&quot;tinkerPatch$&#123;flavor.capitalize()&#125;Debug&quot;)</div><div class="line">                    dependsOn tinkerTask</div><div class="line">                    def preAssembleTask = tasks.getByName(&quot;process$&#123;flavor.capitalize()&#125;DebugManifest&quot;)</div><div class="line">                    preAssembleTask.doFirst &#123;</div><div class="line">                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)</div><div class="line">                        project.tinkerPatch.oldApk = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-debug.apk&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-debug-mapping.txt&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyResourceMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-debug-R.txt&quot;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p><h2 id="Application文件修改"><a href="#Application文件修改" class="headerlink" title="Application文件修改"></a>Application文件修改</h2><p>一旦我们接入了application，那么将会我们application文件将会以另外一种形态存在，DefaultApplicationLike。<br>下面也是官方文档中给的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//以注解的方式生成主次相应的application到DefaultApplicationLike中</div><div class="line">@SuppressWarnings(&quot;unused&quot;)</div><div class="line">@DefaultLifeCycle(application = &quot;tinker.sample.android.app.SampleApplication&quot;,</div><div class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</div><div class="line">                  loadVerifyFlag = false)</div><div class="line">public class SampleApplicationLike extends DefaultApplicationLike &#123;</div><div class="line">    private static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;</div><div class="line"></div><div class="line">    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</div><div class="line">                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</div><div class="line">        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * install multiDex before install tinker</div><div class="line">     * so we don&apos;t need to put the tinker lib classes in the main dex</div><div class="line">     *</div><div class="line">     * @param base</div><div class="line">     */</div><div class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class="line">    @Override</div><div class="line">    public void onBaseContextAttached(Context base) &#123;</div><div class="line">        super.onBaseContextAttached(base);</div><div class="line">        //you must install multiDex whatever tinker is installed!</div><div class="line">     </div><div class="line">        MultiDex.install(base);</div><div class="line"></div><div class="line">        SampleApplicationContext.application = getApplication();</div><div class="line">        SampleApplicationContext.context = getApplication();</div><div class="line"> </div><div class="line">       //对tinkerManager设置相应的ApplicationLike</div><div class="line">       TinkerManager.setTinkerApplicationLike(this);</div><div class="line"></div><div class="line">        TinkerManager.initFastCrashProtect();</div><div class="line">        //开启更新重试，必须在install调用前设置</div><div class="line">        TinkerManager.setUpgradeRetryEnable(true);</div><div class="line"></div><div class="line">        //optional set logIml, or you can use default debug log</div><div class="line">        TinkerInstaller.setLogIml(new MyLogImp());</div><div class="line"></div><div class="line">        //tinkerManager的install必须在multiDex之后执行</div><div class="line">        //初始化tinker</div><div class="line">        TinkerManager.installTinker(this);</div><div class="line">        Tinker tinker = Tinker.with(getApplication());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //给application注册相应的生命周期函数回调。</div><div class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class="line">    public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) &#123;</div><div class="line">        getApplication().registerActivityLifecycleCallbacks(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="执行更新"><a href="#执行更新" class="headerlink" title="执行更新"></a>执行更新</h2><p>对于更新的执行，一旦我们load好了更新包之后，我们需要主动调用更新函数执行更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;);</div></pre></td></tr></table></figure><br>这个7zip文件就是我们指定的patch文件。</p><h2 id="tinker修复过程"><a href="#tinker修复过程" class="headerlink" title="tinker修复过程"></a>tinker修复过程</h2><p>首先从Application类的installTinker开始Tinker的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">TinkerManager.installTinker(this);</div><div class="line">====&gt;</div><div class="line"></div><div class="line"> public static void installTinker(ApplicationLike appLike) &#123;</div><div class="line">        if (isInstalled) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;install tinker, but has installed, ignore&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        LoadReporter loadReporter = new SampleLoadReporter(appLike.getApplication());</div><div class="line">        PatchReporter patchReporter = new SamplePatchReporter(appLike.getApplication());</div><div class="line">        PatchListener patchListener = new SamplePatchListener(appLike.getApplication());</div><div class="line">        AbstractPatch upgradePatchProcessor = new UpgradePatch();</div><div class="line"></div><div class="line">        //在这里直接实现install</div><div class="line">        TinkerInstaller.install(appLike,</div><div class="line">            loadReporter, patchReporter, patchListener,</div><div class="line">            SampleResultService.class, upgradePatchProcessor);</div><div class="line"></div><div class="line">        isInstalled = true;</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line">public static Tinker install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,</div><div class="line">                               PatchListener listener, Class&lt;? extends AbstractResultService&gt; resultServiceClass,</div><div class="line">                               AbstractPatch upgradePatchProcessor) &#123;</div><div class="line"></div><div class="line">        Tinker tinker = new Tinker.Builder(applicationLike.getApplication())</div><div class="line">            .tinkerFlags(applicationLike.getTinkerFlags())</div><div class="line">            .loadReport(loadReporter)</div><div class="line">            .listener(listener)</div><div class="line">            .patchReporter(patchReporter)</div><div class="line">            .tinkerLoadVerifyFlag(applicationLike.getTinkerLoadVerifyFlag()).build();</div><div class="line"></div><div class="line">        Tinker.create(tinker);</div><div class="line">        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor);</div><div class="line">        return tinker;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>首先会通过建造者模式创建出一个tinker实例，然后真正的调用该实例的install方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void install(Intent intentResult, Class&lt;? extends AbstractResultService&gt; serviceClass,</div><div class="line">                        AbstractPatch upgradePatch) &#123;</div><div class="line">        sInstalled = true;</div><div class="line">        //对TinkerPatchService设置更新Patch实例，TinkerPatchService是一个检测到有修复文件时会开启的新Service进程</div><div class="line">        TinkerPatchService.setPatchProcessor(upgradePatch, serviceClass);</div><div class="line">        </div><div class="line">        TinkerLog.i(TAG, &quot;try to install tinker, isEnable: %b, version: %s&quot;, isTinkerEnabled(), ShareConstants.TINKER_VERSION);</div><div class="line"></div><div class="line">        if (!isTinkerEnabled()) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;tinker is disabled&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (intentResult == null) &#123;</div><div class="line">            throw new TinkerRuntimeException(&quot;intentResult must not be null.&quot;);</div><div class="line">        &#125;</div><div class="line">        //tinkerLoadResult会解析tinker的返回值</div><div class="line">        tinkerLoadResult = new TinkerLoadResult();</div><div class="line">        //解析Tiner返回值</div><div class="line">        tinkerLoadResult.parseTinkerResult(getContext(), intentResult);</div><div class="line">        //当更新进程结束之后，调用这个方法解析返回code</div><div class="line">        loadReporter.onLoadResult(patchDirectory, tinkerLoadResult.loadCode, tinkerLoadResult.costTime);</div><div class="line"></div><div class="line">        if (!loaded) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;tinker load fail!&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>或者也可以通过下面的方法进行初始化：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">Tinker tinker = Tinker.with(getApplication());</div><div class="line">=====&gt;</div><div class="line">public static Tinker with(Context context) &#123;</div><div class="line">        if (!sInstalled) &#123;</div><div class="line">            throw new TinkerRuntimeException(&quot;you must install tinker before get tinker sInstance&quot;);</div><div class="line">        &#125;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (Tinker.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new Builder(context).build();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">======&gt;</div><div class="line">public Builder(Context context) &#123;</div><div class="line">            if (context == null) &#123;</div><div class="line">                throw new TinkerRuntimeException(&quot;Context must not be null.&quot;);</div><div class="line">            &#125;</div><div class="line">            this.context = context;</div><div class="line">            this.mainProcess = TinkerServiceInternals.isInMainProcess(context);</div><div class="line">            this.patchProcess = TinkerServiceInternals.isInTinkerPatchServiceProcess(context);</div><div class="line">            this.patchDirectory = SharePatchFileUtil.getPatchDirectory(context);</div><div class="line">            if (this.patchDirectory == null) &#123;</div><div class="line">                TinkerLog.e(TAG, &quot;patchDirectory is null!&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            this.patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory.getAbsolutePath());</div><div class="line">            this.patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory.getAbsolutePath());</div><div class="line">            TinkerLog.w(TAG, &quot;tinker patch directory: %s&quot;, patchDirectory);</div><div class="line">        &#125;</div><div class="line">=====&gt;</div><div class="line">public Tinker build() &#123;</div><div class="line">            if (status == -1) &#123;</div><div class="line">                status = ShareConstants.TINKER_ENABLE_ALL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (loadReporter == null) &#123;</div><div class="line">                loadReporter = new DefaultLoadReporter(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (patchReporter == null) &#123;</div><div class="line">                patchReporter = new DefaultPatchReporter(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (listener == null) &#123;</div><div class="line">                listener = new DefaultPatchListener(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (tinkerLoadVerifyFlag == null) &#123;</div><div class="line">                tinkerLoadVerifyFlag = false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return new Tinker(context, status, loadReporter, patchReporter, listener, patchDirectory,</div><div class="line">                patchInfoFile, patchInfoLockFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>在初始化完毕之后，就可以在收到修复文件的时候，开启修复进程了。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TinkerInstaller.onReceiveUpgradePatch(KKMHApp.getInstance(), </div><div class="line">    Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;);</div><div class="line"> </div></pre></td></tr></table></figure><br>通过TinkerInstaller的onReceiveUpgradePatch开启更新，必须传入相对应的修复文件的路径。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void onReceiveUpgradePatch(Context context, String patchLocation) &#123;</div><div class="line">        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>在这里获取相对应patchListener，并调用其onPatchReceived开始准备更新<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int onPatchReceived(String path) &#123;</div><div class="line">        //检查相应的更新包是否正确</div><div class="line">        int returnCode = patchCheck(path);</div><div class="line">        //如果patch正确，那么开启服务，进行更新，</div><div class="line">        if (returnCode == ShareConstants.ERROR_PATCH_OK) &#123;</div><div class="line">            TinkerPatchService.runPatchService(context, path);</div><div class="line">        &#125; else &#123;</div><div class="line">            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);</div><div class="line">        &#125;</div><div class="line">        return returnCode;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>我们来看看tinker如何检测更新包的有效性。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">protected int patchCheck(String path) &#123;</div><div class="line">        Tinker manager = Tinker.with(context);</div><div class="line">        //判断是否允许tinker启动</div><div class="line">        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_DISABLE;</div><div class="line">        &#125;</div><div class="line">        //生成该文件</div><div class="line">        File file = new File(path);</div><div class="line"></div><div class="line">        //判断文件是否存在且合法</div><div class="line">        if (!SharePatchFileUtil.isLegalFile(file)) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_NOTEXIST;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果是PatchService的线程，那么不能发送更新请求</div><div class="line">        if (manager.isPatchProcess()) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_INSERVICE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果这个PatchService正在执行修复操作，那么应该阻塞</div><div class="line">        if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_RUNNING;</div><div class="line">        &#125;</div><div class="line">        //判断是否是diavik虚拟机</div><div class="line">        if (ShareTinkerInternals.isVmJit()) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_JIT;</div><div class="line">        &#125;</div><div class="line">        return ShareConstants.ERROR_PATCH_OK;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>假如所有的检查都通过，那么就开启更新服务。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void runPatchService(Context context, String path) &#123;</div><div class="line">        try &#123;</div><div class="line">            Intent intent = new Intent(context, TinkerPatchService.class);</div><div class="line">            intent.putExtra(PATCH_PATH_EXTRA, path);</div><div class="line">            intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());</div><div class="line">            context.startService(intent);</div><div class="line">        &#125; catch (Throwable throwable) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;start patch service fail, exception:&quot; + throwable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>这个PatchService是一个IntentService，当成功启动之后，我们会调用到它的onHandleIntent执行操作<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">protected void onHandleIntent(Intent intent) &#123;</div><div class="line">        final Context context = getApplicationContext();</div><div class="line">        Tinker tinker = Tinker.with(context);</div><div class="line">        tinker.getPatchReporter().onPatchServiceStart(intent);</div><div class="line"></div><div class="line">        if (intent == null) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;TinkerPatchService received a null intent, ignoring.&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //更新包的path会通过intent传递到这个Service中</div><div class="line">        String path = getPatchPathExtra(intent);</div><div class="line">        if (path == null) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;TinkerPatchService can&apos;t get the path extra, ignoring.&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        File patchFile = new File(path);</div><div class="line"></div><div class="line">        long begin = SystemClock.elapsedRealtime();</div><div class="line">        boolean result;</div><div class="line">        long cost;</div><div class="line">        Throwable e = null;</div><div class="line"></div><div class="line">        //提高优先级</div><div class="line">        increasingPriority();</div><div class="line">        //patchResult用于处理更新结果</div><div class="line">        PatchResult patchResult = new PatchResult();</div><div class="line">        try &#123;</div><div class="line">            if (upgradePatchProcessor == null) &#123;</div><div class="line">                throw new TinkerRuntimeException(&quot;upgradePatchProcessor is null.&quot;);</div><div class="line">            &#125;</div><div class="line">            //在这里开启更新</div><div class="line">            result = upgradePatchProcessor.tryPatch(context, path, patchResult);</div><div class="line">        &#125; catch (Throwable throwable) &#123;</div><div class="line">            e = throwable;</div><div class="line">            result = false;</div><div class="line">            tinker.getPatchReporter().onPatchException(patchFile, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //记录更新结果</div><div class="line">        cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">        tinker.getPatchReporter().</div><div class="line">            onPatchResult(patchFile, result, cost);</div><div class="line"></div><div class="line">        patchResult.isSuccess = result;</div><div class="line">        patchResult.rawPatchFilePath = path;</div><div class="line">        patchResult.costTime = cost;</div><div class="line">        patchResult.e = e;</div><div class="line">        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>其实上面Service最重要的就是就是启动了一个线程，会调用了upgradePatch的tryPatch执行patch操作,下面我们来看看这个patch操作的处理<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line">public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) &#123;</div><div class="line">        Tinker manager = Tinker.with(context);</div><div class="line"></div><div class="line">        final File patchFile = new File(tempPatchPath);</div><div class="line">        </div><div class="line">        //tinker是否处于enable状态</div><div class="line">        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:patch is disabled, just return&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        //是否是合法的patch文件</div><div class="line">        if (!SharePatchFileUtil.isLegalFile(patchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:patch file is not found, just return&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        //创建出ShareSecurityCheck，用于检查签名文件</div><div class="line">        ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);</div><div class="line">        //检查tinkerid和签名是否正确，后面我们会分析这个检查的执行</div><div class="line">        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);</div><div class="line">        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:onPatchPackageCheckFail&quot;);</div><div class="line">            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //获取相对应的md5值</div><div class="line">        String patchMd5 = SharePatchFileUtil.getMD5(patchFile);</div><div class="line">        if (patchMd5 == null) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:patch md5 is null, just return&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        TinkerLog.i(TAG, &quot;UpgradePatch tryPatch:patchMd5:%s&quot;, patchMd5);</div><div class="line"></div><div class="line">        //上面的检查都正确了，那么可以开始进行修复了</div><div class="line">        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();</div><div class="line"></div><div class="line">        //获取Patchinfo的解锁文件和正式文件</div><div class="line">        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);</div><div class="line">        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);</div><div class="line"></div><div class="line">        //获取先前的patchInfo</div><div class="line">        SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class="line"></div><div class="line">        //it is a new patch, so we should not find a exist</div><div class="line">        SharePatchInfo newInfo;</div><div class="line"></div><div class="line">        //已经patch文件了</div><div class="line">        if (oldInfo != null) &#123;</div><div class="line">            if (oldInfo.oldVersion == null || oldInfo.newVersion == null || oldInfo.oatDir == null) &#123;</div><div class="line">                TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:onPatchInfoCorrupted&quot;);</div><div class="line">                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            //md5不合法</div><div class="line">            if (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) &#123;</div><div class="line">                TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid&quot;, patchMd5);</div><div class="line">                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            // 生成新的PatchInfo</div><div class="line">            final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)</div><div class="line">                ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;</div><div class="line">            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT, finalOatDir);</div><div class="line">        &#125; else &#123;</div><div class="line">            newInfo = new SharePatchInfo(&quot;&quot;, patchMd5, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      </div><div class="line">        final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);</div><div class="line"></div><div class="line">        final String patchVersionDirectory = patchDirectory + &quot;/&quot; + patchName;</div><div class="line"></div><div class="line">        TinkerLog.i(TAG, &quot;UpgradePatch tryPatch:patchVersionDirectory:%s&quot;, patchVersionDirectory);</div><div class="line"></div><div class="line">        //复制文件</div><div class="line">        File destPatchFile = new File(patchVersionDirectory + &quot;/&quot; + SharePatchFileUtil.getPatchVersionFile(patchMd5));</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 再次检查md5</div><div class="line">            if (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) &#123;</div><div class="line">                SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);</div><div class="line">                TinkerLog.w(TAG, &quot;UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d&quot;, patchFile.getAbsolutePath(), patchFile.length(),</div><div class="line">                    destPatchFile.getAbsolutePath(), destPatchFile.length());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:copy patch file fail from %s to %s&quot;, patchFile.getPath(), destPatchFile.getPath());</div><div class="line">            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //尝试修复dex</div><div class="line">        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch dex failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch library failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch resource failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted</div><div class="line">        if (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, check dex opt file failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, rewrite patch info failed&quot;);</div><div class="line">            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TinkerLog.w(TAG, &quot;UpgradePatch tryPatch: done, it is ok&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>在上面我们主要关注dex的修复，因为目前仅仅用于dex修复。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,</div><div class="line">                                                String patchVersionDirectory, File patchFile) &#123;</div><div class="line">        if (!manager.isEnabledForDex()) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;patch recover, dex is not enabled&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        //获取dex文件</div><div class="line">        String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE);</div><div class="line"></div><div class="line">        if (dexMeta == null) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;patch recover, dex is not contained&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long begin = SystemClock.elapsedRealtime();</div><div class="line">        //在这里进行dex解压和处理</div><div class="line">        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</div><div class="line">        long cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">        TinkerLog.i(TAG, &quot;recover dex result:%b, cost:%d&quot;, result, cost);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>我们看看patchDexExtractViaDexDiff的解压操作：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) &#123;</div><div class="line">        String dir = patchVersionDirectory + &quot;/&quot; + DEX_PATH + &quot;/&quot;;</div><div class="line">        </div><div class="line">        //对patch文件解压和检查</div><div class="line">        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;patch recover, extractDiffInternals fail&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final Tinker manager = Tinker.with(context);</div><div class="line"></div><div class="line">        File dexFiles = new File(dir);</div><div class="line">        File[] files = dexFiles.listFiles();</div><div class="line">        optFiles.clear();</div><div class="line"></div><div class="line">        if (files != null) &#123;</div><div class="line">            final String optimizeDexDirectory = patchVersionDirectory + &quot;/&quot; + DEX_OPTIMIZE_PATH + &quot;/&quot;;</div><div class="line">            File optimizeDexDirectoryFile = new File(optimizeDexDirectory);</div><div class="line"></div><div class="line">            if (!optimizeDexDirectoryFile.exists() &amp;&amp; !optimizeDexDirectoryFile.mkdirs()) &#123;</div><div class="line">                TinkerLog.w(TAG, &quot;patch recover, make optimizeDexDirectoryFile fail&quot;);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            //添加opt文件</div><div class="line">            for (File file : files) &#123;</div><div class="line">                String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);</div><div class="line">                optFiles.add(new File(outputPathName));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            TinkerLog.i(TAG, &quot;patch recover, try to optimize dex file count:%d, optimizeDexDirectory:%s&quot;, files.length, optimizeDexDirectory);</div><div class="line">            //针对于art虚拟机使用parallel dex optimizer</div><div class="line">            if (ShareTinkerInternals.isVmArt()) &#123;</div><div class="line">                final List&lt;File&gt; failOptDexFile = new Vector&lt;&gt;();</div><div class="line">                final Throwable[] throwable = new Throwable[1];</div><div class="line"></div><div class="line">                // try parallel dex optimizer</div><div class="line">                TinkerParallelDexOptimizer.optimizeAll(</div><div class="line">                    Arrays.asList(files), optimizeDexDirectoryFile,</div><div class="line">                    new TinkerParallelDexOptimizer.ResultCallback() &#123;</div><div class="line">                        long startTime;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        public void onStart(File dexFile, File optimizedDir) &#123;</div><div class="line">                            startTime = System.currentTimeMillis();</div><div class="line">                            TinkerLog.i(TAG, &quot;start to parallel optimize dex %s, size: %d&quot;, dexFile.getPath(), dexFile.length());</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) &#123;</div><div class="line">                            // Do nothing.</div><div class="line">                            TinkerLog.i(TAG, &quot;success to parallel optimize dex %s, opt file size: %d, use time %d&quot;,</div><div class="line">                                dexFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) &#123;</div><div class="line">                            TinkerLog.i(TAG, &quot;fail to parallel optimize dex %s use time %d&quot;,</div><div class="line">                                dexFile.getPath(), (System.currentTimeMillis() - startTime));</div><div class="line">                            failOptDexFile.add(dexFile);</div><div class="line">                            throwable[0] = thr;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                );</div><div class="line"></div><div class="line">                if (!failOptDexFile.isEmpty()) &#123;</div><div class="line">                    manager.getPatchReporter().onPatchDexOptFail(patchFile, failOptDexFile, throwable[0]);</div><div class="line">                    return false;</div><div class="line">                &#125;</div><div class="line">            // 对于davik虚拟机</div><div class="line">            &#125; else &#123;</div><div class="line">                for (File file : files) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);</div><div class="line">                        long start = System.currentTimeMillis();</div><div class="line">                        //加载dex文件</div><div class="line">                        DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);</div><div class="line">                        TinkerLog.i(TAG, &quot;success single dex optimize file, path: %s, opt file size: %d, use time: %d&quot;, file.getPath(), new File(outputPathName).length(),</div><div class="line">                            (System.currentTimeMillis() - start));</div><div class="line">                    &#125; catch (Throwable e) &#123;</div><div class="line">                        TinkerLog.e(TAG, &quot;single dex optimize or load failed, path:&quot; + file.getPath());</div><div class="line">                        List&lt;File&gt; failedList = new ArrayList&lt;&gt;();</div><div class="line">                        failedList.add(file);</div><div class="line">                        manager.getPatchReporter().onPatchDexOptFail(patchFile, failedList, e);</div><div class="line">                        return false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure></p><h2 id="tinker生成patch原理"><a href="#tinker生成patch原理" class="headerlink" title="tinker生成patch原理"></a>tinker生成patch原理</h2><h3 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h3><p>在了解tinker生成patch文件之前，我们必须先了解一下dex文件的格式。dex文件是davilk虚拟机的文件格式。详细的可以查看<a href="https://source.android.com/devices/tech/dalvik/dex-format详细文档的信息。在这里，我们主要关注dex的文件格式" target="_blank" rel="external">https://source.android.com/devices/tech/dalvik/dex-format详细文档的信息。在这里，我们主要关注dex的文件格式</a></p><ul><li><p>header:这个是最重要的属性。标识了该文件的格式,并且记录了当前文件的数据类型的偏移量和数量。</p></li><li><p>string_ids：字符串数据索引，这个内容必须排序，且不能重复。</p></li><li><p>type_ids: ： 类型的字符串索引，按照stringId的索引进行排序，也不能有重复</p></li><li><p>proto_ids:  原形数据索引，这个列表必须要按照typeid索引进行主要顺序排序，参数列表按照字典排序</p></li><li><p>field_ids: 字段数据索引，定义的类型按照typeid排序，名称爱照stringid排序，这个字段不能重复</p></li><li><p>method_ids: 方法索引，dex文件中所有方法的标识符，必须进行排序，不能重复</p></li><li><p>class_defs: 类索引，必须进行排序，超类或者引用类必须更早出现，重复的重名类无效。</p></li><li><p>call_site_ids: 调用站点标识符列表</p></li><li><p>method_handles: 方法引用。</p></li><li><p>data: 数据区</p></li><li><p>link_data: 链接数据区</p></li></ul><p>如下所示，这个是一个dex文件的数据解析。<br><img src="http://onu21exz8.bkt.clouddn.com/dex_total.jpeg" alt=""><br>我们可以看到dex文件的起始的三个字符就是dex，这个字符用来标识这是一个dex格式的文件。</p><p>下面我们针对于上面几个比较重要的元素来进行分析。<br><img src="http://onu21exz8.bkt.clouddn.com/header.jpeg" alt=""><br>首先是header里面的信息，首先magic会包含struct dex_magic magic结构，这个就是标识文件格式的结构，内部dex的编码。然后会是sha1签名的编码。最后是一些内部数据的大小及偏移量。如果我们想要解析这个dex文件，header的信息是我们必须要先解析出来的。</p><p><img src="http://onu21exz8.bkt.clouddn.com/stringid.jpeg" alt=""><br>stringId项会将所有的string类型数据进行存储<br><img src="http://onu21exz8.bkt.clouddn.com/typeid.jpeg" alt=""><br>typeId为文件中使用的数据类型和对象类型<br><img src="http://onu21exz8.bkt.clouddn.com/fileid.jpeg" alt=""><br>filedId为定义的字段名称<br><img src="http://onu21exz8.bkt.clouddn.com/protoid.jpeg" alt=""><br>protoId为原型数据类型<br><img src="http://onu21exz8.bkt.clouddn.com/methodid.jpeg" alt=""><br>methodId为dex文件中涉及的所有方法<br><img src="http://onu21exz8.bkt.clouddn.com/classid.jpeg" alt=""><br>classId表示在dex文件中涉及的所有类，超类必须比子类早出现，内部包含类名，标识位，超类。。</p><h3 id="tinker-dex文件的生成"><a href="#tinker-dex文件的生成" class="headerlink" title="tinker dex文件的生成"></a>tinker dex文件的生成</h3><p>tinker通过全量的apk打包，然后进行与旧包进行对比，通过差异化生成patch的dex文件。下面我们来看看它是如何生成patch的。<br>gradle定义task有几种方式，我们可以定义一个task继承于DefaultTask，然后通过@TaskAction注解声明gradle的task执行时会调用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@TaskAction</div><div class="line">   def tinkerPatch() &#123;</div><div class="line">       configuration.checkParameter()</div><div class="line">       configuration.buildConfig.checkParameter()</div><div class="line">       configuration.res.checkParameter()</div><div class="line">       configuration.dex.checkDexMode()</div><div class="line">       configuration.sevenZip.resolveZipFinalPath()</div><div class="line"></div><div class="line">       InputParam.Builder builder = new InputParam.Builder()</div><div class="line">       if (configuration.useSign) &#123;</div><div class="line">           if (signConfig == null) &#123;</div><div class="line">               throw new GradleException(&quot;can&apos;t the get signConfig for this build&quot;)</div><div class="line">           &#125;</div><div class="line">           builder.setSignFile(signConfig.storeFile)</div><div class="line">                   .setKeypass(signConfig.keyPassword)</div><div class="line">                   .setStorealias(signConfig.keyAlias)</div><div class="line">                   .setStorepass(signConfig.storePassword)</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       builder.setOldApk(configuration.oldApk)</div><div class="line">              .setNewApk(buildApkPath)</div><div class="line">              .setOutBuilder(outputFolder)</div><div class="line">              .setIgnoreWarning(configuration.ignoreWarning)</div><div class="line">              .setDexFilePattern(new ArrayList&lt;String&gt;(configuration.dex.pattern))</div><div class="line">              .setIsProtectedApp(configuration.buildConfig.isProtectedApp)</div><div class="line">              .setDexLoaderPattern(new ArrayList&lt;String&gt;(configuration.dex.loader))</div><div class="line">              .setDexIgnoreWarningLoaderPattern(new ArrayList&lt;String&gt;(configuration.dex.ignoreWarningLoader))</div><div class="line">              .setDexMode(configuration.dex.dexMode)</div><div class="line">              .setSoFilePattern(new ArrayList&lt;String&gt;(configuration.lib.pattern))</div><div class="line">              .setResourceFilePattern(new ArrayList&lt;String&gt;(configuration.res.pattern))</div><div class="line">              .setResourceIgnoreChangePattern(new ArrayList&lt;String&gt;(configuration.res.ignoreChange))</div><div class="line">              .setResourceLargeModSize(configuration.res.largeModSize)</div><div class="line">              .setUseApplyResource(configuration.buildConfig.usingResourceMapping)</div><div class="line">              .setConfigFields(new HashMap&lt;String, String&gt;(configuration.packageConfig.getFields()))</div><div class="line">              .setSevenZipPath(configuration.sevenZip.path)</div><div class="line">              .setUseSign(configuration.useSign)</div><div class="line"></div><div class="line">       InputParam inputParam = builder.create()</div><div class="line">       Runner.gradleRun(inputParam);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在gradle编译完成最新的apk之后，会调用调用这个task的方法，注入一些配置的必要参数，然后调用Runner.gradleRun方法执行run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void gradleRun(InputParam inputParam) &#123;</div><div class="line">        mBeginTime = System.currentTimeMillis();</div><div class="line">        Runner m = new Runner();</div><div class="line">        m.run(inputParam);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=====&gt;run</div><div class="line">private void run(InputParam inputParam) &#123;</div><div class="line">//在这里将会读取gradle的各种配置信息到config中。</div><div class="line">        loadConfigFromGradle(inputParam);</div><div class="line">        try &#123;</div><div class="line">            Logger.initLogger(config);</div><div class="line">            tinkerPatch();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            goToError();</div><div class="line">        &#125; finally &#123;</div><div class="line">            Logger.closeLogger();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>会在run方法中调用tinkerPatch，这个是生成patch包的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">protected void tinkerPatch() &#123;</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch begin-----------------------&quot;);</div><div class="line"></div><div class="line">        Logger.d(config.toString());</div><div class="line">        try &#123;</div><div class="line">            //初始化APKDecoder，内部会初始化UniqueDexDiffDecoder、BsDiffDecoder、ResDiffDecoder,分别对应dex、so、res的patch生成</div><div class="line">            ApkDecoder decoder = new ApkDecoder(config);</div><div class="line">    //patch开始前的预处理方法，目前为空实现</div><div class="line">            decoder.onAllPatchesStart();</div><div class="line">    //对比新旧apk，生成patch</div><div class="line">            decoder.patch(config.mOldApkFile, config.mNewApkFile);</div><div class="line">            decoder.onAllPatchesEnd();</div><div class="line"></div><div class="line">            //gen meta file and version file</div><div class="line">            PatchInfo info = new PatchInfo(config);</div><div class="line">            info.gen();</div><div class="line"></div><div class="line">            //build patch</div><div class="line">            PatchBuilder builder = new PatchBuilder(config);</div><div class="line">            builder.buildPatch();</div><div class="line"></div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            goToError();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Logger.d(&quot;Tinker patch done, total time cost: %fs&quot;, diffTimeFromBegin());</div><div class="line">        Logger.d(&quot;Tinker patch done, you can go to file to find the output %s&quot;, config.mOutFolder);</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch end-------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=========&gt;在这里执行patch方法：</div><div class="line"></div><div class="line">public boolean patch(File oldFile, File newFile) throws Exception &#123;</div><div class="line">        writeToLogFile(oldFile, newFile);</div><div class="line">        //先对manifest进行patch处理，先检测miniSdk的修改与是否新增component</div><div class="line">        manifestDecoder.patch(oldFile, newFile);</div><div class="line">//将apk文件读取成输出流</div><div class="line">        unzipApkFiles(oldFile, newFile);</div><div class="line">//在这里会调用visitFile方法，生成各个patch文件</div><div class="line">        Files.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));</div><div class="line"></div><div class="line">        //get all duplicate resource file</div><div class="line">        for (File duplicateRes : resDuplicateFiles) &#123;</div><div class="line">//            resPatchDecoder.patch(duplicateRes, null);</div><div class="line">            Logger.e(&quot;Warning: res file %s is also match at dex or library pattern, &quot;</div><div class="line">                + &quot;we treat it as unchanged in the new resource_out.zip&quot;, getRelativePathStringToOldFile(duplicateRes));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//在patch file完成之后，会执行一些patch完成后的操作</div><div class="line">        soPatchDecoder.onAllPatchesEnd();</div><div class="line">        dexPatchDecoder.onAllPatchesEnd();</div><div class="line">        manifestDecoder.onAllPatchesEnd();</div><div class="line">        resPatchDecoder.onAllPatchesEnd();</div><div class="line"></div><div class="line">        //clean resources</div><div class="line">        dexPatchDecoder.clean();</div><div class="line">        soPatchDecoder.clean();</div><div class="line">        resPatchDecoder.clean();</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在walkFileTree中会执行visitFile方法,在这里面分别会执行dex的patch方法，so的patch方法还有res的patch方法，我们主要关注dex的patch方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</div><div class="line">             dexDecoder.patch(oldFile, file.toFile());</div><div class="line">             return FileVisitResult.CONTINUE;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=====&gt; UniqueDexDiffDecoder.patch，这个类表示dex不能重复</div><div class="line"></div><div class="line"> @Override</div><div class="line">    public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException &#123;</div><div class="line">        boolean added = super.patch(oldFile, newFile);</div><div class="line">        if (added) &#123;</div><div class="line">            String name = newFile.getName();</div><div class="line">            if (addedDexFiles.contains(name)) &#123;</div><div class="line">                throw new TinkerPatchException(&quot;illegal dex name, dex name should be unique, dex:&quot; + name);</div><div class="line">            &#125; else &#123;</div><div class="line">                addedDexFiles.add(name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return added;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=========&gt; super.patch也就是DexDiffDecoder.patch方法</div><div class="line"></div><div class="line">  public boolean patch(final File oldFile, final File newFile) throws IOException, TinkerPatchException &#123;</div><div class="line">        //获取相关的dex name</div><div class="line">        final String dexName = getRelativeDexName(oldFile, newFile);</div><div class="line"></div><div class="line">//检测这个dex是否发生改变。</div><div class="line">        excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);</div><div class="line">        if (newFile == null || !newFile.exists() || newFile.length() == 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       </div><div class="line">        File dexDiffOut = getOutputPath(newFile).toFile();</div><div class="line"></div><div class="line">        final String newMd5 = getRawOrWrappedDexMD5(newFile);</div><div class="line"></div><div class="line">        //new add file</div><div class="line">        if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) &#123;</div><div class="line">            hasDexChanged = true;</div><div class="line">            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String oldMd5 = getRawOrWrappedDexMD5(oldFile);</div><div class="line"></div><div class="line">        if ((oldMd5 != null &amp;&amp; !oldMd5.equals(newMd5)) || (oldMd5 == null &amp;&amp; newMd5 != null)) &#123;</div><div class="line">            hasDexChanged = true;</div><div class="line">            if (oldMd5 != null) &#123;</div><div class="line">//计算出来的md5不同，表示有类发生改变，那么收集增加或者删除的类</div><div class="line">                collectAddedOrDeletedClasses(oldFile, newFile);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        RelatedInfo relatedInfo = new RelatedInfo();</div><div class="line">        relatedInfo.oldMd5 = oldMd5;</div><div class="line">        relatedInfo.newMd5 = newMd5;</div><div class="line"></div><div class="line">        oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry&lt;&gt;(oldFile, newFile));</div><div class="line"></div><div class="line">        dexNameToRelatedInfoMap.put(dexName, relatedInfo);</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>上面的excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex非常重要，这个类可以用来判断两个dex是否发生变化了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile) &#123;</div><div class="line">    oldDex = (oldFile != null ? new Dex(oldFile) : null);</div><div class="line">             newDex = (newFile != null ? new Dex(newFile) : null);</div><div class="line">/**</div><div class="line">                 * Check rule:</div><div class="line">                 * 新的dex和老的dex中的loader class必须一致</div><div class="line">                 *</div><div class="line">                 * An error is announced when any of these conditions below is fit:</div><div class="line">                 * 1. 老的dex文件有缺失</div><div class="line">                 * 2. 新的dex文件有缺失</div><div class="line">                 * 3. 老的dex文件中缺失某些loader类</div><div class="line">                 * 4. 新的dex文件中添加了某些老的dex文件中没有的loader类.</div><div class="line">                 * 5. 某些老的dex的loader 类发生了改变，然而却在新类中删除</div><div class="line">                 * 6. loader类在老的dex文件中重复定义</div><div class="line">                 * 7. Loader类在新的dex文件中重复定义</div><div class="line">                 */</div><div class="line"> ....</div><div class="line">  dexCmptor.startCheck(oldDex, newDex);</div><div class="line">                 deletedClassInfos = dexCmptor.getDeletedClassInfos()</div><div class="line">                 addedClassInfos = dexCmptor.getAddedClassInfos();</div><div class="line">                 changedClassInfosMap = new HashMap&lt;&gt;(dexCmptor.getChangedClassDescToInfosMap());</div><div class="line"> ....</div><div class="line">&#125;</div><div class="line"></div><div class="line">======&gt;最主要的check方法</div><div class="line"> public void startCheck(Dex oldDex, Dex newDex) &#123;</div><div class="line">        startCheck(DexGroup.wrap(oldDex), DexGroup.wrap(newDex));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) &#123;</div><div class="line">        //</div><div class="line">        addedClassInfoList.clear();</div><div class="line">        deletedClassInfoList.clear();</div><div class="line">        changedClassDescToClassInfosMap.clear();</div><div class="line">        oldDescriptorOfClassesToCheck.clear();</div><div class="line">        newDescriptorOfClassesToCheck.clear();</div><div class="line">        oldClassDescriptorToClassInfoMap.clear();</div><div class="line">        newClassDescriptorToClassInfoMap.clear();</div><div class="line">        refAffectedClassDescs.clear();</div><div class="line"></div><div class="line">//遍历Old dex，查看old dex文件中的classId items是否发生改变，</div><div class="line">        for (Dex oldDex : oldDexGroup.dexes) &#123;</div><div class="line">            int classDefIndex = 0;</div><div class="line">            for (ClassDef oldClassDef : oldDex.classDefs()) &#123;</div><div class="line">//typeIndex是dex文件中的Class item的类型描述</div><div class="line">                String desc = oldDex.typeNames().get(oldClassDef.typeIndex);</div><div class="line">                if (Utils.isStringMatchesPatterns(desc, patternsOfClassDescToCheck)) &#123;</div><div class="line">                    //如果类型匹配且不重复，则添加进oldDescriptorOfClassesToCheck中</div><div class="line">     if (!oldDescriptorOfClassesToCheck.add(desc)) &#123;</div><div class="line">                        throw new IllegalStateException(</div><div class="line">                                String.format(</div><div class="line">                                        &quot;duplicate class descriptor [%s] in different old dexes.&quot;,</div><div class="line">                                        desc</div><div class="line">                                )</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">//创建出dexClassInfo，并添加到oldClassDescriptorToClassInfoMap.put中。</div><div class="line">                DexClassInfo classInfo = new DexClassInfo(desc, classDefIndex, oldClassDef, oldDex);</div><div class="line">                ++classDefIndex;</div><div class="line">                oldClassDescriptorToClassInfoMap.put(desc, classInfo);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 遍历new dex，获取出new dex的class类型和对应的classInfo</div><div class="line">        for (Dex newDex : newDexGroup.dexes) &#123;</div><div class="line">            int classDefIndex = 0;</div><div class="line">            for (ClassDef newClassDef : newDex.classDefs()) &#123;</div><div class="line">                String desc = newDex.typeNames().get(newClassDef.typeIndex);</div><div class="line">                if (Utils.isStringMatchesPatterns(desc, patternsOfClassDescToCheck)) &#123;</div><div class="line">                    if (!newDescriptorOfClassesToCheck.add(desc)) &#123;</div><div class="line">                        throw new IllegalStateException(</div><div class="line">                                String.format(</div><div class="line">                                        &quot;duplicate class descriptor [%s] in different new dexes.&quot;,</div><div class="line">                                        desc</div><div class="line">                                )</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                DexClassInfo classInfo = new DexClassInfo(desc, classDefIndex, newClassDef, newDex);</div><div class="line">                ++classDefIndex;</div><div class="line">                newClassDescriptorToClassInfoMap.put(desc, classInfo);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //比较old和new中的class描述，deletedClassDescs剩余的成员就是需要移除的class。</div><div class="line">        Set&lt;String&gt; deletedClassDescs = new HashSet&lt;&gt;(oldDescriptorOfClassesToCheck);</div><div class="line">        deletedClassDescs.removeAll(newDescriptorOfClassesToCheck);</div><div class="line"></div><div class="line">        for (String desc : deletedClassDescs) &#123;</div><div class="line">            if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) &#123;</div><div class="line">                logger.i(TAG, &quot;Ignored deleted class: %s&quot;, desc);</div><div class="line">                continue;</div><div class="line">            &#125; else &#123;</div><div class="line">                logger.i(TAG, &quot;Deleted class: %s&quot;, desc);</div><div class="line">            &#125;</div><div class="line">    //如果不是忽略的，那么就要移除，保证两个dexList一致</div><div class="line">            deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//比较old和new中的class描述， addedClassDescs中剩余的成员就是新增的类</div><div class="line">        Set&lt;String&gt; addedClassDescs = new HashSet&lt;&gt;(newDescriptorOfClassesToCheck);</div><div class="line">        addedClassDescs.removeAll(oldDescriptorOfClassesToCheck);</div><div class="line"></div><div class="line">        for (String desc : addedClassDescs) &#123;</div><div class="line">            logger.i(TAG, &quot;Added class: %s&quot;, desc);</div><div class="line">    //增加新类</div><div class="line">            addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//通过oldDescriptorOfClassesToCheck和newDescriptorOfClassesToCheck，添加到同一个set中，这个set的成员就是可能发生改变的类</div><div class="line">        Set&lt;String&gt; mayBeChangedClassDescs = new HashSet&lt;&gt;(oldDescriptorOfClassesToCheck);</div><div class="line">        mayBeChangedClassDescs.retainAll(newDescriptorOfClassesToCheck);</div><div class="line"></div><div class="line">        for (String desc : mayBeChangedClassDescs) &#123;</div><div class="line">            DexClassInfo oldClassInfo = oldClassDescriptorToClassInfoMap.get(desc);</div><div class="line">            DexClassInfo newClassInfo = newClassDescriptorToClassInfoMap.get(desc);</div><div class="line">            switch (compareMode) &#123;</div><div class="line">                case COMPARE_MODE_NORMAL: &#123;</div><div class="line">    //比较是否是同一个类，会比较类中的所有成员、方法及变量。</div><div class="line">                    if (!isSameClass(</div><div class="line">                            oldClassInfo.owner,</div><div class="line">                            newClassInfo.owner,</div><div class="line">                            oldClassInfo.classDef,</div><div class="line">                            newClassInfo.classDef</div><div class="line">                    )) &#123;</div><div class="line">                        logger.i(TAG, &quot;Changed class: %s&quot;, desc);</div><div class="line">//假如类发生过改变，那么添加到changedClassDescToClassInfosMap中</div><div class="line">                        changedClassDescToClassInfosMap.put(</div><div class="line">                                desc, new DexClassInfo[]&#123;oldClassInfo, newClassInfo&#125;</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY: &#123;</div><div class="line">                    if (isClassChangeAffectedToReferrer(</div><div class="line">                            oldClassInfo.owner,</div><div class="line">                            newClassInfo.owner,</div><div class="line">                            oldClassInfo.classDef,</div><div class="line">                            newClassInfo.classDef</div><div class="line">                    )) &#123;</div><div class="line">                        logger.i(TAG, &quot;Ref-changed class: %s&quot;, desc);</div><div class="line">                        changedClassDescToClassInfosMap.put(</div><div class="line">                                desc, new DexClassInfo[]&#123;oldClassInfo, newClassInfo&#125;</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>那么tinker是如何判断类是否发生了改变呢，其实也是基本dex的文件的格式去判断的。上面也简单的截了张classItem的图了。现在我们来详细介绍下class里面的内部成员。</p><ul><li>unit class_idx:也就是类的类型，被称为类的typeId</li><li>enum ACCESS_FLAGS access_flags： 也就是类的访问权限</li><li>uint superclass_idx： 超类的类型， 也就是超类的typeId</li><li>uint interfaces_idx： 类中的接口列表，</li><li>uint source_file_idx： 类的名称</li><li>uint annotations_idx： 注解的列表</li><li>struct class_data_item class_data： class里面的内部数据。包括了static field， instance field，direct method，virtual methods等。</li></ul><p>那么isSameClass就是基于这些数据定义去进行比较的。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">private boolean isSameClass(Dex oldDex,Dex newDex,ClassDef oldClassDef,</div><div class="line">           ClassDef newClassDef) &#123;</div><div class="line">       //首先判断类的标识位是否一致</div><div class="line">       if (oldClassDef.accessFlags != newClassDef.accessFlags) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断类的desc是否一致，也就是类型的定义是否一致</div><div class="line">       if (!isSameClassDesc(</div><div class="line">               oldDex, newDex, oldClassDef.supertypeIndex, newClassDef.supertypeIndex</div><div class="line">       )) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       short[] oldInterfaceIndices = oldDex.interfaceTypeIndicesFromClassDef(oldClassDef);</div><div class="line">       short[] newInterfaceIndices = newDex.interfaceTypeIndicesFromClassDef(newClassDef);</div><div class="line">      //判断接口是否一致</div><div class="line"> if (oldInterfaceIndices.length != newInterfaceIndices.length) &#123;</div><div class="line">           return false;</div><div class="line">       &#125; else &#123;</div><div class="line">           for (int i = 0; i &lt; oldInterfaceIndices.length; ++i) &#123;</div><div class="line">               if (!isSameClassDesc(oldDex, newDex, oldInterfaceIndices[i], newInterfaceIndices[i])) &#123;</div><div class="line">                   return false;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断源文件的java名称是否一致</div><div class="line">       if (!isSameName(oldDex, newDex, oldClassDef.sourceFileIndex, newClassDef.sourceFileIndex)) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断是否是同样的注解</div><div class="line">       if (!isSameAnnotationDirectory(</div><div class="line">               oldDex,</div><div class="line">               newDex,</div><div class="line">               oldClassDef.annotationsOffset,</div><div class="line">               newClassDef.annotationsOffset</div><div class="line">       )) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断是否是同样的classData，内部遍历定义的field和method</div><div class="line">       if (!isSameClassData(</div><div class="line">               oldDex,</div><div class="line">               newDex,</div><div class="line">               oldClassDef.classDataOffset,</div><div class="line">               newClassDef.classDataOffset</div><div class="line">       )) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return isSameStaticValue(</div><div class="line">               oldDex,</div><div class="line">               newDex,</div><div class="line">               oldClassDef.staticValuesOffset,</div><div class="line">               newClassDef.staticValuesOffset</div><div class="line">       );</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>在ApkDecoder执行patch完毕之后，将会调用onAllPatchEnd表示patch执行完毕最后需要进行的操作。<br>现在我们来看看dexPatchDecoder的onAllPatchEnd方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void onAllPatchesEnd() throws Exception &#123;</div><div class="line">        //假如patch过程中没有检测到dex改变的话，直接返回。</div><div class="line">        if (!hasDexChanged) &#123;</div><div class="line">            Logger.d(&quot;No dexes were changed, nothing needs to be done next.&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">//是否使用加固模式，这里我们仅仅阅读不使用加固模式的方式。</div><div class="line">        if (config.mIsProtectedApp) &#123;</div><div class="line">            generateChangedClassesDexFile();</div><div class="line">        &#125; else &#123;</div><div class="line">    //在这里生成patch文件到file。</div><div class="line">            generatePatchInfoFile();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        addTestDex();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">======》 generatePatchInfoFile</div><div class="line"></div><div class="line"> private void generatePatchInfoFile() throws IOException &#123;</div><div class="line">     //生成dexfile</div><div class="line">        generatePatchedDexInfoFile();</div><div class="line"></div><div class="line">//因为generateSmallPatchedDexInfoFile可能会发生阻塞而导致art虚拟机出现异常崩溃</div><div class="line">//generateSmallPatchedDexInfoFile();</div><div class="line">        logDexesToDexMeta();</div><div class="line"></div><div class="line">        checkCrossDexMovingClasses();</div><div class="line">    &#125;</div><div class="line">======》</div><div class="line"> private void generatePatchedDexInfoFile() &#123;</div><div class="line">        for (AbstractMap.SimpleEntry&lt;File, File&gt; oldAndNewDexFilePair : oldAndNewDexFilePairList) &#123;</div><div class="line">            File oldFile = oldAndNewDexFilePair.getKey();</div><div class="line">            File newFile = oldAndNewDexFilePair.getValue();</div><div class="line">            final String dexName = getRelativeDexName(oldFile, newFile);</div><div class="line">            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);</div><div class="line">            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) &#123;</div><div class="line">//md5不同，所以需要生成dex文件</div><div class="line">                diffDexPairAndFillRelatedInfo(oldFile, newFile, relatedInfo);</div><div class="line">            &#125; else &#123;</div><div class="line">//在这种情况下，两个dex的文件是一致的，但是我们也需要将它当成一个更新的dex，这样SmallPatchGenerator才能够分析这个dex中的哪个类需要保存在small patch中</div><div class="line">                relatedInfo.newOrFullPatchedFile = newFile;</div><div class="line">                relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>一旦两个文件的md5值不同，就需要生成patch文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) &#123;</div><div class="line">        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR);</div><div class="line">        final String dexName = getRelativeDexName(oldDexFile, newDexFile);</div><div class="line"></div><div class="line">        File dexDiffOut = getOutputPath(newDexFile).toFile();</div><div class="line">        ensureDirectoryExist(dexDiffOut.getParentFile());</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">    //初始化dexPatch生成器</div><div class="line">            DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);</div><div class="line">            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);</div><div class="line"></div><div class="line">            logWriter.writeLineToInfoFile(</div><div class="line">                    String.format(</div><div class="line">                            &quot;Start diff between [%s] as old and [%s] as new:&quot;,</div><div class="line">                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),</div><div class="line">                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)</div><div class="line">                    )</div><div class="line">            );</div><div class="line">    //执行dexPatch并保存到dexDiffOut文件。</div><div class="line">            dexPatchGen.executeAndSaveTo(dexDiffOut);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new TinkerPatchException(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!dexDiffOut.exists()) &#123;</div><div class="line">            throw new TinkerPatchException(&quot;can not find the diff file:&quot; + dexDiffOut.getAbsolutePath());</div><div class="line">        &#125;</div><div class="line">//将输出文件的信息添加到relatedINfo中。</div><div class="line">        relatedInfo.dexDiffFile = dexDiffOut;</div><div class="line">        relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);</div><div class="line">        Logger.d(&quot;\nGen %s patch file:%s, size:%d, md5:%s&quot;, dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);</div><div class="line"></div><div class="line">        File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);</div><div class="line">        if (!tempFullPatchedDexFile.exists()) &#123;</div><div class="line">            ensureDirectoryExist(tempFullPatchedDexFile.getParentFile());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            new DexPatchApplier(oldDexFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);</div><div class="line"></div><div class="line">            Logger.d(</div><div class="line">                    String.format(&quot;Verifying if patched new dex is logically the same as original new dex: %s ...&quot;, getRelativeStringBy(newDexFile, config.mTempUnzipNewDir))</div><div class="line">            );</div><div class="line"></div><div class="line">            Dex origNewDex = new Dex(newDexFile);</div><div class="line">            Dex patchedNewDex = new Dex(tempFullPatchedDexFile);</div><div class="line">            //检查这个新的patch文件是否真的有更新</div><div class="line">    checkDexChange(origNewDex, patchedNewDex);</div><div class="line"></div><div class="line">            relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;</div><div class="line">            relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            throw new TinkerPatchException(</div><div class="line">                    &quot;Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.&quot;, e</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!tempFullPatchedDexFile.exists()) &#123;</div><div class="line">            throw new TinkerPatchException(&quot;can not find the temporary full patched dex file:&quot; + tempFullPatchedDexFile.getAbsolutePath());</div><div class="line">        &#125;</div><div class="line">        Logger.d(&quot;\nGen %s for dalvik full dex file:%s, size:%d, md5:%s&quot;, dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>上面的方法非常重要，我们必须要知道这个文件内每一种Patch生成器的类型。这个就是tinker计算patch的算法所在。其实也是依据dex文件的格式去生成patch。</p><ul><li>StringDataSectionDiffAlgorithm</li><li>TypeIdSectionDiffAlgorithm</li><li>ProtoIdSectionDiffAlgorithm</li><li>FieldIdSectionDiffAlgorithm</li><li>MethodIdSectionDiffAlgorithm</li><li>ClassDefSectionDiffAlgorithm</li><li>TypeListSectionDiffAlgorithm</li><li>AnnotationSetRefListSectionDiffAlgorithm</li><li>AnnotationSetSectionDiffAlgorithm</li><li>ClassDataSectionDiffAlgorithm</li><li>CodeSectionDiffAlgorithm</li><li>DebugInfoItemSectionDiffAlgorithm</li><li>StaticValueSectionDiffAlgorithm</li><li>AnnotationsDirectorySectionDiffAlgorithm</li></ul><p>这些算法都是子类的实现，他们标注了自身的类型，并且从DexCOntent中去进行对比，我们在这里选择CodeSectionDiff去分析。实际上所有的父类的实现都是一致的。DexSectionDiffAlgorithm的excute方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">public void execute() &#123;</div><div class="line">        this.patchOperationList.clear();</div><div class="line">//收集oldDex中指定格式的item</div><div class="line">        this.adjustedOldIndexedItemsWithOrigOrder = collectSectionItems(this.oldDex, true);</div><div class="line">        this.oldItemCount = this.adjustedOldIndexedItemsWithOrigOrder.length;</div><div class="line"></div><div class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedOldIndexedItems = new AbstractMap.SimpleEntry[this.oldItemCount];</div><div class="line">        System.arraycopy(this.adjustedOldIndexedItemsWithOrigOrder, 0, adjustedOldIndexedItems, 0, this.oldItemCount);</div><div class="line">        //进行排序</div><div class="line">Arrays.sort(adjustedOldIndexedItems, this.comparatorForItemDiff);</div><div class="line">//收集newDex中指定格式的item并排序</div><div class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedNewIndexedItems = collectSectionItems(this.newDex, false);</div><div class="line">        this.newItemCount = adjustedNewIndexedItems.length;</div><div class="line">        Arrays.sort(adjustedNewIndexedItems, this.comparatorForItemDiff);</div><div class="line"></div><div class="line">        int oldCursor = 0;</div><div class="line">        int newCursor = 0;</div><div class="line">     　   while (oldCursor &lt; this.oldItemCount || newCursor &lt; this.newItemCount) &#123;</div><div class="line">            if (oldCursor &gt;= this.oldItemCount) &#123;</div><div class="line">                // 表示oldDex中内容已经比较完毕了，剩下的就是newDex里面的item，此时里面的item就都是新增加的.</div><div class="line">                while (newCursor &lt; this.newItemCount) &#123;</div><div class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor++];</div><div class="line">    //将新添加的item添加的patchOperationlist中</div><div class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</div><div class="line">                &#125;</div><div class="line">            &#125; else if (newCursor &gt;= newItemCount) &#123;</div><div class="line">                // 这种情况下表示newDex的item已经比较完毕，oldDex剩余的item就是需要删除的item</div><div class="line">                while (oldCursor &lt; oldItemCount) &#123;</div><div class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor++];</div><div class="line">                    int deletedIndex = oldIndexedItem.getKey();</div><div class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</div><div class="line">                   //将删除的dex添加到patchOperationList中，并且记录偏移量 </div><div class="line">   this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</div><div class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">//两个dex中item都存在，</div><div class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor];</div><div class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor];</div><div class="line">                //比较新老item</div><div class="line">int cmpRes = oldIndexedItem.getValue().compareTo(newIndexedItem.getValue());</div><div class="line">//这个比较仅仅只是比较指针所对应的item的值，即名称的ASIC码大小，</div><div class="line">                if (cmpRes &lt; 0) &#123;</div><div class="line">    //cmp&lt;0,将old标记为del</div><div class="line">                    int deletedIndex = oldIndexedItem.getKey();</div><div class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</div><div class="line">                    this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</div><div class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</div><div class="line">                    ++oldCursor;</div><div class="line">                &#125; else</div><div class="line">                if (cmpRes &gt; 0) &#123;</div><div class="line">    //cmp&gt;0，将这个item标记为add</div><div class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</div><div class="line">                    ++newCursor;</div><div class="line">                &#125; else &#123;</div><div class="line">    //如果两个item一致，需要判断index是否一致，offset是否一致</div><div class="line">                    int oldIndex = oldIndexedItem.getKey();</div><div class="line">                    int newIndex = newIndexedItem.getKey();</div><div class="line">                    int oldOffset = getItemOffsetOrIndex(oldIndexedItem.getKey(), oldIndexedItem.getValue());</div><div class="line">                    int newOffset = getItemOffsetOrIndex(newIndexedItem.getKey(), newIndexedItem.getValue());</div><div class="line"></div><div class="line">                    if (oldIndex != newIndex) &#123;</div><div class="line">                        this.oldIndexToNewIndexMap.put(oldIndex, newIndex);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (oldOffset != newOffset) &#123;</div><div class="line">                        this.oldOffsetToNewOffsetMap.put(oldOffset, newOffset);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    ++oldCursor;</div><div class="line">                    ++newCursor;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//遍历完成之后，此时所有的diff都已经完成，现在需要判断del和add是否需要替换成replace</div><div class="line">        Collections.sort(this.patchOperationList, comparatorForPatchOperationOpt);</div><div class="line"></div><div class="line">        Iterator&lt;PatchOperation&lt;T&gt;&gt; patchOperationIt = this.patchOperationList.iterator();</div><div class="line">        PatchOperation&lt;T&gt; prevPatchOperation = null;</div><div class="line">        while (patchOperationIt.hasNext()) &#123;</div><div class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</div><div class="line">           //如果index相同，且前一个与后一个分别是del和add，那么替换成replace </div><div class="line">   if (prevPatchOperation != null</div><div class="line">                &amp;&amp; prevPatchOperation.op == PatchOperation.OP_DEL</div><div class="line">                &amp;&amp; patchOperation.op == PatchOperation.OP_ADD</div><div class="line">            ) &#123;</div><div class="line">                if (prevPatchOperation.index == patchOperation.index) &#123;</div><div class="line">                    prevPatchOperation.op = PatchOperation.OP_REPLACE;</div><div class="line">                    prevPatchOperation.newItem = patchOperation.newItem;</div><div class="line">                    patchOperationIt.remove();</div><div class="line">                    prevPatchOperation = null;</div><div class="line">                &#125; else &#123;</div><div class="line">                    prevPatchOperation = patchOperation;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                prevPatchOperation = patchOperation;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 最后记录我们的结果。</div><div class="line">        patchOperationIt = this.patchOperationList.iterator();</div><div class="line">        while (patchOperationIt.hasNext()) &#123;</div><div class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</div><div class="line">            switch (patchOperation.op) &#123;</div><div class="line">                case PatchOperation.OP_DEL: &#123;</div><div class="line">                    indexToDelOperationMap.put(patchOperation.index, patchOperation);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case PatchOperation.OP_ADD: &#123;</div><div class="line">                    indexToAddOperationMap.put(patchOperation.index, patchOperation);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case PatchOperation.OP_REPLACE: &#123;</div><div class="line">                    indexToReplaceOperationMap.put(patchOperation.index, patchOperation);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在我们生成了patch的List之后，那么需要将各个类别的patch添加到一个生成的新dex文件中。按照dex文件格式，及计算出来的各个类别的offse，进行写入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">private void writeResultToStream(OutputStream os) throws IOException &#123;</div><div class="line">        DexDataBuffer buffer = new DexDataBuffer();</div><div class="line">        buffer.write(DexPatchFile.MAGIC);</div><div class="line">        buffer.writeShort(DexPatchFile.CURRENT_VERSION);</div><div class="line">        buffer.writeInt(this.patchedDexSize);</div><div class="line">        // we will return here to write firstChunkOffset later.</div><div class="line">        int posOfFirstChunkOffsetField = buffer.position();</div><div class="line">        buffer.writeInt(0);</div><div class="line">        buffer.writeInt(this.patchedStringIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedTypeIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedProtoIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedFieldIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedMethodIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedClassDefsOffset);</div><div class="line">        buffer.writeInt(this.patchedMapListOffset);</div><div class="line">        buffer.writeInt(this.patchedTypeListsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationSetRefListItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationSetItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedClassDataItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedCodeItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedStringDataItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedDebugInfoItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedEncodedArrayItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationsDirectoryItemsOffset);</div><div class="line">        buffer.write(this.oldDex.computeSignature(false));</div><div class="line">        int firstChunkOffset = buffer.position();</div><div class="line">        buffer.position(posOfFirstChunkOffsetField);</div><div class="line">        buffer.writeInt(firstChunkOffset);</div><div class="line">        buffer.position(firstChunkOffset);</div><div class="line"></div><div class="line">        writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());</div><div class="line"></div><div class="line">        byte[] bufferData = buffer.array();</div><div class="line">        os.write(bufferData);</div><div class="line">        os.flush();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>现在patch文件已经生成，但是这个生成的仅仅只是一个临时的patch文件。名称为我们的输出目录/tempPatchedDexes,这个dex文件并不能够被传统的dex解析器解析出来，因为tinker在生成时添加的MAGIC标识为public static final byte[] MAGIC = {0x44, 0x58, 0x44, 0x49, 0x46, 0x46}，对应的dex文件内容为DXDIFF，这个是用来标识这个dex是一个diff过的dex，需要进行替换或添加。在patch进行更新的时候需要对这个MAGIC进行替换。现在回到tinkerPatch，看看tinker是如何从临时文件，生成patch成功的apk文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> protected void tinkerPatch() &#123;</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch begin-----------------------&quot;);</div><div class="line"></div><div class="line">        Logger.d(config.toString());</div><div class="line">        try &#123;</div><div class="line">            //gen patch</div><div class="line">            ApkDecoder decoder = new ApkDecoder(config);</div><div class="line">            decoder.onAllPatchesStart();</div><div class="line">            decoder.patch(config.mOldApkFile, config.mNewApkFile);</div><div class="line">            decoder.onAllPatchesEnd();</div><div class="line"></div><div class="line">            //gen meta file and version file</div><div class="line">            PatchInfo info = new PatchInfo(config);</div><div class="line">            info.gen();</div><div class="line"></div><div class="line">            //重新生成patch文件。</div><div class="line">            PatchBuilder builder = new PatchBuilder(config);</div><div class="line">            builder.buildPatch();</div><div class="line"></div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            goToError();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Logger.d(&quot;Tinker patch done, total time cost: %fs&quot;, diffTimeFromBegin());</div><div class="line">        Logger.d(&quot;Tinker patch done, you can go to file to find the output %s&quot;, config.mOutFolder);</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch end-------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=========》</div><div class="line"> public PatchBuilder(Configuration config) &#123;</div><div class="line">        this.config = config;</div><div class="line">        this.unSignedApk = new File(config.mOutFolder, PATCH_NAME + &quot;_unsigned.apk&quot;);</div><div class="line">        this.signedApk = new File(config.mOutFolder, PATCH_NAME + &quot;_signed.apk&quot;);</div><div class="line">        this.signedWith7ZipApk = new File(config.mOutFolder, PATCH_NAME + &quot;_signed_7zip.apk&quot;);</div><div class="line">        this.sevenZipOutPutDir = new File(config.mOutFolder, TypedValue.OUT_7ZIP_FILE_PATH);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">======》</div><div class="line">public void buildPatch() throws Exception &#123;</div><div class="line">....</div><div class="line">        generateUnsignedApk(unSignedApk);</div><div class="line">        signApk(unSignedApk, signedApk);</div><div class="line">        use7zApk(signedApk, signedWith7ZipApk, sevenZipOutPutDir);</div><div class="line">....</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>上面的几个apk文件名都是在tinker patch执行完毕之后会生成的几个文件。在buildPatch中，只要的过程就三个，受限生成unSignedApk，然后对生成的unsignedApk进行签名，最后对生成signedApk利用7zip压缩，生成7zip apk包。这个就是tinker生成patch的全过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#tinker接入过程&lt;br&gt;其实tinker接入对于一些第三方sdk接入来说算是一个比较复杂了。但是照着tinker团队提供的文档去实现，还是一件比较轻松的事情。&lt;/p&gt;
&lt;h2 id=&quot;gradle修改&quot;&gt;&lt;a href=&quot;#gradle修改&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android DataBinding的实现原理</title>
    <link href="https://xjlhhz.com/2017/08/13/0813DataBinding%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://xjlhhz.com/2017/08/13/0813DataBinding的实现原理/</id>
    <published>2017-08-13T05:14:00.000Z</published>
    <updated>2017-08-14T12:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>因为打算深入的了解MVVM，在了解的android的databing库的使用之后,于我来说，并没有直接去了解MVVM框架的使用，而是要了解android是如何实现databing框架的。这算是一个进步吧。我在google上基本没找到关于databinding框架的解析的。所以，只能自己阅读代码来琢磨了。</p><h1 id="自动生成文件"><a href="#自动生成文件" class="headerlink" title="自动生成文件"></a>自动生成文件</h1><p>对于dataBinding的实现，很大一部分都是由apt自动生成代码来实现的。对于写的每一个databinding的xml文件，都会生成相应的代码文件。默认是生成的代码文件为我们的xml文件的名称。比如我们的activity_main.xml的文件会生成ActivityMainBinding.java文件。当然我们也能够在layout中的data字段添加class，那么生成的类就是我们指定的class字段对应的name了。</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>下面的一个非常简单的dataBinding的xml文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</div><div class="line">    &lt;data class=&quot;MyFragmentS&quot;&gt;</div><div class="line">        &lt;variable</div><div class="line">            name=&quot;fvm&quot;</div><div class="line">            type=&quot;com.example.xie.myapplication.FragmentViewModel&quot;/&gt;</div><div class="line">    &lt;/data&gt;</div><div class="line">    &lt;RelativeLayout</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:background=&quot;@color/colorPrimary&quot;&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:id=&quot;@+id/text1&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:textColor=&quot;@color/colorAccent&quot;</div><div class="line">            android:clickable=&quot;true&quot;</div><div class="line">            android:layout_centerInParent=&quot;true&quot;</div><div class="line">            android:text=&quot;@&#123;fvm.known&#125;&quot;</div><div class="line">            android:onClick=&quot;@&#123;fvm::clicks&#125;&quot;/&gt;</div><div class="line">        &lt;TextView</div><div class="line">            android:layout_below=&quot;@+id/text1&quot;</div><div class="line">            android:text=&quot;11111&quot;</div><div class="line">            android:onClick=&quot;@&#123;fvm::clicks2&#125;&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line">    &lt;/RelativeLayout&gt;</div><div class="line">&lt;/layout&gt;</div></pre></td></tr></table></figure><br>在这个xml文件里面，我们指定了生成的class名称为MyFragmentS，并且引入了一个变量FragmentViewModel，然后在两个TextView上添加了onClick事件。这两个onclick事件都是在引入的变量里面声明了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class FragmentViewModel &#123;</div><div class="line">    public ObservableField&lt;String&gt; known = new ObservableField&lt;&gt;(&quot;我已经添加进来了&quot;);</div><div class="line"></div><div class="line">    private Context context;</div><div class="line">    public FragmentViewModel(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clicks(View view) &#123;</div><div class="line">        Toast.makeText(context, &quot;我哈哈哈哈，点击事件触发了&quot;, Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void clicks2(View view) &#123;</div><div class="line">        Toast.makeText(context, &quot;我哈哈哈哈，点击事件触发了&quot;, Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来我们来看看生成的代码文件，也就是MyFragmentS类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div></pre></td><td class="code"><pre><div class="line">public class MyFragmentS extends android.databinding.ViewDataBinding  &#123;</div><div class="line">    ...</div><div class="line">    // 这几个View就是我们layout中定义的所有View，都会在构造函数中初始化</div><div class="line">    private final android.widget.RelativeLayout mboundView0;</div><div class="line">    private final android.widget.TextView mboundView2;</div><div class="line">    public final android.widget.TextView text1;</div><div class="line">    //我们在layout中引入的参数类 </div><div class="line">    private com.example.xie.myapplication.FragmentViewModel mFvm;</div><div class="line">    // values</div><div class="line">    // 对于添加的每一个onclick事件处理都会生成一个OnClickListenerImpl,按序排列</div><div class="line">    private OnClickListenerImpl mFvmClicks2AndroidViewViewOnClickListener;</div><div class="line">    private OnClickListenerImpl1 mFvmClicksAndroidViewViewOnClickListener;</div><div class="line">    // Inverse Binding Event Handlers</div><div class="line"></div><div class="line">    //构造函数中，初始化View</div><div class="line">    public MyFragmentS(android.databinding.DataBindingComponent bindingComponent, View root) &#123;</div><div class="line">        super(bindingComponent, root, 1);</div><div class="line">        final Object[] bindings = mapBindings(bindingComponent, root, 3, sIncludes, sViewsWithIds);</div><div class="line">        this.mboundView0 = (android.widget.RelativeLayout) bindings[0];</div><div class="line">        this.mboundView0.setTag(null);</div><div class="line">        this.mboundView2 = (android.widget.TextView) bindings[2];</div><div class="line">        this.mboundView2.setTag(null);</div><div class="line">        this.text1 = (android.widget.TextView) bindings[1];</div><div class="line">        this.text1.setTag(null);</div><div class="line">        setRootTag(root);</div><div class="line">        invalidateAll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //重新绘制整个页面</div><div class="line">    @Override</div><div class="line">    public void invalidateAll() &#123;</div><div class="line">        synchronized(this) &#123;</div><div class="line">                mDirtyFlags = 0x4L;</div><div class="line">        &#125;</div><div class="line">        requestRebind();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //是否有脏数据</div><div class="line">    @Override</div><div class="line">    public boolean hasPendingBindings() &#123;</div><div class="line">        synchronized(this) &#123;</div><div class="line">            if (mDirtyFlags != 0) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //setVariable函数，通过参数对象和参数id进行匹配设置</div><div class="line">    public boolean setVariable(int variableId, Object variable) &#123;</div><div class="line">        switch(variableId) &#123;</div><div class="line">            case BR.fvm :</div><div class="line">                setFvm((com.example.xie.myapplication.FragmentViewModel) variable);</div><div class="line">                return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //设置参数对象，这个方法必须要进行调用，才能进行绑定</div><div class="line">    public void setFvm(com.example.xie.myapplication.FragmentViewModel Fvm) &#123;</div><div class="line">        this.mFvm = Fvm;</div><div class="line">        synchronized(this) &#123;</div><div class="line">            mDirtyFlags |= 0x2L;</div><div class="line">        &#125;</div><div class="line">        //通知BR的fvm属性发生了改变</div><div class="line">        notifyPropertyChanged(BR.fvm);</div><div class="line">        super.requestRebind();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //通过fieldId来更新属性字段</div><div class="line">    @Override</div><div class="line">    protected boolean onFieldChange(int localFieldId, Object object, int fieldId) &#123;</div><div class="line">        switch (localFieldId) &#123;</div><div class="line">            case 0 :</div><div class="line">                return onChangeFvmKnown((android.databinding.ObservableField&lt;java.lang.String&gt;) object, fieldId);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private boolean onChangeFvmKnown(android.databinding.ObservableField&lt;java.lang.String&gt; FvmKnown, int fieldId) &#123;</div><div class="line">        switch (fieldId) &#123;</div><div class="line">            case BR._all: &#123;</div><div class="line">                synchronized(this) &#123;</div><div class="line">                        mDirtyFlags |= 0x1L;</div><div class="line">                &#125;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //执行数据绑定</div><div class="line">    @Override</div><div class="line">    protected void executeBindings() &#123;</div><div class="line">        long dirtyFlags = 0;</div><div class="line">        synchronized(this) &#123;</div><div class="line">            dirtyFlags = mDirtyFlags;</div><div class="line">            mDirtyFlags = 0;</div><div class="line">        &#125;</div><div class="line">        android.view.View.OnClickListener fvmClicks2AndroidViewViewOnClickListener = null;</div><div class="line">        android.databinding.ObservableField&lt;java.lang.String&gt; fvmKnown = null;</div><div class="line">        java.lang.String fvmKnownGet = null;</div><div class="line">        android.view.View.OnClickListener fvmClicksAndroidViewViewOnClickListener = null;</div><div class="line">        com.example.xie.myapplication.FragmentViewModel fvm = mFvm;</div><div class="line"></div><div class="line">        if ((dirtyFlags &amp; 0x7L) != 0) &#123;</div><div class="line"></div><div class="line"></div><div class="line">            if ((dirtyFlags &amp; 0x6L) != 0) &#123;</div><div class="line"></div><div class="line">                    if (fvm != null) &#123;</div><div class="line">                        //绑定click2事件</div><div class="line">                        fvmClicks2AndroidViewViewOnClickListener = (((mFvmClicks2AndroidViewViewOnClickListener == null) ? (mFvmClicks2AndroidViewViewOnClickListener = new OnClickListenerImpl()) : mFvmClicks2AndroidViewViewOnClickListener).setValue(fvm));</div><div class="line">                        //绑定clicks事件</div><div class="line">                        fvmClicksAndroidViewViewOnClickListener = (((mFvmClicksAndroidViewViewOnClickListener == null) ? (mFvmClicksAndroidViewViewOnClickListener = new OnClickListenerImpl1()) : mFvmClicksAndroidViewViewOnClickListener).setValue(fvm));</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">                if (fvm != null) &#123;</div><div class="line">                    //绑定known字段</div><div class="line">                    fvmKnown = fvm.known;</div><div class="line">                &#125;</div><div class="line">                //更新字段监听</div><div class="line">                updateRegistration(0, fvmKnown);</div><div class="line"></div><div class="line"></div><div class="line">                if (fvmKnown != null) &#123;</div><div class="line">                    // read fvm.known.get()</div><div class="line">                    fvmKnownGet = fvmKnown.get();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        // batch finished</div><div class="line">        if ((dirtyFlags &amp; 0x6L) != 0) &#123;</div><div class="line">    //设置click事件监听</div><div class="line">            this.mboundView2.setOnClickListener(fvmClicks2AndroidViewViewOnClickListener);</div><div class="line">            this.text1.setOnClickListener(fvmClicksAndroidViewViewOnClickListener);</div><div class="line">        &#125;</div><div class="line">        if ((dirtyFlags &amp; 0x7L) != 0) &#123;</div><div class="line">            //设置text1的值</div><div class="line">            android.databinding.adapters.TextViewBindingAdapter.setText(this.text1, fvmKnownGet);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //设置每一个onclick都对应到一个onClickLIstenerImpl,通过View与click方法相互对应</div><div class="line">    public static class OnClickListenerImpl implements android.view.View.OnClickListener&#123;</div><div class="line">        private com.example.xie.myapplication.FragmentViewModel value;</div><div class="line">        public OnClickListenerImpl setValue(com.example.xie.myapplication.FragmentViewModel value) &#123;</div><div class="line">            this.value = value;</div><div class="line">            return value == null ? null : this;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onClick(android.view.View arg0) &#123;</div><div class="line">            this.value.clicks2(arg0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static class OnClickListenerImpl1 implements android.view.View.OnClickListener&#123;</div><div class="line">        private com.example.xie.myapplication.FragmentViewModel value;</div><div class="line">        public OnClickListenerImpl1 setValue(com.example.xie.myapplication.FragmentViewModel value) &#123;</div><div class="line">            this.value = value;</div><div class="line">            return value == null ? null : this;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void onClick(android.view.View arg0) &#123;</div><div class="line">            this.value.clicks(arg0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    private  long mDirtyFlags = 0xffffffffffffffffL;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    //下面的是关于View的初始化</div><div class="line">    public static MyFragmentS inflate(android.view.LayoutInflater inflater, android.view.ViewGroup root, boolean attachToRoot) &#123;</div><div class="line">        return inflate(inflater, root, attachToRoot, android.databinding.DataBindingUtil.getDefaultComponent());</div><div class="line">    &#125;</div><div class="line">    public static MyFragmentS inflate(android.view.LayoutInflater inflater, android.view.ViewGroup root, boolean attachToRoot, android.databinding.DataBindingComponent bindingComponent) &#123;</div><div class="line">        return android.databinding.DataBindingUtil.&lt;MyFragmentS&gt;inflate(inflater, com.example.xie.myapplication.R.layout.my_fragment, root, attachToRoot, bindingComponent);</div><div class="line">    &#125;</div><div class="line">    public static MyFragmentS inflate(android.view.LayoutInflater inflater) &#123;</div><div class="line">        return inflate(inflater, android.databinding.DataBindingUtil.getDefaultComponent());</div><div class="line">    &#125;</div><div class="line">    public static MyFragmentS inflate(android.view.LayoutInflater inflater, android.databinding.DataBindingComponent bindingComponent) &#123;</div><div class="line">        return bind(inflater.inflate(com.example.xie.myapplication.R.layout.my_fragment, null, false), bindingComponent);</div><div class="line">    &#125;</div><div class="line">    public static MyFragmentS bind(android.view.View view) &#123;</div><div class="line">        return bind(view, android.databinding.DataBindingUtil.getDefaultComponent());</div><div class="line">    &#125;</div><div class="line">    public static MyFragmentS bind(android.view.View view, android.databinding.DataBindingComponent bindingComponent) &#123;</div><div class="line">        if (!&quot;layout/my_fragment_0&quot;.equals(view.getTag())) &#123;</div><div class="line">            throw new RuntimeException(&quot;view tag isn&apos;t correct on view:&quot; + view.getTag());</div><div class="line">        &#125;</div><div class="line">        return new MyFragmentS(bindingComponent, view);</div><div class="line">    &#125;</div><div class="line">    /* flag mapping</div><div class="line">        flag 0 (0x1L): fvm.known</div><div class="line">        flag 1 (0x2L): fvm</div><div class="line">        flag 2 (0x3L): null</div><div class="line">    flag mapping end*/</div><div class="line">    //end</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h1><p>现在我们详细的来看看它是怎么相互对应的。我们从绑定View的地方看起。</p><p>在绑定View是通过DataBindingutil.bind来绑定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> MyFragmentS binding = DataBindingUtil.bind(view);</div><div class="line">=========&gt;</div><div class="line"></div><div class="line"> public static &lt;T extends ViewDataBinding&gt; T bind(View root) &#123;</div><div class="line">        return bind(root, sDefaultComponent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=======&gt;</div><div class="line"> public static &lt;T extends ViewDataBinding&gt; T bind(View root,</div><div class="line">            DataBindingComponent bindingComponent) &#123;</div><div class="line">        //获取当前的View是否已经绑定过了，绑定过后tag类型将会是ViewDataBinding类型，如果没绑定，则返回null</div><div class="line">        T binding = getBinding(root);</div><div class="line">//绑定过，那么直接返回</div><div class="line">        if (binding != null) &#123;</div><div class="line">            return binding;</div><div class="line">        &#125;</div><div class="line">        //如果没绑定过，那么tag类型是String的，</div><div class="line">        Object tagObj = root.getTag();</div><div class="line">        if (!(tagObj instanceof String)) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">            String tag = (String) tagObj;</div><div class="line">            //通过smapper获取tag对应的layoutid</div><div class="line">            int layoutId = sMapper.getLayoutId(tag);</div><div class="line">            if (layoutId == 0) &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;View is not a binding layout&quot;);</div><div class="line">            &#125;</div><div class="line">            return (T) sMapper.getDataBinder(bindingComponent, root, layoutId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在这个bind方法里面，我们需要注意到sMapper的获取layoutId的方法和个获取binding的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">int getLayoutId(String tag) &#123;</div><div class="line">        if (tag == null) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        //计算hashCode值，匹配对应layout</div><div class="line">        final int code = tag.hashCode();</div><div class="line">//对于dataBinding的每一个layout的，都会通过tag计算hash值进行保存。</div><div class="line">        switch(code) &#123;</div><div class="line">            case 423753077: &#123;</div><div class="line">                if(tag.equals(&quot;layout/activity_main_0&quot;)) &#123;</div><div class="line">                    return com.example.xie.myapplication.R.layout.activity_main;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case 22154319: &#123;</div><div class="line">                if(tag.equals(&quot;layout/my_fragment_0&quot;)) &#123;</div><div class="line">                    return com.example.xie.myapplication.R.layout.my_fragment;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在获取到了对应的layout之后，就需要通过getDataBinder方法调用到生成类的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public android.databinding.ViewDataBinding getDataBinder(android.databinding.DataBindingComponent bindingComponent, android.view.View view, int layoutId) &#123;</div><div class="line">        switch(layoutId) &#123;</div><div class="line">                case com.example.xie.myapplication.R.layout.activity_main:</div><div class="line">                    return com.example.xie.myapplication.databinding.ActivityMainBinding.bind(view, bindingComponent);</div><div class="line">                case com.example.xie.myapplication.R.layout.my_fragment:</div><div class="line">    //匹配到这个layoutid，并进行调用其band方法</div><div class="line">                    return com.example.xie.myapplication.databinding.MyFragmentS.bind(view, bindingComponent);</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">===========&gt;</div><div class="line"></div><div class="line">public static MyFragmentS bind(android.view.View view, android.databinding.DataBindingComponent bindingComponent) &#123;</div><div class="line">        if (!&quot;layout/my_fragment_0&quot;.equals(view.getTag())) &#123;</div><div class="line">            throw new RuntimeException(&quot;view tag isn&apos;t correct on view:&quot; + view.getTag());</div><div class="line">        &#125;</div><div class="line">        //调用到该生成类的构造方法</div><div class="line">        return new MyFragmentS(bindingComponent, view);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在构造方法里面进行一些初始化的相关操作，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public MyFragmentS(android.databinding.DataBindingComponent bindingComponent, View root) &#123;</div><div class="line">        super(bindingComponent, root, 1);</div><div class="line">        final Object[] bindings = mapBindings(bindingComponent, root, 3, sIncludes, sViewsWithIds);</div><div class="line">        this.mboundView0 = (android.widget.RelativeLayout) bindings[0];</div><div class="line">        this.mboundView0.setTag(null);</div><div class="line">        this.mboundView2 = (android.widget.TextView) bindings[2];</div><div class="line">        this.mboundView2.setTag(null);</div><div class="line">        this.text1 = (android.widget.TextView) bindings[1];</div><div class="line">        this.text1.setTag(null);</div><div class="line">        //如果layout绑定过后，将会setTag，标识已经绑定过了</div><div class="line">        setRootTag(root);</div><div class="line">        invalidateAll();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在这个构造方法里面，我们必须先了解父类构造方法做的处理,也就是ViewDataBinding的处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">protected ViewDataBinding(DataBindingComponent bindingComponent, View root, int localFieldCount) &#123;</div><div class="line">        mBindingComponent = bindingComponent;</div><div class="line">        //localFieldCount表示需要监听的field数目</div><div class="line">        mLocalFieldObservers = new WeakListener[localFieldCount];</div><div class="line">        this.mRoot = root;</div><div class="line">        //方法的调用必须在主线程中</div><div class="line">        if (Looper.myLooper() == null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;DataBinding must be created in view&apos;s UI Thread&quot;);</div><div class="line">        &#125;</div><div class="line">//判断是否使用choreographer，通过垂直同步信号刷新Ui</div><div class="line">        if (USE_CHOREOGRAPHER) &#123;</div><div class="line">            mChoreographer = Choreographer.getInstance();</div><div class="line">            mFrameCallback = new Choreographer.FrameCallback() &#123;</div><div class="line">                @Override</div><div class="line">                public void doFrame(long frameTimeNanos) &#123;</div><div class="line">    //直接通过doFrame回调，执行run方法</div><div class="line">                    mRebindRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFrameCallback = null;</div><div class="line">    //将会通过UIHreadHandle调用post runable </div><div class="line">            mUIThreadHandler = new Handler(Looper.myLooper());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>下面来看看run方法的执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">private final Runnable mRebindRunnable = new Runnable() &#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            synchronized (this) &#123;</div><div class="line">                mPendingRebind = false;</div><div class="line">            &#125;</div><div class="line">            processReferenceQueue();</div><div class="line"></div><div class="line">            if (VERSION.SDK_INT &gt;= VERSION_CODES.KITKAT) &#123;</div><div class="line">                if (!mRoot.isAttachedToWindow()) &#123;</div><div class="line">                    mRoot.removeOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);</div><div class="line">                    mRoot.addOnAttachStateChangeListener(ROOT_REATTACHED_LISTENER);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            executePendingBindings();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p><p>在这里，最重要的就是最底下的这个方法executePendingBindings,执行数据绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public void executePendingBindings() &#123;</div><div class="line">//内部是否包含viewBinding，也就是绑定嵌套</div><div class="line">        if (mContainingBinding == null) &#123;</div><div class="line">            executeBindingsInternal();</div><div class="line">        &#125; else &#123;</div><div class="line">            mContainingBinding.executePendingBindings();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=============&gt;</div><div class="line"></div><div class="line">private void executeBindingsInternal() &#123;</div><div class="line">//是否正在执行binding操作。</div><div class="line">        if (mIsExecutingPendingBindings) &#123;</div><div class="line">            requestRebind();</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">//是否需要重新绑定，判断是否存在脏数据</div><div class="line">        if (!hasPendingBindings()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        mIsExecutingPendingBindings = true;</div><div class="line">        mRebindHalted = false;</div><div class="line">        if (mRebindCallbacks != null) &#123;</div><div class="line">            mRebindCallbacks.notifyCallbacks(this, REBIND, null);</div><div class="line"></div><div class="line">            // The onRebindListeners will change mPendingHalted</div><div class="line">            if (mRebindHalted) &#123;</div><div class="line">                mRebindCallbacks.notifyCallbacks(this, HALTED, null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!mRebindHalted) &#123;</div><div class="line">    //excuteBindings这个方法是在子类实现的，父类做完相应的判断之后，开始由子类执行绑定操作。</div><div class="line">            executeBindings();</div><div class="line">            if (mRebindCallbacks != null) &#123;</div><div class="line">                mRebindCallbacks.notifyCallbacks(this, REBOUND, null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mIsExecutingPendingBindings = false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>对于每一个子类的bingding操作都是不一样的，和自身layout中的view密切相关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">protected void executeBindings() &#123;</div><div class="line">        long dirtyFlags = 0;</div><div class="line">        synchronized(this) &#123;</div><div class="line">            dirtyFlags = mDirtyFlags;</div><div class="line">            mDirtyFlags = 0;</div><div class="line">        &#125;</div><div class="line">//初始化listener和参数</div><div class="line">        android.view.View.OnClickListener fvmClicks2AndroidViewViewOnClickListener = null;</div><div class="line">        android.databinding.ObservableField&lt;java.lang.String&gt; fvmKnown = null;</div><div class="line">        java.lang.String fvmKnownGet = null;</div><div class="line">        android.view.View.OnClickListener fvmClicksAndroidViewViewOnClickListener = null;</div><div class="line">        com.example.xie.myapplication.FragmentViewModel fvm = mFvm;</div><div class="line"></div><div class="line">        if ((dirtyFlags &amp; 0x7L) != 0) &#123;</div><div class="line"></div><div class="line"></div><div class="line">            if ((dirtyFlags &amp; 0x6L) != 0) &#123;</div><div class="line"></div><div class="line">                    if (fvm != null) &#123;</div><div class="line">                        // 为click2设置对应的执行方法所在的类。</div><div class="line">                        fvmClicks2AndroidViewViewOnClickListener = (((mFvmClicks2AndroidViewViewOnClickListener == null) ? (mFvmClicks2AndroidViewViewOnClickListener = new OnClickListenerImpl()) : mFvmClicks2AndroidViewViewOnClickListener).setValue(fvm));</div><div class="line">                        // 为clicks设置对应的执行方法所在的类</div><div class="line">                        fvmClicksAndroidViewViewOnClickListener = (((mFvmClicksAndroidViewViewOnClickListener == null) ? (mFvmClicksAndroidViewViewOnClickListener = new OnClickListenerImpl1()) : mFvmClicksAndroidViewViewOnClickListener).setValue(fvm));</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">                if (fvm != null) &#123;</div><div class="line">                    fvmKnown = fvm.known;</div><div class="line">                &#125;</div><div class="line">                updateRegistration(0, fvmKnown);</div><div class="line"></div><div class="line"></div><div class="line">                if (fvmKnown != null) &#123;</div><div class="line">                    //真正用于设置textView的参数</div><div class="line">                    fvmKnownGet = fvmKnown.get();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        if ((dirtyFlags &amp; 0x6L) != 0) &#123;</div><div class="line">    //对相应的View设置listener</div><div class="line">            this.mboundView2.setOnClickListener(fvmClicks2AndroidViewViewOnClickListener);</div><div class="line">            this.text1.setOnClickListener(fvmClicksAndroidViewViewOnClickListener);</div><div class="line">        &#125;</div><div class="line">        if ((dirtyFlags &amp; 0x7L) != 0) &#123;</div><div class="line">    //通过textViewBindingAdapter设置</div><div class="line">            android.databinding.adapters.TextViewBindingAdapter.setText(this.text1, fvmKnownGet);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>dataBinding对于每一个控件都对应了一个BindingAdapter.这样就是实现了绑定。绑定数据与监听。下面继续构造函数里的内容。在父类构造函数执行完毕之后，会调用mapBindings来初始化layout节点。然后子函数针对于序号与bindings数组的数据相互对应。<br>对于监听字段的改变，在excuteBindings有一个方法，updateRegistration(0, fvmKnown),这个方法就是注册监听的入口了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">protected boolean updateRegistration(int localFieldId, Observable observable) &#123;</div><div class="line">//对于这个每一个设置observable的字段都有对应的一个id，CREATE_PROPERTY_LISTENER会创建一个关于这个监听字段的监听。</div><div class="line">        return updateRegistration(localFieldId, observable, CREATE_PROPERTY_LISTENER);</div><div class="line">    &#125;</div><div class="line">========&gt;CREATE_PROPERTY_LISTENER下面这个是监听器：</div><div class="line">private static class WeakPropertyListener extends Observable.OnPropertyChangedCallback</div><div class="line">            implements ObservableReference&lt;Observable&gt; &#123;</div><div class="line">        final WeakListener&lt;Observable&gt; mListener;</div><div class="line"></div><div class="line">        public WeakPropertyListener(ViewDataBinding binder, int localFieldId) &#123;</div><div class="line">            mListener = new WeakListener&lt;Observable&gt;(binder, localFieldId, this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public WeakListener&lt;Observable&gt; getListener() &#123;</div><div class="line">            return mListener;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void addListener(Observable target) &#123;</div><div class="line">            target.addOnPropertyChangedCallback(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void removeListener(Observable target) &#123;</div><div class="line">            target.removeOnPropertyChangedCallback(this);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//接收prepertyChange的回调</div><div class="line">        @Override</div><div class="line">        public void onPropertyChanged(Observable sender, int propertyId) &#123;</div><div class="line">            ViewDataBinding binder = mListener.getBinder();</div><div class="line">            if (binder == null) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            Observable obj = mListener.getTarget();</div><div class="line">            if (obj != sender) &#123;</div><div class="line">                return; // notification from the wrong object?</div><div class="line">            &#125;</div><div class="line">    //处理字段改变的的事件，通常会重新绑定。</div><div class="line">            binder.handleFieldChange(mListener.mLocalFieldId, sender, propertyId);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>当设置ObservableField或者利用Bindable注解修饰字段时,假如说字段发生了改变，前者需要会自动调用notifyChange，后者需要我们手动调用notifyPropertyChange。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//ObservableField</div><div class="line">public void set(T value) &#123;</div><div class="line">        if (value != mValue) &#123;</div><div class="line">            mValue = value;</div><div class="line">            notifyChange();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//Bindable</div><div class="line"></div><div class="line">@Bindable</div><div class="line">    public String getTest() &#123;</div><div class="line">        return this.test;</div><div class="line">    &#125;</div><div class="line">    public void setTest(String test) &#123;</div><div class="line">        this.test = test;</div><div class="line">        notifyPropertyChanged(BR.test);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>对于设置的bindingAdapter，将会在excuteBinding中执行自定义方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//xml</div><div class="line">&lt;TextView</div><div class="line">            android:layout_below=&quot;@+id/text1&quot;</div><div class="line">            app:texts=&quot;@&#123;fvm.known&#125;&quot;</div><div class="line">            android:textColor=&quot;@color/colorAccent&quot;</div><div class="line">            android:onClick=&quot;@&#123;fvm::clicks2&#125;&quot;</div><div class="line">            android:layout_width=&quot;wrap_content&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot; /&gt;</div><div class="line"></div><div class="line">//DataUtils</div><div class="line"> @BindingAdapter(&#123;&quot;texts&quot;&#125;)</div><div class="line">    public static void setAppTextss(TextView view, String textss) &#123;</div><div class="line">        Log.d(&quot;BindingAdapter&quot;, &quot;textView&quot;);</div><div class="line">        view.setText(textss);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//自动生成</div><div class="line">com.example.xie.myapplication.DataUtils.setAppTextss(this.mboundView2, fvmKnownGet);</div></pre></td></tr></table></figure><br>自定义的Adapter必须与可变数据进行绑定，才能进行监听。否则不能起作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;因为打算深入的了解MVVM，在了解的android的databing库的使用之后,于我来说，并没有直接去了解MVVM框架的使用，而是要了解a
      
    
    </summary>
    
    
  </entry>
  
</feed>
