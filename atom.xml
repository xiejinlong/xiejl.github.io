<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉迷学习却日渐发福</title>
  
  <subtitle>我会笑着迎接每一天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xjlhhz.com/"/>
  <updated>2020-04-17T14:00:32.710Z</updated>
  <id>https://xjlhhz.com/</id>
  
  <author>
    <name>phiCoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://xjlhhz.com/2020/04/17/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://xjlhhz.com/2020/04/17/git相关问题解决/</id>
    <published>2020-04-17T13:58:20.232Z</published>
    <updated>2020-04-17T14:00:32.710Z</updated>
    
    <content type="html"><![CDATA[<p>title: git相关问题解决<br>date: 2020-04-16 13:14:00<br>tags:<br>—﻿</p><p>#git相关问题解决</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着开发迭代，整个代码仓库越来越大，git操作越来越慢，大大影响的整个开发节奏，想要解决这一个问题。在解决这一个问题前，需要对下面这几个问题有答案。</p><ul><li>git 操作是怎么运行的？</li><li>git是怎么存储的？</li><li>为什么随着开发迭代，会越来越慢？慢在哪里？</li></ul><h2 id="git是怎么运行的？"><a href="#git是怎么运行的？" class="headerlink" title="git是怎么运行的？"></a>git是怎么运行的？</h2><p>git从根本上来讲，是一个内容寻址系统。意味着Git的核心部分是一个简单的键值对数据库（key-value data store）。 你可以向 Git仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。 它分为底层命令和上层命令，上层命令就是我们熟悉的git命令，底层命令是指能在各个系统执行的底层命令，通过上层命令的调用，连接到底层命令，才能够真正执行， 比如再Unix系统上，主要是通过一系列script来实现的。比如说，<br>git add命令就对应了git-add-script<br>git commit命令就对应了git-commit-script</p><p>这些命令的初始化时机在我们执行了git init操作之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ls -F1</div><div class="line">config</div><div class="line">description</div><div class="line">HEAD</div><div class="line">hooks/</div><div class="line">info/</div><div class="line">objects/</div><div class="line">refs/</div></pre></td></tr></table></figure></p><p>description：作为gitWeb使用的，无需关心<br>config：git配置<br>info：全局排除的文件，比如写入.gitigonore里面的<br>hooks：放置服务端和客户端的钩子文件<br>//比较重要的几个<br>HEAD：指向被检测出来的分支<br>refs：目录存储数据的提交对象的指针（分支、标签和仓库）<br>objects：存储数据所有数据内容<br>index：保存暂存区信息</p><h3 id="objects"><a href="#objects" class="headerlink" title="objects"></a>objects</h3><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>解决文件存储问题，<br>1.Blob对象： 包含图片、源文件、二进制大对象等文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find .git/objects -type f</div><div class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</div></pre></td></tr></table></figure></p><h4 id="Tree对象"><a href="#Tree对象" class="headerlink" title="Tree对象"></a>Tree对象</h4><p>解决文件名保存问题，类似Unix系统的目录结构。存储指向blob对象的指针和指向tree对象的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git cat-file -p master^&#123;tree&#125;</div><div class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README</div><div class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile</div><div class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</div></pre></td></tr></table></figure></p><h4 id="commit对象"><a href="#commit对象" class="headerlink" title="commit对象"></a>commit对象</h4><p>一个commit的对象的生成需要有Tree对象的引用和父级的Commit对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;second commit&apos; | git commit-tree 0155eb -p fdf4fc3</div><div class="line">cac0cab538b970a37ea1e769cbbde608743bc96d</div><div class="line">$ echo &apos;third commit&apos;  | git commit-tree 3c4e9c -p cac0cab</div><div class="line">1a410efbd13591db07496601ebc7a059dd55cfe9</div></pre></td></tr></table></figure></p><p>如何存储git对象呢：</p><ul><li>读取文件内容，添加一段特殊标记到头部，得到新的内容，记为 content</li><li>计算这个content的SHA-1值</li><li>通过 zlib 压缩内容</li><li>通过SHA-1值的前两个字符作为目录，后38个字符作为文件名</li></ul><p>所有的 Git 对象均以这种方式存储，区别仅在于类型标识——另两种对象类型的头部信息以字符串“commit”或“tree”开头，而不是“blob”。 另外，虽然数据对象的内容几乎可以是任何东西，但提交对象和树对象的内容却有各自固定的格式。</p><p>结合3种对象，我们可以知道commit引用tree对象，tree对象引用tree和blob对象，这样就能记录所有的变更。</p><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>refs里面记录着git引用，这基本就是 Git分支的本质：一个指向某一系列提交之首的指针或引用。</p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>当你执行 git branch <branch> 时，Git 如何知道最新提交的 SHA-1 值呢？ 答案是 HEAD 文件。<br>head文件通常存放着一个符号引用，指向目前所在的分支，所谓符号引用，表示它是一个指向其他引用的指针。<br>在某些罕见的情况下，HEAD 文件可能会包含一个 git 对象的 SHA-1 值。 当你在检出一个标签、提交或远程分支，让你的仓库变成 “分离 HEAD”状态时，就会出现这种情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat .git/HEAD</div><div class="line">ref: refs/heads/master</div></pre></td></tr></table></figure></branch></p><h4 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h4><p> 标签对象（tag object） 非常类似于一个提交对象——它包含一个标签创建者信息、一个日期、一段注释信息，以及一个指针。 主要的区别在于，标签对象通常指向一个提交对象，而不是一个树对象。 它像是一个永不移动的分支引用——永远指向同一个提交对象，只不过给这个提交对象加上一个更友好的名字罢了。</p><h4 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h4><p>智能传输协议：<br>它可以读取本地数据，理解客户端有什么和需要什么，并为它生成合适的包文件。 总共有两组进程用于传输数据，它们分别负责上传和下载数据。</p><h5 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h5><p>为了上传数据至远端，Git 使用 send-pack 和 receive-pack 进程。 运行在客户端上的 send-pack 进程连接到远端运行的 receive-pack 进程。<br>协商完传输数据，再发起请求上传。</p><h5 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h5><p>当你在下载数据时， fetch-pack 和 upload-pack 进程就起作用了。 客户端启动 fetch-pack 进程，连接至远端的 upload-pack 进程，以协商后续传输的数据。协商完传输数据，再发起请求下载。</p><h4 id="git包"><a href="#git包" class="headerlink" title="git包"></a>git包</h4><p>在不执行优化的情况下，如果我们提交了一个10M大文件，那么将会在object内部增加一个blob对象，这个对象将会是经过zlib压缩的对象。一旦我们再次对该文件修改，并且add之后，将会再一次的生成hash值不同的一个blob对象，也就是说，当前的object大小将近有20M。</p><h5 id="git-gc"><a href="#git-gc" class="headerlink" title="git gc"></a>git gc</h5><p>1.收集所有松散对象并将它们放置到包文件中， 2.将多个包文件合并为一个大的包文件<br>3.移除与任何提交都不相关的陈旧对象<br>4.打包引用到一个单独的文件</p><p>如果你在这个时候更新引用，Git 并不会修改这个文件，而是向 refs/heads 创建一个新的文件。 为了获得指定引用的正确 SHA-1 值，Git 会首先在 refs 目录中查找指定的引用，然后再到 packed-refs 文件中查找。 所以，如果你在 refs 目录中找不到一个引用，那么它或许在 packed-refs 文件中。</p><p>Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 当版本库中有太多的松散对象，或者你手动执行 git gc命令，或者你向远程服务器执行推送时，Git 都会这样做。 要看到打包过程，你可以手动执行 git gc 命令让 Git 对对象进行打包<br>这个时候再查看 objects 目录，你会发现大部分的对象都不见了，与此同时出现了一对新文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ find .git/objects -type f</div><div class="line">.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37</div><div class="line">.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</div><div class="line">.git/objects/info/packs</div><div class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx</div><div class="line">.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</div></pre></td></tr></table></figure></p><p>Git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容.<br>通常来说，最新的数据会以全量的数据保存，而老版本以差异方式保存。因为大部分情况下，我们都只会使用最新的数据。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><h4 id="分支数过多"><a href="#分支数过多" class="headerlink" title="分支数过多"></a>分支数过多</h4><p>在开发迭代中，我们每一个feature都可能是一个单独的分支，导致随着迭代周期，分支数越来越多。主要影响点在于：</p><ul><li>上传和下载的过程中，需要去计算分支的更新，涉及到heads目录的遍历</li><li>如果有有些分支没有合入主分支，并且这个分支已经废弃了，不再维护，那么在这个分支上新增的文件，commit信息，tree信息，都会一直存储在远端仓库，导致每次推拉都要再次计算这些数据。<h5 id="objects数据量变大"><a href="#objects数据量变大" class="headerlink" title="objects数据量变大"></a>objects数据量变大</h5>在多次开发迭代之后，没有进行gc操作进行优化，导致重复数据比较多，整个objects目录越来越大。计算越来越耗时。</li></ul><h3 id="解决流程"><a href="#解决流程" class="headerlink" title="解决流程"></a>解决流程</h3><ol><li>删除无用分支<br>规则：删除各个分支上，最新的commit信息更新时间大于距离现在超过60的分支。<br>步骤：<br>1.获取出当前远端所有分支<br>2.遍历所有远端分支，计算当前最新commit的更新时间<br>3.跟当前时间间隔大雨60天的，执行打tag，并且删除操作</li></ol><p>2.执行git仓库的gc操作<br>执行： 登录到远端git仓库，执行git gc，删除无用commit和没有引用的object</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: git相关问题解决&lt;br&gt;date: 2020-04-16 13:14:00&lt;br&gt;tags:&lt;br&gt;—﻿&lt;/p&gt;
&lt;p&gt;#git相关问题解决&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tinker修复流程梳理</title>
    <link href="https://xjlhhz.com/2018/12/20/20181220Tinker%E5%8E%9F%E7%90%86/"/>
    <id>https://xjlhhz.com/2018/12/20/20181220Tinker原理/</id>
    <published>2018-12-20T05:14:00.000Z</published>
    <updated>2018-12-23T09:07:31.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tinker原理"><a href="#Tinker原理" class="headerlink" title="Tinker原理"></a>Tinker原理</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>接入tinker我们需要改动gradle，对于我们原始的打包不会有影响。<br>通过添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.tencent.tinker.patch&apos;</div></pre></td></tr></table></figure></p><p>在gradle中，我们可以引入tinker插件，并且添加task，tinerPatch。内部可以配置一些相应的参数。</p><h3 id="tinkerPatch过程"><a href="#tinkerPatch过程" class="headerlink" title="tinkerPatch过程"></a>tinkerPatch过程</h3><p>这一部分涉及到了一个Plugin的源码，实现一个插件，需要继承于Plugin<project><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class TinkerPatchPlugin implements Plugin&lt;Project&gt; &#123;</div><div class="line">     @Override</div><div class="line">    public void apply(Project project) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></project></p><p>最后在apply方法中做一些操作。</p><h4 id="添加扩展"><a href="#添加扩展" class="headerlink" title="添加扩展"></a>添加扩展</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">project.extensions.create(&apos;tinkerPatch&apos;, TinkerPatchExtension)</div><div class="line"></div><div class="line">      project.tinkerPatch.extensions.create(&apos;buildConfig&apos;, TinkerBuildConfigExtension, project)</div><div class="line"></div><div class="line">      project.tinkerPatch.extensions.create(&apos;dex&apos;, TinkerDexExtension, project)</div><div class="line">      project.tinkerPatch.extensions.create(&apos;lib&apos;, TinkerLibExtension)</div><div class="line">      project.tinkerPatch.extensions.create(&apos;res&apos;, TinkerResourceExtension)</div><div class="line">      project.tinkerPatch.extensions.create(&apos;packageConfig&apos;, TinkerPackageConfigExtension, project)</div><div class="line">      project.tinkerPatch.extensions.create(&apos;sevenZip&apos;, TinkerSevenZipExtension, project)</div></pre></td></tr></table></figure><p>第一个扩展是tinkerPatch的task，也就是我们可以在gradle中直接使用tinkerPatch，里面可以使用的参数定义在了TinkerPatchExtension，其实就是下面的几个tinkerPatch.extensions。</p><h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TinkerPatchSchemaTask tinkerPatchBuildTask = project.tasks.create(&quot;tinkerPatch$&#123;variantName&#125;&quot;, TinkerPatchSchemaTask)</div></pre></td></tr></table></figure><p>我们将会在gradle中看到两个生成patch的gradle命令。tinkerPatchDebug和tinkerPatchRelease<br>然后设置参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tinkerPatchBuildTask.signConfig = variantData.variantConfiguration.signingConfig</div><div class="line"></div><div class="line">               variant.outputs.each &#123; output -&gt;</div><div class="line">                   setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask)</div><div class="line">                   setPatchOutputFolder(configuration, output, variant, tinkerPatchBuildTask)</div><div class="line">               &#125;</div></pre></td></tr></table></figure></p><p>会设置签名方式，和新apk的路径，还有path文件生产的目录。其中tinkerPatchBuildTask将会在新apk编译完成之后执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void setPatchNewApkPath(configuration, output, variant, tinkerPatchBuildTask) &#123;</div><div class="line">        def newApkPath = configuration.newApk</div><div class="line">        if (!Utils.isNullOrNil(newApkPath)) &#123;</div><div class="line">            if (FileOperation.isLegalFile(newApkPath)) &#123;</div><div class="line">                tinkerPatchBuildTask.buildApkPath = newApkPath</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tinkerPatchBuildTask.buildApkPath = output.outputFile</div><div class="line">        tinkerPatchBuildTask.dependsOn variant.assemble</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>下面是tinker插入编译过程的几个比较重要的任务</p><ul><li><p>TinkerManifestTask<br>TinkerManifestTask会修改原始的manifest文件，将新的tinkerId添加到meta-data之后，假如说原始的manifest已经有了，那么将会先移除再替换。这个任务将会在manifestTask之后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">manifestTask.mustRunAfter variantOutput.processManifest</div><div class="line"></div><div class="line">              variantOutput.processResources.dependsOn manifestTask</div></pre></td></tr></table></figure></li><li><p>TinkerResourceIdTask<br>为了修复资源文件并且保证资源文件id不出错，那么tinker会单独生成一份资源id文件。这个文件是遍历<br>values目录下生成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> int string member_month 0x7f090551</div><div class="line">int string member_not_login_desc 0x7f090552</div><div class="line">int string member_not_login_title 0x7f090553</div><div class="line">int string member_open 0x7f090554</div></pre></td></tr></table></figure></li></ul><p>这个任务将会在Manifest任务执行完毕之后执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//let applyResourceTask run after manifestTask</div><div class="line">               applyResourceTask.mustRunAfter manifestTask</div><div class="line"></div><div class="line">               variantOutput.processResources.dependsOn applyResourceTask</div></pre></td></tr></table></figure></p><ul><li><p>TinkerProguardConfigTask<br>这个是为了混淆的配置，添加tinker会在这个任务中添加对于自身的apk的keep。</p></li><li><p>TinkerMultidexConfigTask<br>如果开启了multidex，那么需要保证tinker的load在主dex中加载</p></li></ul><p>###Diff dex<br>通过apk全量差分算法，最后生成的产物为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">patch_signed_7zip.apk</div><div class="line">resources_out.zip</div></pre></td></tr></table></figure></p><p>虽然是以.apk文件结尾，但是其并非是apk文件，而是新旧apk的差分文件。<br>其中patch_signed_7zip.apk包含以下几个产物：</p><ul><li>resource<br>  包含了所有的修改过的资源文件</li><li>dex文件<br>  这个文件是class的改动</li><li>assert<br>  里面记录了相关的改动</li></ul><ol><li><p>dex_meta.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">classes3.dex,,1576d311d59ddedd90669eda381eac4b,1576d311d59ddedd90669eda381eac4b,7bf7e62455b20776f9542e48396f110c,2500353069,1637042276,jar</div><div class="line">classes2.dex,,14dfca01b4a8cb1560131fa0bd38d90b,14dfca01b4a8cb1560131fa0bd38d90b,991f5078e48003d937b04817c16d778b,3700541000,275306650,jar</div><div class="line">classes.dex,,94c904adfa2ba38bdeaf0cb9f373615b,94c904adfa2ba38bdeaf0cb9f373615b,79b82777a3b181ae8957b1cabe97bdbe,4118346810,3212732521,jar</div><div class="line">classes5.dex,,0,14471ae55489fa8bab85119466c6fe16,0,1868353943,1868353943,jar</div><div class="line">classes4.dex,,0,f60932365b5d653670abbdb4f749b580,0,1507289107,1507289107,jar</div><div class="line">test.dex,,56900442eb5b7e1de45449d0685e6e00,56900442eb5b7e1de45449d0685e6e00,0,0,0,jar</div></pre></td></tr></table></figure></li><li><p>res_meta.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">resources_out.zip,1443645094,c2150945805274616641d2f7a916e264</div><div class="line">pattern:3</div><div class="line">resources.arsc</div><div class="line">res/*</div><div class="line">assets/*</div><div class="line">large modify:1</div><div class="line">resources.arsc,c2150945805274616641d2f7a916e264,2065727823</div><div class="line">modify:4</div><div class="line">res/drawable-xxhdpi-v4/airship.png</div><div class="line">res/layout/activity_main.xml</div><div class="line">res/drawable-v21/avd_hide_password.xml</div><div class="line">res/drawable-v21/avd_show_password.xml</div><div class="line">add:2</div><div class="line">res/drawable-xxhdpi-v4/test_retant.png</div><div class="line">assets/only_use_to_test_tinker_resource.txt</div><div class="line">store:2</div><div class="line">res/drawable-xxhdpi-v4/airship.png</div><div class="line">res/drawable-xxhdpi-v4/test_retant.png</div></pre></td></tr></table></figure></li><li><p>package_meta.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#base package config field</div><div class="line">#Wed Dec 19 17:24:06 CST 2018</div><div class="line">platform=all</div><div class="line">NEW_TINKER_ID=tinker_id_3cb12a846</div><div class="line">TINKER_ID=tinker_id_3cb12a846</div><div class="line">patchMessage=tinker is sample to use</div><div class="line">patchVersion=2.0</div></pre></td></tr></table></figure></li></ol><p>##合成patch过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TinkerInstaller.onReceiveUpgradePatch(this, Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;);</div></pre></td></tr></table></figure></p><p>通过TinkerInstaller指定差异化apk路径，来进行patch合成。<br>最终，将会启动TinkerPatchService来进行修复合成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = upgradePatchProcessor.tryPatch(context, path, patchResult);</div></pre></td></tr></table></figure></p><p>patch合成的目录会存储在/data/data/packageName/tinker下。<br>首先是dex合成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context, String patchVersionDirectory, File patchFile) &#123;</div><div class="line">       if (!manager.isEnabledForDex()) &#123;</div><div class="line">           TinkerLog.w(TAG, &quot;patch recover, dex is not enabled&quot;);</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line">       //是否存在assets/dex_meta.txt文件</div><div class="line">       String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE);</div><div class="line"></div><div class="line">       if (dexMeta == null) &#123;</div><div class="line">           TinkerLog.w(TAG, &quot;patch recover, dex is not contained&quot;);</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       long begin = SystemClock.elapsedRealtime();</div><div class="line">       //通过差分算法进行合成修复</div><div class="line">       boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</div><div class="line">       long cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">       TinkerLog.i(TAG, &quot;recover dex result:%b, cost:%d&quot;, result, cost);</div><div class="line">       return result;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>然后是资源文件的合成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">if (!manager.isEnabledForResource()) &#123;</div><div class="line">          TinkerLog.w(TAG, &quot;patch recover, resource is not enabled&quot;);</div><div class="line">          return true;</div><div class="line">      &#125;</div><div class="line">      String resourceMeta = checker.getMetaContentMap().get(RES_META_FILE);</div><div class="line"></div><div class="line">      if (resourceMeta == null || resourceMeta.length() == 0) &#123;</div><div class="line">          TinkerLog.w(TAG, &quot;patch recover, resource is not contained&quot;);</div><div class="line">          return true;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      long begin = SystemClock.elapsedRealtime();</div><div class="line">      boolean result = patchResourceExtractViaResourceDiff(context, patchVersionDirectory, resourceMeta, patchFile);</div><div class="line">      long cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">      TinkerLog.i(TAG, &quot;recover resource result:%b, cost:%d&quot;, result, cost);</div><div class="line">      return result;</div></pre></td></tr></table></figure></p><p>##启动修复过程<br>首先，tinker会在编译期间生成application的子类。<br>首先会先在attachBaseContext方法中作一些相应的操作。<br>主要是加载tinker中相应的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private void loadTinker() &#123;</div><div class="line">        //disable tinker, not need to install</div><div class="line">        if (tinkerFlags == TINKER_DISABLE) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        tinkerResultIntent = new Intent();</div><div class="line">        try &#123;</div><div class="line">            //反射获取tinkerLoadClass</div><div class="line">            Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, false, getClassLoader());</div><div class="line">            </div><div class="line">            //获取tryLoad方法 </div><div class="line">            Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);</div><div class="line">            //获取构造函数，并进行调用。</div><div class="line">            Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</div><div class="line">            tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), this);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            //has exception, put exception error code</div><div class="line">            ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</div><div class="line">            tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>其实做的就是反射调用TinkerLoader的tryLoad方法。然后就直接调用到了加载修复的代码tryLoadPatchFilesInternal。</p><ol><li>首先判断是否支持tinker，不支持直接return。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">final int tinkerFlag = app.getTinkerFlags();</div><div class="line">      //</div><div class="line">      if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) &#123;</div><div class="line">          Log.w(TAG, &quot;tryLoadPatchFiles: tinker is disable, just return&quot;);</div><div class="line">          ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</div><div class="line">          return;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></li></ol><p>2.判断当前是否是patch进程，如果不是，直接返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (ShareTinkerInternals.isInPatchProcess(app)) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles: we don&apos;t load patch with :patch process itself, just return&quot;);</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</div><div class="line">           return;</div><div class="line"></div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>3.获取tinker目录， 如果不存在，直接返回。文件目录为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/data/data/tinker.sample.android/tinker</div></pre></td></tr></table></figure></p><p>详细判断代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> //tinker</div><div class="line">       File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);</div><div class="line">       if (patchDirectoryFile == null) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles:getPatchDirectory == null&quot;);</div><div class="line">           //treat as not exist</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">//check patch directory whether exist</div><div class="line">       if (!patchDirectoryFile.exists()) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles:patch dir not exist:&quot; + patchDirectoryPath);</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>4.查看patch_info文件是否存在,不存在直接返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//tinker/patch.info</div><div class="line">       File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</div><div class="line"></div><div class="line">       //check patch info file whether exist</div><div class="line">       if (!patchInfoFile.exists()) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles:patch info not exist:&quot; + patchInfoFile.getAbsolutePath());</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>5.比较从lockFile和patch_info文件中读取SharePatchInfo,不存在则直接返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</div><div class="line"></div><div class="line">        patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class="line">        if (patchInfo == null) &#123;</div><div class="line">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</div><div class="line">            return;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>6.获取版本信息,如果version为空，那么直接返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">String oldVersion = patchInfo.oldVersion;</div><div class="line">        String newVersion = patchInfo.newVersion;</div><div class="line">        String oatDex = patchInfo.oatDir;</div><div class="line"></div><div class="line">        if (oldVersion == null || newVersion == null || oatDex == null) &#123;</div><div class="line">            //it is nice to clean patch</div><div class="line">            Log.w(TAG, &quot;tryLoadPatchFiles:onPatchInfoCorrupted&quot;);</div><div class="line">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</div><div class="line"></div><div class="line">        boolean mainProcess = ShareTinkerInternals.isInMainProcess(app);</div><div class="line">        boolean versionChanged = !(oldVersion.equals(newVersion));</div><div class="line">        boolean oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH) &amp;&amp; mainProcess;</div><div class="line">        oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);</div><div class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);</div><div class="line"></div><div class="line">        String version = oldVersion;</div><div class="line"></div><div class="line">        if (versionChanged &amp;&amp; mainProcess) &#123;</div><div class="line">            version = newVersion;</div><div class="line">        &#125;</div><div class="line">        if (ShareTinkerInternals.isNullOrNil(version)) &#123;</div><div class="line">            Log.w(TAG, &quot;tryLoadPatchFiles:version is blank, wait main process to restart&quot;);</div><div class="line">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);</div><div class="line">            return;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>7.获取更新的patchName<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//patch-641e634c</div><div class="line">       String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</div><div class="line">       if (patchName == null) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles:patchName is null&quot;);</div><div class="line">           //we may delete patch info file</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>8.获取对应的patch文件，不存在直接返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//tinker/patch.info/patch-641e634c</div><div class="line">       String patchVersionDirectory = patchDirectoryPath + &quot;/&quot; + patchName;</div><div class="line"></div><div class="line">       File patchVersionDirectoryFile = new File(patchVersionDirectory);</div><div class="line"></div><div class="line">       if (!patchVersionDirectoryFile.exists()) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles:onPatchVersionDirectoryNotFound&quot;);</div><div class="line">           //we may delete patch info file</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>9.获取patch的apk文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//tinker/patch.info/patch-641e634c/patch-641e634c.apk</div><div class="line">     File patchVersionFile = new File(patchVersionDirectoryFile.getAbsolutePath(), SharePatchFileUtil.getPatchVersionFile(version));</div><div class="line"></div><div class="line">     if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) &#123;</div><div class="line">         Log.w(TAG, &quot;tryLoadPatchFiles:onPatchVersionFileNotFound&quot;);</div><div class="line">         //we may delete patch info file</div><div class="line">         ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);</div><div class="line">         return;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p><p>10.检查签名和tinkerId是否一致<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ShareSecurityCheck securityCheck = new ShareSecurityCheck(app);</div><div class="line"></div><div class="line">       int returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);</div><div class="line">       if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</div><div class="line">           Log.w(TAG, &quot;tryLoadPatchFiles:checkTinkerPackage&quot;);</div><div class="line">           resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);</div><div class="line">           ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</div><div class="line">           return;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>11.如果存在dex修复，那么检查dex文件的完整性,并且返回是否成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">final boolean isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</div><div class="line"></div><div class="line">        if (isEnabledForDex) &#123;</div><div class="line">            //tinker/patch.info/patch-641e634c/dex</div><div class="line">            boolean dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);</div><div class="line">            if (!dexCheck) &#123;</div><div class="line">                //file not found, do not load patch</div><div class="line">                Log.w(TAG, &quot;tryLoadPatchFiles:dex check fail&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>12.如果存在nativeLib修复，那么检查完整性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (isEnabledForNativeLib) &#123;</div><div class="line">           //tinker/patch.info/patch-641e634c/lib</div><div class="line">           boolean libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">           if (!libCheck) &#123;</div><div class="line">               //file not found, do not load patch</div><div class="line">               Log.w(TAG, &quot;tryLoadPatchFiles:native lib check fail&quot;);</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>12.如果存在资源替换，那么检查资源的完整性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//check resource</div><div class="line">       final boolean isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</div><div class="line">       Log.w(TAG, &quot;tryLoadPatchFiles:isEnabledForResource:&quot; + isEnabledForResource);</div><div class="line">       if (isEnabledForResource) &#123;</div><div class="line">           boolean resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</div><div class="line">           if (!resourceCheck) &#123;</div><div class="line">               //file not found, do not load patch</div><div class="line">               Log.w(TAG, &quot;tryLoadPatchFiles:resource check fail&quot;);</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>14.开始进行dex替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (isEnabledForDex) &#123;</div><div class="line">           boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);</div><div class="line">           ...</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>将会在loadTinkerJars方法中完成主要逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA) &#123;</div><div class="line">       //如果没有提前生成dexList，那么直接返回。</div><div class="line">       if (loadDexList.isEmpty() &amp;&amp; classNDexInfo.isEmpty()) &#123;</div><div class="line">           Log.w(TAG, &quot;there is no dex to load&quot;);</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       //获取classLoader</div><div class="line">       PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();</div><div class="line">       ...</div><div class="line">       //从classNDexInfo和classNDexInfo生成合法文件</div><div class="line">        ArrayList&lt;File&gt; legalFiles = new ArrayList&lt;&gt;();</div><div class="line">        </div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>通过pathClassLoader替换dex<br>在sdk23的版本上-<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获取pathList的Field</div><div class="line">  Field pathListField = ShareReflectUtil.findField(loader, &quot;pathList&quot;);</div><div class="line">            //获取classLoader对应的Field的值</div><div class="line">            Object dexPathList = pathListField.get(loader);</div><div class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</div><div class="line">            //扩展该dexPathList的dexElements</div><div class="line">            ShareReflectUtil.expandFieldArray(dexPathList, &quot;dexElements&quot;, makePathElements(dexPathList,</div><div class="line">                new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</div></pre></td></tr></table></figure></p><p>对于dexElements的扩展，其实就是通过反射获取出原值，并且改动了下原值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> //获取dexElements的Filed</div><div class="line">  Field jlrField = findField(instance, fieldName);</div><div class="line">//获取dexElements对应的值</div><div class="line">        Object[] original = (Object[]) jlrField.get(instance);</div><div class="line">        //创建新的dexElements数组</div><div class="line">        Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length);</div><div class="line"></div><div class="line">        //先添加extraElements，也就是热修复合并生成的dex</div><div class="line">        System.arraycopy(extraElements, 0, combined, 0, extraElements.length);</div><div class="line">        //再添加原始的dex文件。</div><div class="line">        System.arraycopy(original, 0, combined, extraElements.length, original.length);</div><div class="line">        //给dexElement设置修改后的dex文件。</div><div class="line">        jlrField.set(instance, combined);</div></pre></td></tr></table></figure></p><p>在sdk24及以上，tinker通过hook整个classLoader来进行修复。<br>首先是创建新的classLoader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">final AndroidNClassLoader androidNClassLoader = new AndroidNClassLoader(&quot;&quot;,  originalClassLoader, application);</div><div class="line">//获取原始pathList列表</div><div class="line">final Field pathListField = ShareReflectUtil.findField(originalClassLoader, &quot;pathList&quot;);</div><div class="line">final Object originPathList = pathListField.get(originalClassLoader);</div><div class="line"></div><div class="line">//通过原始的pathList列表，创建出新的pathList列表。</div><div class="line">Object newPathList = recreateDexPathList(originPathList, androidNClassLoader);</div><div class="line"></div><div class="line">// Update new classloader&apos;s pathList.</div><div class="line">pathListField.set(androidNClassLoader, newPathList);</div><div class="line"></div><div class="line">return androidNClassLoader;</div></pre></td></tr></table></figure></p><p>然后替换classLoader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//创建classLoader</div><div class="line"> AndroidNClassLoader classLoader = createAndroidNClassLoader(originClassLoader, application);</div><div class="line">    //替换classLoader</div><div class="line">        reflectPackageInfoClassloader(application, classLoader);</div></pre></td></tr></table></figure></p><p>15.开始进行资源替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public static void monkeyPatchExistingResources(Context context, String externalResourceFile) throws Throwable &#123;</div><div class="line">        //遍历ActivityThread的mPackages和mResourcePackages，这两个都是map</div><div class="line">        for (Field field : new Field[]&#123;packagesFiled, resourcePackagesFiled&#125;) &#123;</div><div class="line">            Object value = field.get(currentActivityThread);</div><div class="line"></div><div class="line">            for (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry</div><div class="line">                : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;</div><div class="line">                Object loadedApk = entry.getValue().get();</div><div class="line">                if (loadedApk == null) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (externalResourceFile != null) &#123;</div><div class="line">                    //资源文件mResDir是会在loadedApk中，api8为PackageInfo，api10为android.app.LoadedApk</div><div class="line">                    //通过反射设置新的资源文件的文件</div><div class="line">                    resDir.set(loadedApk, externalResourceFile);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //反射调用addAssetPath方法，添加为我们新建的assertManager</div><div class="line">        if (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == 0) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Could not create new AssetManager&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //反射调用ensureStringBlocks方法，Kitkat版需要调用这个方法</div><div class="line">        ensureStringBlocksMethod.invoke(newAssetManager);</div><div class="line">        //sdk大于等于19通过反射获取ResourcesManager的mActiveResources，就是所有的资源文件，sdk小于19时，通过ActivityThread中的mActiveResources获取所有的资源</div><div class="line">        for (WeakReference&lt;Resources&gt; wr : references) &#123;</div><div class="line">            Resources resources = wr.get();</div><div class="line">            //设置mAssets的路径为新的assertManger</div><div class="line">            assetsFiled.set(resources, newAssetManager);</div><div class="line">               </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在通过tinkerLoader方法修复完dex和资源文件之后，创建DefaultApplicationLike,并且回调里面的生命周期方法。</p><p><img src="http://mykotlin.com/tinker%E4%BF%AE%E5%A4%8D%E8%BF%87%E7%A8%8B.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tinker原理&quot;&gt;&lt;a href=&quot;#Tinker原理&quot; class=&quot;headerlink&quot; title=&quot;Tinker原理&quot;&gt;&lt;/a&gt;Tinker原理&lt;/h1&gt;&lt;h2 id=&quot;编译过程&quot;&gt;&lt;a href=&quot;#编译过程&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>导入stetho依赖库重复引用的解决</title>
    <link href="https://xjlhhz.com/2018/11/26/20181126stetho%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://xjlhhz.com/2018/11/26/20181126stetho问题解决/</id>
    <published>2018-11-26T05:14:00.000Z</published>
    <updated>2018-12-09T09:53:35.351Z</updated>
    
    <content type="html"><![CDATA[<p>##问题<br>最近在引用stetho这个第三方库时，编译时一直报错。错误如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* What went wrong:</div><div class="line">Execution failed for task &apos;:Kuaikan:transformClassesWithMultidexlistForDebug&apos;.</div><div class="line">&gt; com.android.build.api.transform.TransformException: Error while generating the main dex list.</div></pre></td></tr></table></figure></p><p>更详细的错误是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Program type already present: javax.annotation.*</div></pre></td></tr></table></figure></p><p>也就是说，出现了两个同时引用javax.annotation的情况。</p><p>##解决<br>这种时候可以按照我们下面的</p><h3 id="查询依赖库"><a href="#查询依赖库" class="headerlink" title="查询依赖库"></a>查询依赖库</h3><p>我们可以通过gradle命令来查询当前的库的引用情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew kuaikan:dependencies</div></pre></td></tr></table></figure></p><p>通过这个命令，可以查看当前库的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+--- com.facebook.stetho:stetho:1.5.0</div><div class="line">|    +--- commons-cli:commons-cli:1.2</div><div class="line">|    \--- com.google.code.findbugs:jsr305:2.0.1</div><div class="line">+--- com.github.ctiao:dfm:0.4.4</div></pre></td></tr></table></figure></p><p>发现了stetho内部依赖了com.google.code.findbugs。其实它内部包含了模块annotations，所以会导致javax.annotation重复引用的情况。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>既然有两个同样的库，那么只要保证其中的一个库不引入annotation就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">implementation(&apos;com.facebook.stetho:stetho:1.5.0&apos;) &#123;</div><div class="line">        exclude group: &apos;com.google.code.findbugs&apos;</div><div class="line">        exclude module: &apos;annotations&apos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>表示意思是： 在引入了stetho库的同时，不引入其内部的依赖com.google.code.findbugs中的模块annotations。这样就不会出现重复引用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##问题&lt;br&gt;最近在引用stetho这个第三方库时，编译时一直报错。错误如下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Executor简单理解</title>
    <link href="https://xjlhhz.com/2018/11/21/20181121Executor%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>https://xjlhhz.com/2018/11/21/20181121Executor简单理解/</id>
    <published>2018-11-21T05:14:00.000Z</published>
    <updated>2018-11-25T03:07:33.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池-Executor"><a href="#线程池-Executor" class="headerlink" title="线程池 Executor"></a>线程池 Executor</h2><h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><ul><li>Executor： 是一个接口，它是Executor框架的基础，它将任务的提交和执行分离开<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">    void execute(Runnable command);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>这个execute方法就行执行任务的方法。</p><ul><li><p>ExcutorService：这个Service是个接口，ThreadPoolExecutor和ScheduledThreadpoolExecutor都是其子类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface ExecutorService extends Executor &#123;</div><div class="line">    //关闭任务</div><div class="line">    void shutdown();</div><div class="line"></div><div class="line">    //尝试关闭所有任务</div><div class="line">    List&lt;Runnable&gt; shutdownNow();</div><div class="line"></div><div class="line">    //提交任务</div><div class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line"></div><div class="line">    //提交任务，并且接收回调</div><div class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</div><div class="line">    //执行任务</div><div class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</div><div class="line">        throws InterruptedException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>ThreadPoolExecutor：是线程池的核心实现类，用来执行被提交的任务</p></li><li>ScheduledThreadpoolExecutor：是一个实现类，用来在指定的延迟时间后运行命令，或者定期执行命令。</li><li>Future接口和Future接口的实现类FutureTask：表示异步计算的结果</li><li>Runnable接口和Callable的实现类，都可以被ThreadPoolExecutor和ScheduledThreadpoolExecutor执行。</li></ul><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li>主线程创建任务对象，也就是Runnable或Callable的实现类</li><li>主线程把任务对象交给ExcutorService执行。</li><li>通过ExcutorService返回的FetureTask对象，调用get方法等待任务执行完毕。当然，也可以通过cancel方法取消任务的执行。</li></ol><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>Executor框架提供了三种不同的线程池：</p><ol><li>FixedThreadPool：表示创建使用固定线程数的线程池。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      0L, TimeUnit.MILLISECONDS,</div><div class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ol><p>会限制当前线程数量的应用场景，适用于负载比较重得服务器。</p><ol><li><p>SignleThreadExecutor创建使用单个线程的线程池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">       return new FinalizableDelegatedExecutorService</div><div class="line">           (new ThreadPoolExecutor(1, 1,</div><div class="line">                                   0L, TimeUnit.MILLISECONDS,</div><div class="line">                                   new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>CachedThreadPool，会根据需要创建新线程的Executor。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                      60L, TimeUnit.SECONDS,</div><div class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ol><p>这个是一个大小没有边界的线程池，适用于执行很多短期异步小任务。</p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>主要成员</p><ul><li>corePool: 核心线程池大小</li><li>maximumPool：最大线程池大小</li><li>BlockingQueue：暂时保存任务的工作队列</li><li>RejectedExecutionHandle：饱和时，execute方法调用的handler</li></ul><p>针对于上面三种线程池，我们来看看其内部的执行过程。</p><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><ol><li>如果当前线程数小于corePoolSize，那么将会创建新的线程来执行任务</li><li>在线程池的运行线程与corePoolSize一样大时，将会将任务加入阻塞队列中。</li><li>之前创建出的线程执行完任务之后，将会循环的从阻塞队列中获取任务来执行。</li></ol><p>因为是一个无界的阻塞队列，所以maximumPool无效，并且不会有饱和的情况。</p><h4 id="SignleThreadExecutor"><a href="#SignleThreadExecutor" class="headerlink" title="SignleThreadExecutor"></a>SignleThreadExecutor</h4><p>和上面的FixedThreadPool流程基本一致，只不过是size被设置为1.</p><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><p>CachedThreadPool的corePoolSize被设置为0，maximumPoolSize被设置为Int的最大值。也就是maximumPoll是无界的，keepAliveTime设置的空闲存活时间为60s。一旦线程空闲超过60s，将会被终止。</p><h3 id="FutureTask实现"><a href="#FutureTask实现" class="headerlink" title="FutureTask实现"></a>FutureTask实现</h3><p>####FutureTask的三种状态</p><ul><li>未启动： 未调用run方法，调用get，导致线程阻塞，调用cancel，不会执行。</li><li>启动：调用run方法，正在执行中，调用get，导致线程阻塞，调用cancel(false),无影响。调用cancel(true)，中断线程</li><li>已完成：正常结束、异常结束、cancel，导致线程立即返回结果或抛出异常。调用cancel，返回false</li></ul><h4 id="FutureTask的异步实现"><a href="#FutureTask的异步实现" class="headerlink" title="FutureTask的异步实现"></a>FutureTask的异步实现</h4><p>是基于AbstractQueueSynchronizer，抽象同步队列，简称AQS，是一个同步框架，提供通用机制来原子性管理同步状态、阻塞和唤醒线程以及维护被阻塞线程的队列。实现类包括了可重入锁，信号量等。<br>每一个基于AQS实现的同步器至少会包含两种类型的操作。</p><ul><li>acquire: 这个操作将阻塞线程，直到AQS允许这个线程继续执行，在FutureTask中，就是get操作</li><li>release：改变AQS状态，改变状态后，允许一个或多个阻塞线程被解除阻塞。在FutureTask中，是run方法和cancel方法。</li></ul><p>FutureTask内部声明了一个AQS的子类Sync，所有的调用都会委托给Sync。</p><p>#####FutrureTask.get流程：</p><ul><li>内部会调用到AQS.acquireSharedInterruptibly方法，回调Sync实现的tryAcquireShared方法判断acquire操作是否可以成功。成功的条件为：state为执行完成状态或者已取消状态。</li><li>如果成功则get立即返回。如果失败则到线程等待队列中去等待其他线程执行release操作。</li><li>当其他线程执行了release操作并且唤醒当前线程后，再次执行tryAcquireShared将返回1.</li><li>最后返回计算结果。</li></ul><p>#####FutureTask.run流程</p><ul><li>执行构造函数指定的任务</li><li>以CAS方式更新同步状态。</li><li>调用releaseShared方法，唤醒等待队列的第一个线程。</li><li>调用FutureTask.done</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程池-Executor&quot;&gt;&lt;a href=&quot;#线程池-Executor&quot; class=&quot;headerlink&quot; title=&quot;线程池 Executor&quot;&gt;&lt;/a&gt;线程池 Executor&lt;/h2&gt;&lt;h3 id=&quot;成员&quot;&gt;&lt;a href=&quot;#成员&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin语法糖的理解</title>
    <link href="https://xjlhhz.com/2018/11/18/20181118kotlin%E8%AF%AD%E6%B3%95%E7%B3%96%E7%90%86%E8%A7%A3/"/>
    <id>https://xjlhhz.com/2018/11/18/20181118kotlin语法糖理解/</id>
    <published>2018-11-18T05:14:00.000Z</published>
    <updated>2018-11-18T14:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于kotlin和java，两个语言都是在jvm上运行的，所以它们最终生产的字节码将会是一致的。对于kotlin的一些比较方便的语法糖，我们可以利用其等同的java代码，来验证其内部的实现。</p><p>##字节码和.kt对应的.java文件<br>通过AndroidStudio的tool -&gt; kotlin -&gt; show kotlin bytecode,可以生产kt文件对应的字节码，然后在字节码文件上，选中Decompile，反编译字节码文件，可以生成对应的.java文件。</p><h2 id="可空参数与非空参数"><a href="#可空参数与非空参数" class="headerlink" title="可空参数与非空参数"></a>可空参数与非空参数</h2><p>kotlin的参数定义时，必须标明是否可空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var callBack: String? = null</div><div class="line">var currentFlow：PayFlow = PayFlow.Idle</div></pre></td></tr></table></figure></p><p>第一个参数表示可空的，第二个参数表示非空参数<br>其实在java中，就是对应以下的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Nullable</div><div class="line">private static String callBack;</div><div class="line">@NotNull</div><div class="line">private static final ReadWriteProperty currentFlow$delegate</div></pre></td></tr></table></figure></p><p>其实kotlin实现非空参数，跟java通过注解@Nullable和@NotNull来实现是一样的。</p><h2 id="object关键字来实现单例"><a href="#object关键字来实现单例" class="headerlink" title="object关键字来实现单例"></a>object关键字来实现单例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">object PayFlowManager &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对应的java实现为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static final PayFlowManager INSTANCE;</div><div class="line">static &#123;</div><div class="line">      PayFlowManager var0 = new PayFlowManager();</div><div class="line">      INSTANCE = var0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>利用了static加载的方式，来创建单例。也就是我们常说的单例的饿汉实现。同时，这个创建出来的变量名为INSTANCE，所以我们java调用的方式都需要通过类名.INSTANCE来访问kt的单例。</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>kotlin中，支持传入lambda作为成员变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var succeedViewAction: () -&gt; Unit = &#123;&#125;</div></pre></td></tr></table></figure></p><p>这个lambda表示当前接收空参数，并且返回值为空。在java中的表示为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@NotNull</div><div class="line">private Function1 payResultAction;</div></pre></td></tr></table></figure></p><p>这个Function1是一个接口，也就是说，kt的lambda对于java来说，就是一个接口。lambda每多一个参数，都有一个相对应的Function，后面的数字就表示参数的个数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">** A function that takes 0 arguments. */</div><div class="line">public interface Function0&lt;out R&gt; : Function&lt;R&gt; &#123;</div><div class="line">    /** Invokes the function. */</div><div class="line">    public operator fun invoke(): R</div><div class="line">&#125;</div><div class="line">....</div><div class="line">....</div><div class="line">/** A function that takes 22 arguments. */</div><div class="line">public interface Function22&lt;in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, in P22, out R&gt; : Function&lt;R&gt; &#123;</div><div class="line">    /** Invokes the function with the specified arguments. */</div><div class="line">    public operator fun invoke(p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, p10: P10, p11: P11, p12: P12, p13: P13, p14: P14, p15: P15, p16: P16, p17: P17, p18: P18, p19: P19, p20: P20, p21: P21, p22: P22): R</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>也就是说，目前kt的最多支持的lambda的参数的个数是22个。<br>所以，在java中传递这个lambda，就是set这个接口的实现类,也就是匿名内部类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">payTypeParam.setPayResultAction(new Function1&lt;Integer, Unit&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Unit invoke(Integer integer) &#123;</div><div class="line">                ...</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p><h2 id="companion-object"><a href="#companion-object" class="headerlink" title="companion object"></a>companion object</h2><p>在kt中，通常我们用companion object来作为静态成员的存储。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">companion object &#123;</div><div class="line">       val PAY_SOURCE_NONE = 0</div><div class="line">       val PAY_SOURCE_LIST = 1</div><div class="line">       val PAY_SOURCE_ACTIVITY = 2</div><div class="line">       val PAY_SOURCE_COMIC = 3</div><div class="line">       val PAY_SOURCE_NOTICE = 4</div><div class="line">       val PAY_SOURCE_LIVE = 5</div><div class="line">       val PAY_SOURCE_VIP_CENTER = 6</div><div class="line">       val PAY_SOURCE_PARTNER = 8</div><div class="line">       val PAY_SOURCE_COMIC_LAYER = 9</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>对应的java代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public interface PaySource &#123;</div><div class="line">   PaySource.Companion Companion = PaySource.Companion.$$INSTANCE;</div><div class="line">public static final class Companion &#123;</div><div class="line">      private static final int PAY_SOURCE_NONE = 0;</div><div class="line">      private static final int PAY_SOURCE_LIST = 1;</div><div class="line">      private static final int PAY_SOURCE_ACTIVITY = 2;</div><div class="line">      private static final int PAY_SOURCE_COMIC = 3;</div><div class="line">      private static final int PAY_SOURCE_NOTICE = 4;</div><div class="line">      private static final int PAY_SOURCE_LIVE = 5;</div><div class="line">      private static final int PAY_SOURCE_VIP_CENTER = 6;</div><div class="line">      private static final int PAY_SOURCE_PARTNER = 8;</div><div class="line">      private static final int PAY_SOURCE_COMIC_LAYER = 9;</div><div class="line">      // $FF: synthetic field</div><div class="line">      static final PaySource.Companion $$INSTANCE;</div><div class="line">      static &#123;</div><div class="line">         PaySource.Companion var0 = new PaySource.Companion();</div><div class="line">         $$INSTANCE = var0;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    等对应的get和set方法</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>也就是说，内部会生成一个Companion的静态内部类，同时生成一个这个静态内部类对应的实例。java调用时，将会直接调用这个Companion变量来访问静态方法和静态变量。</p><h2 id="kotlin-Extension"><a href="#kotlin-Extension" class="headerlink" title="kotlin Extension"></a>kotlin Extension</h2><p>kt提供了一个插件，让我们可以在用到xml的地方直接用id进行访问，而不用再通过findViewById来初始化View,我们需要先导入对应的生成文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import kotlinx.android.synthetic.main.activity_vip_recharge.*</div></pre></td></tr></table></figure></p><p>在对应java实现中，我们可以知道其内部的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public View _$_findCachedViewById(int var1) &#123;</div><div class="line">      if (this._$_findViewCache == null) &#123;</div><div class="line">         this._$_findViewCache = new HashMap();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      View var2 = (View)this._$_findViewCache.get(var1);</div><div class="line">      if (var2 == null) &#123;</div><div class="line">         var2 = this.findViewById(var1);</div><div class="line">         this._$_findViewCache.put(var1, var2);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      return var2;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void _$_clearFindViewByIdCache() &#123;</div><div class="line">      if (this._$_findViewCache != null) &#123;</div><div class="line">         this._$_findViewCache.clear();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>对于每一个通过id直接调用view的类，都会生成_$_findCachedViewById方法,在这个方法中，提供了findViewById的操作，同时会创建出一个HashMap作为缓存时，防止多次使用时重复的执行findViewById操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">((ImageView)this._$_findCachedViewById(id.icBack)).setOnClickListener((OnClickListener)this);</div><div class="line">     ((TextView)this._$_findCachedViewById(id.tradingRecord)).setOnClickListener((OnClickListener)this);</div><div class="line">     ((KKLayoutButton)this._$_findCachedViewById(id.btnAction)).setOnClickListener((OnClickListener)this);</div><div class="line">     ((TextView)this._$_findCachedViewById(id.autoContinue)).setOnClickListener((OnClickListener)this);</div></pre></td></tr></table></figure></p><p>kt在每一个使用到id的地方，都将入侵式的替换代码，通过我们给定的id来调用findViewById。</p><p>##lateinit关键字<br>对于一个我们保证肯定会在生命周期一开始就初始化的值，我们可以用lateinit来修饰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private lateinit var mMemberAutoContinueClose: ImageView</div></pre></td></tr></table></figure></p><p>那么kt如何保证这个lateinit的有效性呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (this.mMemberAutoContinueClose == null) &#123;</div><div class="line">         Intrinsics.throwUninitializedPropertyAccessException(&quot;mMemberAutoContinueClose&quot;);</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><p>在每一次使用这个属性之前都会先做一次判空操作，一旦为空，将会直接抛出异常。</p><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>kt的一个非常牛逼的功能，其实就是扩展函数，我们可以扩展一些基础类的基本功能，比如说我们给Context扩展toast功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun Context?.toast(@StringRes toastRes: Int) &#123;</div><div class="line">    if (this == null) &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    val text = getString(toastRes)</div><div class="line">    toast(text)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对应的生成java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static final void toast(@Nullable Context $receiver, @StringRes int toastRes) &#123;</div><div class="line">      if ($receiver != null) &#123;</div><div class="line">         String text = $receiver.getString(toastRes);</div><div class="line">         Intrinsics.checkExpressionValueIsNotNull(text, &quot;text&quot;);</div><div class="line">         toast($receiver, text);</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>也就是说，扩展函数的功能其实就是基于静态方法来实现的。被扩展类作为第一个入参，后续的参数就是扩展函数需要的参数。<br>而且，每一个扩展函数的文件，都会生成对应名称的class文件。比如说KotlinExt.kt将会生成KotlinExtKt这个类。最后java文件中，通过生成的类来访问静态方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于kotlin和java，两个语言都是在jvm上运行的，所以它们最终生产的字节码将会是一致的。对于kotlin的一些比较方便的语法糖，我们可以利用其等同的java代码，来验证其内部的实现。&lt;/p&gt;
&lt;p&gt;##字节码和.kt对应的.java文件&lt;br&gt;通过AndroidSt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap及其并发的一些理解</title>
    <link href="https://xjlhhz.com/2018/11/17/20181117HashMap%E5%8F%8A%E5%85%B6%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://xjlhhz.com/2018/11/17/20181117HashMap及其并发的一些理解/</id>
    <published>2018-11-17T05:14:00.000Z</published>
    <updated>2018-11-17T09:47:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>#HashMap及其并发的一些理解</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>在jdk1.8之前，HashMap通过数组加链表的方式实现。在1.8之后，在链表长度大于8之后，会将链表转化为红黑树进行存储。</p><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><h4 id="Node和Entry"><a href="#Node和Entry" class="headerlink" title="Node和Entry"></a>Node和Entry</h4><p>Entry表示链表的每一个节点的元素，就是key和value的包装对象。Map是一个接口，实现类为Node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">       final int hash;</div><div class="line">       final K key;</div><div class="line">       V value;</div><div class="line">       Node&lt;K,V&gt; next;</div><div class="line"></div><div class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">           this.hash = hash;</div><div class="line">           this.key = key;</div><div class="line">           this.value = value;</div><div class="line">           this.next = next;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public final K getKey()        &#123; return key; &#125;</div><div class="line">       public final V getValue()      &#123; return value; &#125;</div><div class="line">       public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</div><div class="line"></div><div class="line">       public final int hashCode() &#123;</div><div class="line">           return Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public final V setValue(V newValue) &#123;</div><div class="line">           V oldValue = value;</div><div class="line">           value = newValue;</div><div class="line">           return oldValue;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       public final boolean equals(Object o) &#123;</div><div class="line">           if (o == this)</div><div class="line">               return true;</div><div class="line">           if (o instanceof Map.Entry) &#123;</div><div class="line">               Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">               if (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                   Objects.equals(value, e.getValue()))</div><div class="line">                   return true;</div><div class="line">           &#125;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>作为一个Map存储的基本单元，需要有下面几个成员变量和方法</p><ul><li>hash： 表示当前node对应的hash值</li><li>key： map中put对应的key值</li><li>value： map中put对应的value值</li><li>next： 表示链表的下一个节点</li><li>equals： 比较两个node是否相等</li></ul><h4 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h4><p>在jdk1.8之后，当链表长度大于8个时，将会转化红黑树，以用来提供查找效率。当链表长度到达一定长度时，查找的时间复杂度为O(n),在已红黑树进行查询时，时间复杂度会缩减为O(lgn)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.LinkedHashMapEntry&lt;K,V&gt; &#123;</div><div class="line">       TreeNode&lt;K,V&gt; parent;  // red-black tree links</div><div class="line">       TreeNode&lt;K,V&gt; left;</div><div class="line">       TreeNode&lt;K,V&gt; right;</div><div class="line">       TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</div><div class="line">       boolean red;</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>一个红黑树的Node，需要有一下几个成员变量</p><ul><li>parent: 父节点</li><li>left： 左子节点</li><li>right：右子节点</li><li>prev： 上一个节点</li><li>red： 是否是红节点</li></ul><p>还会提供几个相关的方法：</p><ul><li>root(): 获取当前红黑树的根节点</li><li>moveRootToFront(): 保证红黑树节点是链表的第一个元素</li><li>find：从指定节点找到node</li><li>getTreeNode：从root节点找到对应的node</li><li>treeify：将链表转化为红黑树</li><li>untreeify：将红黑树转化为链表</li><li>putTreeVal：插入一个红黑树节点</li><li>removeTreeNode：移除一个红黑树节点</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                  boolean evict) &#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">       if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">           //创建resize里面会创建新的table，或进行扩容</div><div class="line">           n = (tab = resize()).length;</div><div class="line">       if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">           //如果计算出来的pos并没有node节点，那么直接创建新的节点，并且进行存储</div><div class="line">           tab[i] = newNode(hash, key, value, null);</div><div class="line">       else &#123;</div><div class="line">           //计算出来pos有元素存在</div><div class="line">           Node&lt;K,V&gt; e; K k;</div><div class="line">           if (p.hash == hash &amp;&amp;</div><div class="line">               ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">               //当前的node是需要需要替换的node</div><div class="line">               //直接替换</div><div class="line">               e = p;</div><div class="line">           else if (p instanceof TreeNode)</div><div class="line">               //当前是以树结构进行存储，通过树的put方法进行插入</div><div class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">           else &#123;</div><div class="line">               //当前是链表，需要添加新node</div><div class="line">               for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                   if ((e = p.next) == null) &#123;</div><div class="line">                       //在最后一个节点处，创建新节点</div><div class="line">                       p.next = newNode(hash, key, value, null);</div><div class="line">                       //如果当前是size大于等于7了，也就是添加元素之后size至少是8了，</div><div class="line">                       if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                           //将链表转化为输结构存储</div><div class="line">                           treeifyBin(tab, hash);</div><div class="line">                       break;</div><div class="line">                   &#125;</div><div class="line">                   ...</div><div class="line">                   p = e;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           ....</div><div class="line">       &#125;</div><div class="line">       ++modCount;</div><div class="line">       if (++size &gt; threshold)</div><div class="line">           //如果当前的大小大于阈值，那么需要扩容</div><div class="line">           resize();</div><div class="line">       afterNodeInsertion(evict);</div><div class="line">       return null;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>HashMap的put方法主要以下几个步骤：</p><ol><li>如果当前table为空，那么初始化table</li><li>查找通过key的hash值来计算当前的table的pos，如果pos对应的node为空，那么直接插入</li><li>如果不为空，而且hash值一样和key一样，那么直接替换</li><li>如果不为空，hash值不一致，而且获取出来的节点是树节点，那么通过树的putTreeVal方法进行插入，内部会维持红黑树的平衡。</li><li>如果不为空，hash值不一致，且非树节点，那么当前还是以链表的形式存储，需要将元素添加到链表后面，添加完成之后，如果链表元素大于阈值，需要进行扩容。</li></ol><p>下面我们来看看hashMap的扩容方法resize<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">       Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">       int oldThr = threshold;</div><div class="line">       int newCap, newThr = 0;</div><div class="line">       if (oldCap &gt; 0) &#123;</div><div class="line">           ...</div><div class="line">           //进行扩容，新size为oldsize的2倍</div><div class="line">           newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">       &#125;</div><div class="line">       threshold = newThr;</div><div class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">       //创建新的table</div><div class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">       table = newTab;</div><div class="line">       if (oldTab != null) &#123;</div><div class="line">           //如果旧表有值，需要将旧表的值添加新表</div><div class="line">           for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">               Node&lt;K,V&gt; e;</div><div class="line">               if ((e = oldTab[j]) != null) &#123;</div><div class="line">                   oldTab[j] = null;</div><div class="line">                   if (e.next == null)</div><div class="line">                       newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                   else if (e instanceof TreeNode)</div><div class="line">                       //通过树进行赋值</div><div class="line">                       ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                   else &#123; // preserve order</div><div class="line">                       //重新计算hash，链表节点赋值</div><div class="line">                       ...</div><div class="line">                      &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return newTab;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</div><div class="line">            //table对应pos的节点存在</div><div class="line">            if (first.hash == hash &amp;&amp; // always check first node</div><div class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                //key相等，hash值也相等，直接返回</div><div class="line">                return first;</div><div class="line">            if ((e = first.next) != null) &#123;</div><div class="line">                //如果当前是以树结构进行存储，那么通过树去寻找节点，并返回</div><div class="line">                if (first instanceof TreeNode)</div><div class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                do &#123;</div><div class="line">                    //当前仍是以链表形式存储，遍历查找并且返回</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        return e;</div><div class="line">                &#125; while ((e = e.next) != null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>其实get操作相对put还是比较简单的，</p><ol><li>首先通过hash计算出在table的位置，并取值</li><li>如果当前的node已经是匹配hash和key的，那么直接返回</li><li><p>如果当前不匹配，</p><p> 当前node是以链表进行存储的：遍历比较取值并返回<br> 当前node是以树的形式进行存储的：通过红黑树的getTreeNode进行取值并返回</p></li></ol><h3 id="hashMap在多线程中的缺陷"><a href="#hashMap在多线程中的缺陷" class="headerlink" title="hashMap在多线程中的缺陷"></a>hashMap在多线程中的缺陷</h3><p>hashMap并没有对多线程做一些额外的处理，这就导致了在多线程中直接使用hashMap可能出现异常情况。</p><ul><li><p>在put操作中，如果并发进行元素的添加，可能出现某个元素添加失败的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ((e = p.next) == null) &#123;</div><div class="line">    //第一个线程进入这个判断，切换到到第二个线程，并且执行完p.next的设置，再切换到第一个线程执行p.next的设置，会导致第二个线程的设置失效</div><div class="line">    p.next = newNode(hash, key, value, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在put中，如果正在进行扩容，会导致链表循环引用的出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">    if (loTail == null)</div><div class="line">        loHead = e;</div><div class="line">    else</div><div class="line">        //在第一个线程执行到这个语句时，切换到第二个线程</div><div class="line">        loTail.next = e;</div><div class="line">    loTail = e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>最后会出现e.next = e的循环引用的出现。所以，在多线程的情况下，我们需要利用ConcurrentHashMap。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>对于HashTable，通过给synchronized修饰解决HashMap的并发问题，这样效率十分低下，在同一个时刻，仅能有一个线程访问HashTable的各个方法，因为每个线程都需要竞争同一把锁。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="基本元素-1"><a href="#基本元素-1" class="headerlink" title="基本元素"></a>基本元素</h3><h4 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h4><p>底层结构是以树结构来进行存储的<br>TreeBin表示红黑树的root节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</div><div class="line">        TreeNode&lt;K,V&gt; root;</div><div class="line">        volatile TreeNode&lt;K,V&gt; first;</div><div class="line">        volatile Thread waiter;</div><div class="line">        volatile int lockState;</div><div class="line">        // values for lockState</div><div class="line">        static final int WRITER = 1; // set while holding write lock</div><div class="line">        static final int WAITER = 2; // set when waiting for write lock</div><div class="line">        static final int READER = 4;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h4 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h4><p>这个是一个在扩容时会创建的节点，主要用于占位，当其他线程发现某个位置的节点fwd类型的节点，那么会跳过这个节点。</p><h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><p>CAS操作是可以保证线程间同步的操作，比较并设置。不需要锁来实现，通过设置一个期待的原值，和需要修改的值，只有原值和当前期待的值成功，才会进行修改。<br>map中提供了三个关于node的CAS操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//获取table指定位置的元素</div><div class="line">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</div><div class="line">        return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //判断当前元素是否存在</div><div class="line">    static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</div><div class="line">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">        return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">    &#125;</div><div class="line">//设置table的某个元素</div><div class="line">    static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123;</div><div class="line">        U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h2 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>在jdk1.7里面及以前采用了锁分段技术，对于每几个Entry，都将对应到一个Segment上，在put的时候，仅仅对segment进行加锁，多线程访问不同数据段的数据，就不会出现锁竞争的情况。</p><h3 id="jdk1-8实现"><a href="#jdk1-8实现" class="headerlink" title="jdk1.8实现"></a>jdk1.8实现</h3><p>在jdk1.8里面通过Unsafe类来实现。这个类并未开源<br>原子访问是sun.misc.Unsafe被广泛应用的特性之一，特性包括简单的“put”和“get”操作（带有 volatile 语义或不带有 volatile 语义）以及比较并交换（compare and swap，CAS）操作</p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>put方法的流程大概有下面几步</p><ul><li>判空值<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (key == null || value == null) throw new NullPointerException();</div></pre></td></tr></table></figure></li></ul><p>//如果此时需要插入的key和value为null，那么直接抛异常，说明concurrentHashMap不支持空key和空value</p><ul><li>计算hash<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int hash = spread(key.hashCode());</div></pre></td></tr></table></figure></li></ul><p>通过hashCode值才能知道当前需要存入的哪个buket中。</p><ul><li>遍历table<ol><li>如果当前table为null，那么需要new除新的table<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (tab == null || (n = tab.length) == 0)</div><div class="line">               tab = initTable();</div></pre></td></tr></table></figure></li></ol></li></ul><p>initTable的代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">    while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">        if ((sc = sizeCtl) &lt; 0)</div><div class="line">            Thread.yield(); // lost initialization race; just spin</div><div class="line">        //通过Unsafe这个类来进行原子操作，如果size仍然为0，那么进行创建</div><div class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">            try &#123;</div><div class="line">                if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                    //设置默认size，默认为16</div><div class="line">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                    //创建size为16的数组</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    //计算ctrl参数为16 - 4 = 12</div><div class="line">                    sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先会通过Unsafe来进行判断是否需要创建table，如果需要，那么直接创建table，默认的初始化table大小为16，同时会设置大小控制参数，初始的sizeCtl为12</p><ol><li><p>如果当前的table不为空，那么查找当前hash值对应的table位置上是否有值，如果有值，直接通过cas设置值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//如果table表指定的位置没有值，</div><div class="line">if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">    //已cas操作的形式直接插入</div><div class="line">    if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                    break;                   // no lock when adding to empty bin</div><div class="line">            &#125;</div></pre></td></tr></table></figure></li><li><p>如果table当前pos已经存储了其他的Node，且当前的hash值是-1，表明当前table正在扩容，则通过多线程帮助其扩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if ((fh = f.hash) == MOVED)</div><div class="line">    tab = helpTransfer(tab, f);</div></pre></td></tr></table></figure></li></ol><p>MOVED是内部定义的常量，值为-1，如果计算出的hash值为MOVE，表明当前正在扩容。这个扩容的内容后续会讲解</p><ol><li>当前table的pos位置有值，且没有到达扩容阈值，需要直接进行覆盖<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">else &#123;</div><div class="line">   V oldVal = null;</div><div class="line">   //对需当前需要替换的节点加锁</div><div class="line">   synchronized (f) &#123;</div><div class="line">       //再次判断需要替换的节点已经被替换</div><div class="line">       if (tabAt(tab, i) == f) &#123;</div><div class="line">               //fh是前面计算出来的f节点的hash值，大于等于0表示当前是已链表的形式进行存储</div><div class="line">               if (fh &gt;= 0) &#123;</div><div class="line">                   binCount = 1;</div><div class="line">                   for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                       K ek;</div><div class="line">                       //判断当前的hash值是否相等，key是否相等</div><div class="line">                       if (e.hash == hash &amp;&amp;</div><div class="line">                           ((ek = e.key) == key ||</div><div class="line">                                   (ek != null &amp;&amp; key.equals(ek)))) &#123;                           //相等，那么找到了需要替换的value</div><div class="line">                           oldVal = e.val;</div><div class="line">                           //如果不是不才替换，那么直接替换,并结束循环</div><div class="line">                           if (!onlyIfAbsent)</div><div class="line">                               e.val = value;</div><div class="line">                               break;</div><div class="line">                           &#125;</div><div class="line"></div><div class="line">                           Node&lt;K,V&gt; pred = e;</div><div class="line">                           //加入没有找到需要替换的节点，那么在节点最后创建新的节点</div><div class="line">                           if ((e = e.next) == null) &#123;</div><div class="line">                               pred.next = new Node&lt;K,V&gt;(hash, key, value,null);</div><div class="line">                                   break;</div><div class="line">                               &#125;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">                       //如果当前是已红黑树进行存储</div><div class="line">                       else if (f instanceof TreeBin) &#123;</div><div class="line">                           Node&lt;K,V&gt; p;</div><div class="line">                           binCount = 2;</div><div class="line">                           //已树的形式寻找节点</div><div class="line">                           if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                          value)) != null) &#123;</div><div class="line">                               oldVal = p.val;</div><div class="line">                               if (!onlyIfAbsent)</div><div class="line">                                   p.val = value;</div><div class="line">                           &#125;</div><div class="line">                       &#125;</div><div class="line">               &#125;</div><div class="line">               if (binCount != 0) &#123;</div><div class="line">                   //如果当前节点数大于8，那么建立为树节点</div><div class="line">                   if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                       treeifyBin(tab, i);</div><div class="line">                   if (oldVal != null)</div><div class="line">                       return oldVal;</div><div class="line">                   break;</div><div class="line">               &#125;</div><div class="line">           &#125;</div></pre></td></tr></table></figure></li></ol><p>在转化为红黑树之前，在table大小小于64时，会对table进行扩容。否则直接创建红黑树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</div><div class="line">                synchronized (b) &#123;</div><div class="line">                    if (tabAt(tab, index) == b) &#123;</div><div class="line">                        TreeNode&lt;K,V&gt; hd = null, tl = null;</div><div class="line">                        for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123;</div><div class="line">                            //创建节点</div><div class="line">                            TreeNode&lt;K,V&gt; p =</div><div class="line">                                new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</div><div class="line">                                                  null, null);</div><div class="line">                            if ((p.prev = tl) == null)</div><div class="line">                                hd = p;</div><div class="line">                            else</div><div class="line">                                tl.next = p;</div><div class="line">                            tl = p;</div><div class="line">                        &#125;</div><div class="line">                        //同时设置头节点，也就是TreeBin</div><div class="line">                        setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p><p>和hashMap相比，其实就是一些同步相关的操作</p><ul><li>通过cas操作初始化table</li><li>通过CAS操作查找node是否存在</li><li>通过CAS操作设置node</li><li>通过多线程并发进行扩容<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div class="line">        //两次hash计算hash计算hash值</div><div class="line">        int h = spread(key.hashCode());</div><div class="line">        //通过CAS操作获取头节点</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</div><div class="line">            //判断是否节点是否符合</div><div class="line">            if ((eh = e.hash) == h) &#123;</div><div class="line">                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div class="line">                    return e.val;</div><div class="line">            &#125;</div><div class="line">            else if (eh &lt; 0)</div><div class="line">                //hash小于0，表示当前以树的形式做存储</div><div class="line">                return (p = e.find(h, key)) != null ? p.val : null;</div><div class="line">            while ((e = e.next) != null) &#123;</div><div class="line"></div><div class="line">                if (e.hash == h &amp;&amp;</div><div class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div class="line">                    return e.val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>get操作也比较简单，先通过cas操作判断node是否存在，其他的操作和普通的hashmap一致。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#HashMap及其并发的一些理解&lt;/p&gt;
&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h2&gt;&lt;p&gt;在jdk1.8之前，HashMap通过数组加链表的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Adnroid Arouter的了解</title>
    <link href="https://xjlhhz.com/2018/11/11/20181111ARouter%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <id>https://xjlhhz.com/2018/11/11/20181111ARouter的简单了解/</id>
    <published>2018-11-11T05:14:00.000Z</published>
    <updated>2018-11-12T07:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>#ARouter</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//&quot;/test/activity2&quot;会在对应的跳转页面内增加标注</div><div class="line">ARouter.getInstance()</div><div class="line">        .build(&quot;/test/activity2&quot;)</div><div class="line">        .navigation();</div></pre></td></tr></table></figure><p>对应的页面跳转页面为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Route(path = &quot;/test/activity2&quot;)</div><div class="line">public class Test2Activity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    String key1;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test2);</div><div class="line"></div><div class="line">        ARouter.getInstance().inject(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>首先通过Route标注一个页面的路由，这个需要保证唯一性。</li><li>@Autowired标注所需要的参数</li><li>在外部页面通过ARouter单例加上设置的路由进行页面切换，然后通过navigation进行跳转。</li><li>在跳转到的页面通过inject方法进行依赖注入。</li></ul><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><h4 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h4><h5 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h5><p>RouteProcessor负责Route的解析和文件的生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</div><div class="line">       if (CollectionUtils.isNotEmpty(annotations)) &#123;</div><div class="line">           Set&lt;? extends Element&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</div><div class="line">           ....</div><div class="line">           this.parseRoutes(routeElements);</div><div class="line">           ....</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return false;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>在processor中解析获取被Route修饰的Element，并且解析。parseRoutes这个方法做了生成代码的操作。最后主要生成以下几个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</div><div class="line">public class ARouter$$Group$$test implements IRouteGroup &#123;</div><div class="line">  @Override</div><div class="line">  public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123;</div><div class="line">  </div><div class="line">    atlas.put(&quot;/test/activity2&quot;, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, &quot;/test/activity2&quot;, &quot;test&quot;, new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(&quot;key1&quot;, 8); &#125;&#125;, -1, -2147483648));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class ARouter$$Root$$app implements IRouteRoot &#123;</div><div class="line">  @Override</div><div class="line">  public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123;</div><div class="line">    routes.put(&quot;service&quot;, ARouter$$Group$$service.class);</div><div class="line">    routes.put(&quot;test&quot;, ARouter$$Group$$test.class);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主要生成的路由映射表，由/test/activity2就可以知道当前需要跳转的activity是Test2Activity.class</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h4><p>通过AutowiredProcessor来解析Autowired注解，并且生成依赖注入代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Test2Activity$$ARouter$$Autowired implements ISyringe &#123;</div><div class="line">  private SerializationService serializationService;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void inject(Object target) &#123;</div><div class="line">    serializationService = ARouter.getInstance().navigation(SerializationService.class);</div><div class="line">    Test2Activity substitute = (Test2Activity)target;</div><div class="line">    substitute.key1 = substitute.getIntent().getStringExtra(&quot;key1&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从intent中取出相对应的key名称的值并且赋值给对应的成员变量。</p><h2 id="navigation操作"><a href="#navigation操作" class="headerlink" title="navigation操作"></a>navigation操作</h2><h3 id="postCard"><a href="#postCard" class="headerlink" title="postCard"></a>postCard</h3><p>在解析跳转方法之前，我们需要先了解下Postcard这个类，这个类主要是用来包装传入的参数，主要是route需要的参数，并且生成一些需要值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected Postcard build(String path) &#123;</div><div class="line">            ...</div><div class="line">            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</div><div class="line">            if (null != pService) &#123;</div><div class="line">                path = pService.forString(path);</div><div class="line">            &#125;</div><div class="line">            return build(path, extractGroup(path));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>PathReplaceService用来做主要提供了两个接口，将原始的uri和path转化为定义好的uri，它的创建过程比较麻烦</p><ul><li><p>首先通过providersIndex，也就是缓存的Iprovider寻找是否已经有对应的RouteMeta，也就是跳转的源信息。通过meta来构建新的postcard实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static Postcard buildProvider(String serviceName) &#123;</div><div class="line">        RouteMeta meta = Warehouse.providersIndex.get(serviceName);</div><div class="line"></div><div class="line">        if (null == meta) &#123;</div><div class="line">            return null;</div><div class="line">        &#125; else &#123;</div><div class="line">            return new Postcard(meta.getPath(), meta.getGroup());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>如果存在所对应postCard实例，直接返回postCard的Provider，这个Pro否则返回null.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> if (null == postcard) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">LogisticsCenter.completion(postcard);</div><div class="line">return (T) postcard.getProvider();</div></pre></td></tr></table></figure></li></ul><p>最后通过path和group创建出postcard实例。<br>postCard有几个比较重要属性是跳转需要用的，action，destination和extra。这几个参数是在completion进行赋值的。</p><ul><li>首先会从缓存中拿RouteMeta</li><li>在缓存中没有对应RouteMeta，那么会Warehouse.groupsIndex中拿取对应的groupMeta,这个map是在application中进行初始化进行赋值的。这个就涉及到了前面自动生成的代码，通过反射奖指定的文件的路径的类添加到集合中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</div><div class="line">                       // This one of root elements, load root.</div><div class="line">                       ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());</div></pre></td></tr></table></figure><p>在通过反射拿到了对应的GroupMeta实例之后，调用自动生成的GroupMeta转化RouteMeta方法进行转化，生成RouteMeta。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</div><div class="line">iGroupInstance.loadInto(Warehouse.routes);</div><div class="line">Warehouse.groupsIndex.remove(postcard.getGroup());</div><div class="line">...</div><div class="line">completion(postcard);   // Reload</div></pre></td></tr></table></figure></p><p>loadInfo就是调用了前面的ARouter Group test的loadInfo方法。<br>同时从groupsIndex移除已经转化过的groupMeta，并且reload,这样，此时获取出来的RouteMeta就是已经存在的。</p><ul><li>RouteMeta已经存在，那么直接为postCard赋值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//目标class，具体的.class</div><div class="line">postcard.setDestination(routeMeta.getDestination());</div><div class="line">//类型，activity</div><div class="line">postcard.setType(routeMeta.getType());</div><div class="line">//跳转优先级。</div><div class="line">postcard.setPriority(routeMeta.getPriority());</div><div class="line">//额外的信息</div><div class="line">postcard.setExtra(routeMeta.getExtra());</div><div class="line">//获取uri</div><div class="line">Uri rawUri = postcard.getUri();</div><div class="line">if (null != rawUri) &#123;   // Try to set params into bundle.</div><div class="line">//参数值</div><div class="line">Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</div><div class="line">//参数类型</div><div class="line">Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</div><div class="line"></div><div class="line">if (MapUtils.isNotEmpty(paramsType)) &#123;</div><div class="line">//将参数值和参数名进行匹配，写入resulteMap中</div><div class="line">for (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</div><div class="line">                        setValue(postcard,</div><div class="line">                                params.getValue(),</div><div class="line">                                params.getKey(),</div><div class="line">                                resultMap.get(params.getKey()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// Save params name which need auto inject.</div><div class="line">postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]&#123;&#125;));</div><div class="line">                &#125;</div><div class="line">// Save raw uri</div><div class="line">postcard.withString(ARouter.RAW_URI, rawUri.toString());</div><div class="line">            &#125;</div></pre></td></tr></table></figure></li></ul><h3 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Object navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback) &#123;</div><div class="line">       return _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>_Arouter是整个router框架实现的核心，跳转时如果是activity，将会执行下面的请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">switch (postcard.getType()) &#123;</div><div class="line">          case ACTIVITY:</div><div class="line">              // Build intent</div><div class="line">              final Intent intent = new Intent(currentContext, postcard.getDestination());</div><div class="line">              intent.putExtras(postcard.getExtras());</div><div class="line"></div><div class="line">              // Set flags.</div><div class="line">              int flags = postcard.getFlags();</div><div class="line">              if (-1 != flags) &#123;</div><div class="line">                  intent.setFlags(flags);</div><div class="line">              &#125; else if (!(currentContext instanceof Activity)) &#123;    // Non activity, need less one flag.</div><div class="line">                  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              // Set Actions</div><div class="line">              String action = postcard.getAction();</div><div class="line">              if (!TextUtils.isEmpty(action)) &#123;</div><div class="line">                  intent.setAction(action);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              // Navigation in main looper.</div><div class="line">              runInMainThread(new Runnable() &#123;</div><div class="line">                  @Override</div><div class="line">                  public void run() &#123;</div><div class="line">                      startActivity(requestCode, currentContext, intent, postcard, callback);</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure></p><p>整个跳转的逻辑其实是非常简单的，</p><ul><li>填充intent</li><li>在context非activity的情况下设置flag</li><li>如果有action，就设置action，表示支持隐式跳转，启动activity</li></ul><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ARouter.getInstance().inject(this);</div></pre></td></tr></table></figure></p><p>来进行intent的参数注入,这个依赖注入就是直接调用了上面自动生成的代码，Autowired，进去intent取值，和成员变量的赋值。，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;#ARouter&lt;/p&gt;
&lt;h2 id=&quot;使用方式&quot;&gt;&lt;a href=&quot;#使用方式&quot; class=&quot;headerlink&quot; title=&quot;使用方式&quot;&gt;&lt;/a&gt;使用方式&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Adnroid processor的一次尝试</title>
    <link href="https://xjlhhz.com/2018/11/04/20181104%E5%85%B3%E4%BA%8EAdnroid%20processor/"/>
    <id>https://xjlhhz.com/2018/11/04/20181104关于Adnroid processor/</id>
    <published>2018-11-04T05:14:00.000Z</published>
    <updated>2018-11-04T09:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# 关于Adnroid processor</p><h2 id="LovelyInject"><a href="#LovelyInject" class="headerlink" title="LovelyInject"></a>LovelyInject</h2><p>项目地址：<a href="https://github.com/xiejinlong/LovelyInject" target="_blank" rel="external">https://github.com/xiejinlong/LovelyInject</a><br>这个是一个基于<a href="https://github.com/enbandari/TieGuanYin库实现的一个简易版的intent注入框架。" target="_blank" rel="external">https://github.com/enbandari/TieGuanYin库实现的一个简易版的intent注入框架。</a></p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>可以使用的有3个注解，BuilderActivity，BuilderFragment和BuilderModel，这三个注解是用来修饰类的,三个注解的retention都是编译期间，targetType都是ElementType.TYPE，也就是用来修饰Class。<br>其中，BuilderActivity用来修饰Activity，可以指定默认的跳转Scheme，会生成一个通过scheme跳转的静态方法。<br>BuilderFragme用来修饰Fragment。<br>BuilderModel用来修饰普通的model类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">@Target(ElementType.TYPE)</div></pre></td></tr></table></figure></p><ul><li><p>修饰activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@BuilderActivity(routerValue = &quot;to_test_scheme&quot;)</div><div class="line">    class TestActivity: Activity() &#123;</div><div class="line">    @Fields</div><div class="line">    var name: String? = null</div><div class="line">    @Fields</div><div class="line">    var age: Int = 0</div><div class="line">    @Fields</div><div class="line">    var msg: String? = null</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>修饰fragment</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@BuilderFragment</div><div class="line">    class TestFragment: Fragment() &#123;</div><div class="line">    @Fields</div><div class="line">    var name: String? = null</div><div class="line">    @Fields</div><div class="line">    var age: Int = 0</div><div class="line">    @Fields</div><div class="line">    var msg: String? = null</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>修饰model类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@BuilderModel</div><div class="line">    class TestModel &#123;</div><div class="line">    @Fields</div><div class="line">    var name: String? = null</div><div class="line">    @Fields</div><div class="line">    var age: Int = 0</div><div class="line">    @Fields</div><div class="line">    var msg: String? = null</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><h4 id="编译build"><a href="#编译build" class="headerlink" title="编译build"></a>编译build</h4><ul><li><p>生成的ActivityBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public final class TestActivityBuilder &#123;</div><div class="line">  public static final String FIELD_NAME = &quot;name&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_AGE = &quot;age&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_MSG = &quot;msg&quot;;</div><div class="line"></div><div class="line">  private String name;</div><div class="line"></div><div class="line">  private int age;</div><div class="line"></div><div class="line">  private String msg;</div><div class="line"></div><div class="line">  public static TestActivityBuilder builder() &#123;</div><div class="line">    TestActivityBuilder builder = new TestActivityBuilder();</div><div class="line">    return builder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestActivityBuilder name(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestActivityBuilder age(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestActivityBuilder msg(String msg) &#123;</div><div class="line">    this.msg = msg;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private void fillIntent(Intent intent) &#123;</div><div class="line">    intent.putExtra(&quot;name&quot;, name);</div><div class="line">    intent.putExtra(&quot;age&quot;, age);</div><div class="line">    intent.putExtra(&quot;msg&quot;, msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void start(Context context) &#123;</div><div class="line">    Intent intent = new Intent(context, TestActivity.class);</div><div class="line">    fillIntent(intent);</div><div class="line">    context.startActivity(intent);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></li><li><p>生成的fragmentBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">public final class TestFragmentBuilder &#123;</div><div class="line">  public static final String FIELD_NAME = &quot;name&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_AGE = &quot;age&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_MSG = &quot;msg&quot;;</div><div class="line"></div><div class="line">  private String name;</div><div class="line"></div><div class="line">  private int age;</div><div class="line"></div><div class="line">  private String msg;</div><div class="line"></div><div class="line">  public static TestFragmentBuilder builder() &#123;</div><div class="line">    TestFragmentBuilder builder = new TestFragmentBuilder();</div><div class="line">    return builder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragmentBuilder name(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragmentBuilder age(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragmentBuilder msg(String msg) &#123;</div><div class="line">    this.msg = msg;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private void fillIntent(Intent intent) &#123;</div><div class="line">    intent.putExtra(&quot;name&quot;, name);</div><div class="line">    intent.putExtra(&quot;age&quot;, age);</div><div class="line">    intent.putExtra(&quot;msg&quot;, msg);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestFragment build() &#123;</div><div class="line">    TestFragment fragment = new TestFragment();</div><div class="line">    Intent intent = new Intent();</div><div class="line">    fillIntent(intent);</div><div class="line">    fragment.setArguments(intent.getExtras());</div><div class="line">    return fragment;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>-生成的modelBuilder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public final class TestModelBuilder &#123;</div><div class="line">  public static final String FIELD_NAME = &quot;name&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_AGE = &quot;age&quot;;</div><div class="line"></div><div class="line">  public static final String FIELD_MSG = &quot;msg&quot;;</div><div class="line"></div><div class="line">  private String name;</div><div class="line"></div><div class="line">  private int age;</div><div class="line"></div><div class="line">  private String msg;</div><div class="line"></div><div class="line">  public static TestModelBuilder builder() &#123;</div><div class="line">    TestModelBuilder builder = new TestModelBuilder();</div><div class="line">    return builder;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModelBuilder name(String name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModelBuilder age(int age) &#123;</div><div class="line">    this.age = age;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModelBuilder msg(String msg) &#123;</div><div class="line">    this.msg = msg;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public TestModel build() &#123;</div><div class="line">    TestModel model = new TestModel();</div><div class="line">    return model;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这三个builder文件基本类似，每个@Fields修饰的成员变量都将生成一个对应的builder方法。activityBuilder会多一个fillIntent方法和start方法，用来填充intent和开启新页面。而fragmentBuilder会多一个fillIntent方法和build方法，fillIntent也是用来填充intent，而build方法是用来返回fragment实例的。</p><h3 id="使用Builder"><a href="#使用Builder" class="headerlink" title="使用Builder"></a>使用Builder</h3><ul><li><p>in ActivityBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//调用</div><div class="line">TestActivityBuilder.builder().age(12)</div><div class="line">                    .name(&quot;xie&quot;)</div><div class="line">                    .msg(&quot;我是从mainAc过来的参数&quot;)</div><div class="line">                    .start(this)</div><div class="line">//使用变量，in TestActivity</div><div class="line"> Toast.makeText(this,</div><div class="line">                &quot;我是 $name，今年 $age, $msg&quot;, Toast.LENGTH_LONG).show()</div></pre></td></tr></table></figure></li><li><p>in fragmentBuilder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//调用</div><div class="line">fragmentManager.beginTransaction()</div><div class="line">                    .replace(R.id.mainLayout,</div><div class="line">                            TestFragmentBuilder.builder()</div><div class="line">                                    .name(&quot;lovely&quot;)</div><div class="line">                                    .age(13)                                .msg(&quot;我是从testAc过来的参数&quot;).build())</div><div class="line">                    .commitAllowingStateLoss()</div><div class="line">//使用变量，in TestFragment</div><div class="line"> Toast.makeText(context,</div><div class="line">                &quot;我是 $name，今年 $age, $msg&quot;, Toast.LENGTH_LONG).show()</div></pre></td></tr></table></figure></li></ul><h2 id="Prossor生成代码原理"><a href="#Prossor生成代码原理" class="headerlink" title="Prossor生成代码原理"></a>Prossor生成代码原理</h2><p>上面就是通过builder生成的代码来给我简化使用流程，每一个activity和fragment都会相对应的生成一个Builder类来供我们使用。下面我们来详细了解一下这个框架的原理实现。</p><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><p>Element是基类，可在不同的情况下转化成不同的子类，具体的类型可以通过getKind方法获得</p><ul><li>TypeElement: 表示类或者接口</li><li>VariableElement: 表示字段参数</li><li>PackageElement: 表示一个包</li><li>ExecutableElement: 表示方法</li><li>TypeParameterElement: 表示范型参数</li></ul><h4 id="TypeMirror"><a href="#TypeMirror" class="headerlink" title="TypeMirror"></a>TypeMirror</h4><p>Element表示的是元素，而TypeMirror表示的是参数类型。可以通过getkind来获取参数类型。</p><h4 id="TypeSpec"><a href="#TypeSpec" class="headerlink" title="TypeSpec"></a>TypeSpec</h4><p>是javapoet库用来生成文件的主要的类。</p><h4 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h4><p>ProcessingEnvironment中提供了4个工具接口</p><ul><li>lateinit var types: Types //java类型工具</li><li>lateinit var elements: Elements //注解获取出来的元素</li><li>lateinit var messager: Messager//消息输出</li><li>lateinit var filer: Filer//文件写入</li></ul><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><ol><li><p>首先我们需要先创建出Annotation库，创建出对应的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Retention(RetentionPolicy.CLASS)</div><div class="line">@Target(ElementType.TYPE)</div><div class="line">public @interface BuilderActivity &#123;</div><div class="line">    String routerValue() default &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>创建出Processor库，并且自定义Processor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class KKProcessor : AbstractProcessor() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>在这里需要注意的是，我们必须手动的建立Processor索引，不然编译期间不会执行到这个Processor。<br>需要在和java同级目下创建出resources/META-INF/services/javax.annotation.processing.Processor文件，然后在内部添加processor的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.inject.xie.processor.KKProcessor</div></pre></td></tr></table></figure></p><p>而且，需要在app的gradle中添加该processor的编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kapt project(&quot;:Processor&quot;)</div></pre></td></tr></table></figure></p><ol><li>开始编译，解析注解<br>在编译时，会调用到processor的process方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override fun process(p0: MutableSet&lt;out TypeElement&gt;?, p1: RoundEnvironment?): Boolean &#123;</div><div class="line">        LogUtils.warn(&quot;KKProcessor process&quot;)</div><div class="line"></div><div class="line">        return true</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ol><p>在这个方法中，我们需要解析出我们要的注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//解析class</div><div class="line">env.getElementsAnnotatedWith(BuilderActivity::class.java)</div><div class="line">                .asSequence()</div><div class="line">                .filter(SuperficialValidation::validateElement)</div><div class="line">                .filter &#123; it.kind.isClass &#125;</div><div class="line">                .toList()</div><div class="line">                .forEach &#123; element -&gt;</div><div class="line">                    LogUtils.warn(&quot;KKProcessor parasClass $&#123;element.simpleName&#125; is Activity~&quot;)</div><div class="line">                    if (ProcessorEnv.types.isSubtype(element.asType(), ClassType.KKACTIVITY.typeMirror)) &#123;</div><div class="line">                        classMap[element] = KKActivityBuilder(element as TypeElement)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>通过getElementsAnnotatedWith方法来获取被BuilderActivity修饰的所有的类。其他几个注解类似，然后存储在classMap，这里需要注意一点，process方法可能会执行多次，所以需要将解析的产物放在map中或者每次解析都将list清空。<br>然后解析field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private fun parasFiled(env: RoundEnvironment) &#123;</div><div class="line">        env.getElementsAnnotatedWith(Fields::class.java)</div><div class="line">                .asSequence()</div><div class="line">                .filter(SuperficialValidation::validateElement)</div><div class="line">                .filter &#123; it.kind.isField &#125;</div><div class="line">                .toList()</div><div class="line">                .forEach &#123; element -&gt;</div><div class="line">                    LogUtils.warn(&quot;KKProcessor parasFiled $&#123;element.simpleName&#125;&quot;)</div><div class="line">                    classMap[element.enclosingElement]?.addFiled(element)</div><div class="line">                &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>将解析生成的fields存储到上一步生成的class产物中，这样，就拿到了被注解的类和其中的被注解的成员变量。</p><ol><li>生成代码</li></ol><ul><li><p>创建class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val classFileBuilder = TypeSpec.classBuilder(builderClassName)</div><div class="line">        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</div></pre></td></tr></table></figure></li><li><p>创建成员及成员的builder方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fields.forEach &#123; field -&gt;</div><div class="line">            LogUtils.warn(&quot;fieldBuilder $&#123;field.name&#125;&quot;)</div><div class="line">            //构造临时变量</div><div class="line">            classFileBuilder.addField(FieldSpec.builder(field.asTypeName(), field.name, Modifier.PRIVATE).build())</div><div class="line"></div><div class="line">            //构造变量相关的静态变量</div><div class="line">            classFileBuilder.addField(FieldSpec.builder(String::class.java, KKActivityBuilder.CONST_POSIX + field.name.toUpperCase())</div><div class="line">                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)</div><div class="line">                    .initializer(&quot;\$S&quot;, field.name)</div><div class="line">                    .build())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">            //构造相关变量的builder方法</div><div class="line">            classFileBuilder.addMethod(MethodSpec.methodBuilder(field.name)</div><div class="line">                    .addModifiers(Modifier.PUBLIC)</div><div class="line">                    .addParameter(field.asTypeName(), field.name)</div><div class="line">                    .addStatement(&quot;this.$&#123;field.name&#125; = $&#123;field.name&#125;&quot;)</div><div class="line">                    .addStatement(&quot;return this&quot;)</div><div class="line">                    .returns(builderClassTypeName)</div><div class="line">                    .build())</div><div class="line">        &#125;</div></pre></td></tr></table></figure></li><li><p>创建方法<br>首先需要静态的builder方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//构造主builder</div><div class="line">        classFileBuilder.addMethod(MethodSpec.methodBuilder(&quot;builder&quot;)</div><div class="line">                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</div><div class="line">                .returns(builderClassTypeName)</div><div class="line">                .addStatement(&quot;\$T builder = new \$T()&quot;, builderClassTypeName, builderClassTypeName)</div><div class="line">                .addStatement(&quot;return builder&quot;).build())</div></pre></td></tr></table></figure></li></ul><p>对于Activity，需要创建fillIntent和start方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//对于Activity，需要创建fillIntent和start方法</div><div class="line">       val intentMethod = MethodSpec.methodBuilder(&quot;fillIntent&quot;)</div><div class="line">               .addModifiers(Modifier.PRIVATE)</div><div class="line">               .addParameter(INTENT.java, &quot;intent&quot;)</div><div class="line">       fields.forEach &#123; field -&gt;</div><div class="line">           //给fillIntent方法添加元素</div><div class="line">           intentMethod.addStatement(&quot;intent.putExtra(\$S, \$L)&quot;, field.name, field.name)</div><div class="line">       &#125;</div><div class="line">       typeBuilder.addMethod(intentMethod.build())</div><div class="line"></div><div class="line"></div><div class="line">       //start</div><div class="line">       typeBuilder.addMethod(MethodSpec.methodBuilder(&quot;start&quot;)</div><div class="line">               .addModifiers(Modifier.PUBLIC)</div><div class="line">               .addParameter(CONTEXT.java, &quot;context&quot;)</div><div class="line">               .addStatement(&quot;Intent intent = new Intent(context, \$L.class)&quot;, simpleName)</div><div class="line">               .addStatement(&quot;fillIntent(intent)&quot;)</div><div class="line">               .addStatement(&quot;context.startActivity(intent)&quot;)</div><div class="line">               .build())</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>对于fragment需要创建fillIntent和build方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//fragment也需要fillIntent</div><div class="line">     val intentMethod = MethodSpec.methodBuilder(&quot;fillIntent&quot;)</div><div class="line">             .addModifiers(Modifier.PRIVATE)</div><div class="line">             .addParameter(ClassType.INTENT.java, &quot;intent&quot;)</div><div class="line">     fields.forEach &#123; field -&gt;</div><div class="line">         //给fillIntent方法添加元素</div><div class="line">         intentMethod.addStatement(&quot;intent.putExtra(\$S, \$L)&quot;, field.name, field.name)</div><div class="line">     &#125;</div><div class="line">     typeBuilder.addMethod(intentMethod.build())</div><div class="line"></div><div class="line"></div><div class="line">     val originClassName = ClassName.get(packageName, simpleName.toString())</div><div class="line">     //通过builder方法返回实例</div><div class="line">     typeBuilder.addMethod(MethodSpec.methodBuilder(&quot;build&quot;)</div><div class="line">             .returns(originClassName)</div><div class="line">             .addModifiers(Modifier.PUBLIC)</div><div class="line">             .addStatement(&quot;\$T fragment = new \$T()&quot;, originClassName, originClassName)</div><div class="line">             .addStatement(&quot;Intent intent = new Intent()&quot;)</div><div class="line">             .addStatement(&quot;fillIntent(intent)&quot;)</div><div class="line">             .addStatement(&quot;fragment.setArguments(intent.getExtras())&quot;)</div><div class="line">             .addStatement(&quot;return fragment&quot;)</div><div class="line">             .build())</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><ul><li>写入文件<br>当构建好了TypeSpec，通过Filer进行文件写入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private fun writeJavaToFile(typeSpec: TypeSpec) &#123;</div><div class="line">       try &#123;</div><div class="line">           val file = JavaFile.builder(packageName, typeSpec).build()</div><div class="line">           file.writeTo(ProcessorEnv.filer)</div><div class="line">       &#125; catch (e: IOException) &#123;</div><div class="line">           e.printStackTrace()</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ul><p>这样，对应的生成文件就创建出来了。</p><ol><li>依赖注入<br>在文件生成之后，我们通过对应的Builder类来启动activity或者创建fragment实例，那我们如何直接在activity或者fragment中直接使用被注解的成员变量呢？这个其实也比较简单。</li></ol><ul><li>对于activity<br>在application中注册activity监听，然后通过onActivityCreate的回调方法中进行inject，这个方法会在oncreate之前调用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"> override fun onActivityCreated(activity: Activity?, savedInstanceState: Bundle?) &#123;</div><div class="line">                if (activity == null) &#123;</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line">                if (!activity.javaClass.isAnnotationPresent(BuilderActivity::class.java)) &#123;</div><div class="line">                    //该activity没有被Builder标注，跳过</div><div class="line">                    return</div><div class="line">                &#125;</div><div class="line">                Log.d(&quot;KKActivityBuilder&quot;, &quot;onActivityCreated~&quot;)</div><div class="line">                val intent = activity.intent ?: return</div><div class="line">                var fields = activity.javaClass.declaredFields</div><div class="line">                inject(activity, fields, intent.extras)</div><div class="line">            &#125;</div><div class="line"></div><div class="line">fun inject(activity: Activity?, fields: Array&lt;Field&gt;?, extras: Bundle?) &#123;</div><div class="line">        if (fields == null) &#123;</div><div class="line">            Log.d(&quot;KKActivityBuilder&quot;, &quot;declaredFields is null, should return~&quot;)</div><div class="line">            return</div><div class="line">        &#125;</div><div class="line">        fields.forEach &#123; field -&gt;</div><div class="line">            if (field.isAnnotationPresent(Fields::class.java)) &#123;</div><div class="line">                val name = field.name</div><div class="line">                try &#123;</div><div class="line">                    val access = field.isAccessible</div><div class="line">                    if (!access) field.isAccessible = true</div><div class="line">                    val value = getIntentExtra(extras, name)</div><div class="line">                    if (value != null) &#123;</div><div class="line">                        field.set(activity, getIntentExtra(extras, name))</div><div class="line">                    &#125; else &#123;</div><div class="line">                        Log.d(&quot;KKActivityBuilder&quot;, &quot;get value is null, continue~&quot;)</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (!access) field.isAccessible = false</div><div class="line"></div><div class="line">                &#125; catch (e: Exception) &#123;</div><div class="line">                    Log.e(&quot;KKActivityBuilder&quot;, &quot;error in -&gt; $&#123;e.message&#125;&quot;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fun  getIntentExtra(extras: Bundle?, name: String): Any? &#123;</div><div class="line">        return extras?.get(name)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><ol><li>判断当前的activity是否被BuilderActivity修饰过</li><li>如果被BuilderActivity修饰过，遍历fields，判断是否被Fields修饰过</li><li>如果被Fields修饰过，从intent中获取field的name对应的value，以object的形式取出即可</li><li>通过反射，给field赋值为上一步取出的值。</li><li>完成</li></ol><ul><li>对于fragment<br>fragment的注入其实与activity基本一致，只是fragment没有相对应的生命周期的监听，不过我们可以在统一的基类的onCreateView方法中调用inject方法进行注入。实际的注入流程完全一样。不过activity是从intent中取值，fragment是从argument中取值。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# 关于Adnroid processor&lt;/p&gt;
&lt;h2 id=&quot;LovelyInject&quot;&gt;&lt;a href=&quot;#LovelyInject&quot; class=&quot;headerlink&quot; title=&quot;LovelyInject&quot;&gt;&lt;/a&gt;LovelyInject&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>flutter的常见问题</title>
    <link href="https://xjlhhz.com/2018/10/08/20181008flutter%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://xjlhhz.com/2018/10/08/20181008flutter常见问题/</id>
    <published>2018-10-08T05:14:00.000Z</published>
    <updated>2018-11-04T09:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何实现android的match-param？"><a href="#如何实现android的match-param？" class="headerlink" title="如何实现android的match_param？"></a>如何实现android的match_param？</h4><p>flutter控件默认的宽高为wrap_content<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Container(</div><div class="line">    width:double.infinity,</div><div class="line">)</div></pre></td></tr></table></figure></p><p>通过设置宽度为double.infinity，将会将宽度填充父布局.</p><h4 id="如何获取状态栏的高度"><a href="#如何获取状态栏的高度" class="headerlink" title="如何获取状态栏的高度"></a>如何获取状态栏的高度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final double statusBarHeight = MediaQuery.of(context).padding.top;</div><div class="line">return new Padding(</div><div class="line">      padding: new EdgeInsets.only(top: statusBarHeight),</div><div class="line">      child: content</div><div class="line">);</div></pre></td></tr></table></figure><h4 id="如何检测系统返回键"><a href="#如何检测系统返回键" class="headerlink" title="如何检测系统返回键"></a>如何检测系统返回键</h4><p>需要再外部的Widget嵌套一层WillPopScope来捕获返回事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class HomePageState extends State&lt;HomePage&gt; &#123;</div><div class="line">  @override</div><div class="line">  Widget build(BuildContext context) &#123;</div><div class="line"></div><div class="line">    return WillPopScope(</div><div class="line">        child: Scaffold(</div><div class="line">          appBar: new AppBar(</div><div class="line">            backgroundColor: new Color(0xfffde23d),</div><div class="line">            title: new Text(&quot;快看漫画&quot;,</div><div class="line">                style: new TextStyle(color: const Color(0xff442509))),</div><div class="line">          ),</div><div class="line">          body: new Container(),</div><div class="line">        ),</div><div class="line">        onWillPop: _onWillPop);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Future&lt;bool&gt; _onWillPop() &#123;</div><div class="line">    exit(0);</div><div class="line">    return new Future.value(false);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以通过dart:io的方法exit(0)来退出app。</p><h4 id="bottomTab"><a href="#bottomTab" class="headerlink" title="bottomTab"></a>bottomTab</h4><p>flutter为我们提供了bottomTab的控件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">bottomNavigationBar: new CupertinoTabBar(</div><div class="line">            items: &lt;BottomNavigationBarItem&gt;[</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                icon: getTabIcon(0),</div><div class="line">                title: getTabTitle(0)</div><div class="line">              ),</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                  icon: getTabIcon(1),</div><div class="line">                  title: getTabTitle(1)</div><div class="line">              ),</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                  icon: getTabIcon(2),</div><div class="line">                  title: getTabTitle(2)</div><div class="line">              ),</div><div class="line">              BottomNavigationBarItem(</div><div class="line">                  icon: getTabIcon(3),</div><div class="line">                  title: getTabTitle(3)</div><div class="line">              )</div><div class="line">            ],</div><div class="line">            currentIndex: currentSelectIndex,</div><div class="line">            onTap: (index)&#123;</div><div class="line">              setState(() &#123;</div><div class="line">                currentSelectIndex = index;</div><div class="line">              &#125;);</div><div class="line">            &#125;,</div></pre></td></tr></table></figure></p><p>这个控件是Scaffold内置的控件，currentIndex设置当前选中的index，可以通过onTab获取选中的index。</p><h4 id="Column内部控件的居中"><a href="#Column内部控件的居中" class="headerlink" title="Column内部控件的居中"></a>Column内部控件的居中</h4><p>可以通过mainAxisAlignment属性来设置整体列表的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">child: new Column(</div><div class="line">                     mainAxisAlignment: MainAxisAlignment.center,</div><div class="line">                     children: &lt;Widget&gt;[</div><div class="line">                       new CircleAvatar(</div><div class="line">                         backgroundImage: new AssetImage(&apos;images/ic_personal_headportrait.png&apos;),</div><div class="line">                       ),</div><div class="line">                       new Text(&quot;点击登陆&quot;)</div><div class="line">                     ],</div><div class="line">                   )</div></pre></td></tr></table></figure></p><h4 id="对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。"><a href="#对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。" class="headerlink" title="对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。"></a>对于Android使用的EditText，可以用TextField来代替，但是如果在列表中，则需要使用Flexible包裹着，否则将会报错。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;如何实现android的match-param？&quot;&gt;&lt;a href=&quot;#如何实现android的match-param？&quot; class=&quot;headerlink&quot; title=&quot;如何实现android的match_param？&quot;&gt;&lt;/a&gt;如何实现android的ma
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A Tour of the Dart Language</title>
    <link href="https://xjlhhz.com/2018/09/09/20180919Dart%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    <id>https://xjlhhz.com/2018/09/09/20180919Dart文档翻译/</id>
    <published>2018-09-09T05:14:00.000Z</published>
    <updated>2018-11-04T09:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>﻿# A Tour of the Dart Language</p><p>下面是一个比较基础的Dart的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//定义一个方法</div><div class="line">printInteger(int aNumber) &#123;</div><div class="line">  print(&apos;The number is $aNumber.&apos;); // 输出到终端</div><div class="line">&#125;</div><div class="line"></div><div class="line">//一个app启动的入口</div><div class="line">main() &#123;</div><div class="line">  var number = 42; // 初始化一个变量</div><div class="line">  printInteger(number); // 调用方法</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><ul><li>每一个变量都是一个object，并且每一个object都是class的实例，甚至是一个数字、方法或者是null也是object，所有的对象继承于Object。</li><li>虽然Dart是一个强类型，但类型的声明是可选的，因为Dart可以推断出其类型，就像上面的代码，数字42将被推断出其类型是int。如果我们想要明确的一个对象没有指定的类型，那么我们可以使用动态类型。如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void log(Object object) &#123;</div><div class="line">  print(object.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// Returns a Boolean representation for [arg], which must</div><div class="line">/// be a String or bool.</div><div class="line">bool convertToBool(dynamic arg) &#123;</div><div class="line">  if (arg is bool) return arg;</div><div class="line">  if (arg is String) return arg == &apos;true&apos;;</div><div class="line">  throw ArgumentError(&apos;Cannot convert $arg to a bool.&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>我们可以将参数定义为dynamic，也可以将参数定义为Object。有一些方法是任意的对象都会有的，比如说上面的log方法，接收了一个Object的参数，然后调用了object的toString方法，dynamic是一个比较复杂的关键字，这就意味着Dart的类型系统足够复杂，复杂到能够展示所有其支持的类型，或者其值需要通过交互来获得或者它是一个在静态类型系统的范围之外的，因此我们能够在运行时明确的指出其类型和值。</p><ul><li><p>Dart支持普通类型，比如说 List<int>和List<dynamic> ，表示int类型的列表和动态类型的列表</dynamic></int></p></li><li><p>dart支持顶层方法，比如说main方法，和方法绑定在class或者object一样(静态和实例方法除外)， 同样的你也可以在方法内创建方法，嵌套方法或者局部方法</p></li><li>同样的，Dart支持顶层变量，和绑定在class或者object的变量是一样的(静态和实例变量)，实例变量在有些时候被成为是fields or properties.</li><li>和java不一样的是，Dart没有public, protected, and private关键字，如果一个标识符已括号开始， (_), 那么它是库私有的，</li><li>标识符可以从下划线(_)或者字母开始，通过任意的字母加数字的合并来排序</li><li>有时候我们可能疑惑某个东西是一个语句或者表达式，所以它可以帮助我们区分这两个东西</li><li>Dart工具可以帮我们反映两种类型的问题： 警告和错误，警告只是预测我们的代码可能会不能如期工作，但是它们不会中断我们代码的运行。Error可能出现在编译期间或者运行时，一个编译期间的错误将会直接停止代码的运行，一个运行时的错误将会抛出异常</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name = &apos;Bob&apos;;</div></pre></td></tr></table></figure><p>定义一个String类型的变量，并为其赋值为Bob。如果一个对象我们不想让它只受限于单一类型，那么我们可以将它的类型定义为Object或者Dynamic。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dynamic name = &apos;Bob&apos;;</div></pre></td></tr></table></figure></p><p>当然我们也可以声明一个确定的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String name = &apos;Bob&apos;;</div></pre></td></tr></table></figure></p><p>相对于确定类型，Dart更推荐我们使用var。</p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果一个没有初始化的变量，那么它的默认值就是null，甚至的数值类型也会未初始化时，也会是null，因为数字类型和其他类型在dart中都是一样的，都是对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int lineCount;</div><div class="line">assert(lineCount == null);</div></pre></td></tr></table></figure></p><p>assert将会在生产环境中会忽略，如果在开发环境中，assert的不为真，那么将会抛出异常。</p><h2 id="final和const"><a href="#final和const" class="headerlink" title="final和const"></a>final和const</h2><p>如果我们不尝试去改变一个变量，我们可以使用final或const去修饰变量，final的变量只允许被设置一次，const变量是一个编译时常量，const其实内部也是final，一个顶层的、class的final变量将会在第一次使用时赋值。实例变量不能声明为final但是可以声明为const。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final name = &apos;Bob&apos;; // Without a type annotation</div><div class="line">final String nickname = &apos;Bobby&apos;;</div></pre></td></tr></table></figure></p><p>一旦赋值过后将不能再进行改变。下面的语句将会在编译期间报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name = &apos;Alice&apos;; // Error: a final variable can only be set once.</div></pre></td></tr></table></figure></p><p>const关键字不仅仅能修饰变量，我们可以用来创建常量，也能够声明构造器去创建常量，每一个变量都可以有一个常量值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//const创建常量[]</div><div class="line">var foo = const [];</div><div class="line">final bar = const [];</div><div class="line">const baz = []; // Equivalent to `const []`</div></pre></td></tr></table></figure></p><p>实际上我们可以忽略初始化时const的声明。比如说下面的[1, 2, 3]就是一个const的数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo = [1, 2, 3];</div></pre></td></tr></table></figure></p><p>同样的，const也不能够被赋值。</p><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><ul><li>数值类型</li><li>String类型</li><li>boolean类型</li><li>list类型(通常是数组)</li><li>map类型</li><li>runes(unicode的String)</li><li>symbols</li></ul><p>在dart中，每一个变量都是一个对象，一个class的实例，我们可以通过构造函数来初始化变量，一些内置类型有它们特有的构造函数，比如说我们可以通过Map()来创建map对象。</p><h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>Dart的numbers有两种表示方式：</p><ul><li>int 取值为-2的63次方到 2的63次方 - 1</li><li>double</li></ul><p>我们可以对这两种类型使用number提供的方法，比如说+-*/,或者abs、ceil和floor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int x = 1;</div><div class="line">int hex = 0xDEADBEEF;</div><div class="line"></div><div class="line">double y = 1.1;</div><div class="line">double exponents = 1.42e5;</div></pre></td></tr></table></figure></p><p>下面是一个String和number类型互转的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// String -&gt; int</div><div class="line">var one = int.parse(&apos;1&apos;);</div><div class="line">assert(one == 1);</div><div class="line"></div><div class="line">// String -&gt; double</div><div class="line">var onePointOne = double.parse(&apos;1.1&apos;);</div><div class="line">assert(onePointOne == 1.1);</div><div class="line"></div><div class="line">// int -&gt; String</div><div class="line">String oneAsString = 1.toString();</div><div class="line">assert(oneAsString == &apos;1&apos;);</div><div class="line"></div><div class="line">// double -&gt; String</div><div class="line">String piAsString = 3.14159.toStringAsFixed(2);</div><div class="line">assert(piAsString == &apos;3.14&apos;);</div></pre></td></tr></table></figure></p><p>下面是&lt;&lt; &gt;&gt; | 符号的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">assert((3 &lt;&lt; 1) == 6); // 0011 &lt;&lt; 1 == 0110</div><div class="line">assert((3 &gt;&gt; 1) == 1); // 0011 &gt;&gt; 1 == 0001</div><div class="line">assert((3 | 4) == 7); // 0011 | 0100 == 0111</div></pre></td></tr></table></figure></p><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>Dart String是一个UTF-16编码格式的，下面是几个创建String的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s1 = &apos;Single quotes work well for string literals.&apos;;</div><div class="line">var s2 = &quot;Double quotes work just as well.&quot;;</div><div class="line">var s3 = &apos;It\&apos;s easy to escape the string delimiter.&apos;;</div><div class="line">var s4 = &quot;It&apos;s even easier to use the other delimiter.&quot;;</div></pre></td></tr></table></figure></p><p>我们可以通过$在String的字符串中引用其他变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s = &apos;string interpolation&apos;;</div><div class="line"></div><div class="line">assert(&apos;Dart has $s, which is very handy.&apos; ==</div><div class="line">    &apos;Dart has string interpolation, &apos; +</div><div class="line">        &apos;which is very handy.&apos;);</div><div class="line">assert(&apos;That deserves all caps. &apos; +</div><div class="line">        &apos;$&#123;s.toUpperCase()&#125; is very handy!&apos; ==</div><div class="line">    &apos;That deserves all caps. &apos; +</div><div class="line">        &apos;STRING INTERPOLATION is very handy!&apos;);</div></pre></td></tr></table></figure></p><p>需要注意的是 == 是用来比较两个对象是否相等<br>String类型也能用+来进行拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var s1 = &apos;String &apos;</div><div class="line">    &apos;concatenation&apos;</div><div class="line">    &quot; works even over line breaks.&quot;;</div><div class="line">assert(s1 ==</div><div class="line">    &apos;String concatenation works even over &apos;</div><div class="line">    &apos;line breaks.&apos;);</div><div class="line"></div><div class="line">var s2 = &apos;The + operator &apos; + &apos;works, as well.&apos;;</div><div class="line">assert(s2 == &apos;The + operator works, as well.&apos;);</div></pre></td></tr></table></figure></p><p>如果我们想要创建一个多行的String，那么我们可以使用’’’或者”””来创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s1 = &apos;&apos;&apos;</div><div class="line">You can create</div><div class="line">multi-line strings like this one.</div><div class="line">&apos;&apos;&apos;;</div><div class="line"></div><div class="line">var s2 = &quot;&quot;&quot;This is also a</div><div class="line">multi-line string.&quot;&quot;&quot;;</div></pre></td></tr></table></figure></p><p>如果我们想要创建一个raw字符串，我们可以在字符串前面拼接一个r<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var s = r&apos;In a raw string, not even \n gets special treatment.&apos;;</div></pre></td></tr></table></figure></p><p>如果我们想要将编码后的字符，比如说一些表情和文字符号，转化成字符串，那么我们可以使用Runnes。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">main() &#123;</div><div class="line">  var clapping = &apos;\u&#123;1f44f&#125;&apos;;</div><div class="line">  print(clapping);</div><div class="line">  print(clapping.codeUnits);</div><div class="line">  print(clapping.runes.toList());</div><div class="line"></div><div class="line">  Runes input = new Runes(</div><div class="line">      &apos;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&apos;);</div><div class="line">  print(new String.fromCharCodes(input));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>String也可以作为编译时常量，也就是能被const修饰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// These work in a const string.</div><div class="line">const aConstNum = 0;</div><div class="line">const aConstBool = true;</div><div class="line">const aConstString = &apos;a constant string&apos;;</div><div class="line"></div><div class="line">// These do NOT work in a const string.</div><div class="line">var aNum = 0;</div><div class="line">var aBool = true;</div><div class="line">var aString = &apos;a string&apos;;</div><div class="line">const aConstList = [1, 2, 3];</div><div class="line"></div><div class="line">const validConstString = &apos;$aConstNum $aConstBool $aConstString&apos;;</div><div class="line">// const invalidConstString = &apos;$aNum $aBool $aString $aConstList&apos;;</div></pre></td></tr></table></figure></p><h3 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h3><p>为了展示boolean，Dart使用了bool类型，只有两个对象有这个类型，那就是true和false。这两个都是编译时常量。<br>Dart是类型安全的，这就意味着我们不能够在判断中使用非bool类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Check for an empty string.</div><div class="line">var fullName = &apos;&apos;;</div><div class="line">assert(fullName.isEmpty);</div><div class="line"></div><div class="line">// Check for zero.</div><div class="line">var hitPoints = 0;</div><div class="line">assert(hitPoints &lt;= 0);</div><div class="line"></div><div class="line">// Check for null.</div><div class="line">var unicorn;</div><div class="line">assert(unicorn == null);</div><div class="line"></div><div class="line">// Check for NaN.</div><div class="line">var iMeantToDoThis = 0 / 0;</div><div class="line">assert(iMeantToDoThis.isNaN);</div></pre></td></tr></table></figure></p><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>大部分语言中最常用到的集合类应该就是数组或有序的对象组，在Dart中，数组是List对象，所以大部分人将其称之为列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var list = [1, 2, 3];</div></pre></td></tr></table></figure></p><p>同样的，list是有类型的，在上面的例子能够推断出类型是List<int>,如果尝试将非int类型的对象添加到列表中，那么将会报错。<br>和其他语言一样，Dart的list也是从0开始计数的。</int></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Dart中map也是有类型的，map中的key也是唯一的，但是value可以重复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var gifts = &#123; // Key：Value&apos;first &apos; ：&apos;partridge&apos; ，&apos;second&apos; ：&apos;turtledoves&apos; ，&apos; first &apos; ：&apos;golden rings&apos; &#125;;</div><div class="line"></div><div class="line">var nobleGases = &#123; 2 ：&apos;氦&apos; ，10 ：&apos;氖&apos; ，18 ：&apos;氩&apos; ，&#125;;</div></pre></td></tr></table></figure></p><p>我们可以通过Map的构造函数来创建map对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var gifts = Map （）;</div><div class="line">gifts[ &apos;first&apos; ] = &apos;鹧&apos;&apos; ;</div><div class="line">gifts[ &apos;second&apos; ] = &apos;turtledoves&apos; ;</div><div class="line">gifts[ &apos;第五&apos; ] = &apos;金戒指&apos; ;       </div><div class="line"></div><div class="line">var nobleGases = Map （）;</div><div class="line">nobleGases[ 2 ] = &apos;氦&apos; ;</div><div class="line">nobleGases[ 10 ] = &apos;霓虹灯&apos; ;</div><div class="line">nobleGases[ 18 ] = &apos;氩&apos; ;</div></pre></td></tr></table></figure></p><p>如果map中不存在这个key值，那么将会返回null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var gifts = &#123; &apos;first&apos; ：&apos;partridge&apos; &#125;; 断言（gifts [ &apos;fifth&apos; ] == null ）;</div></pre></td></tr></table></figure></p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>符号是用来作为标识符的,如果我们想获取标识符的符号，那么通过#添加标识符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#radix</div><div class="line">#bar</div></pre></td></tr></table></figure></p><p>符号文字是编译时常量</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Dart是一种真正的面向对象语言，所以就算是函数也是对象，并且其类型是Function对象，这就意味着函数可以作为变量或者作为参数传递到其他方法，如果是一个函数，我们可以直接调用Dart的类实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bool isNoble(int atomicNumber) &#123;</div><div class="line">  return _nobleGases[atomicNumber] != null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>虽然Dart推荐我们对于函数设置返回值类型，但是如果我们忽略了返回值，dart仍然可以运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isNoble(atomicNumber) &#123;</div><div class="line">  return _nobleGases[atomicNumber] != null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果我们的函数中只有一个表达式，那么我们可以简化它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bool isNoble(int atomicNumber) =&gt; _nobleGases[atomicNumber] != null;</div></pre></td></tr></table></figure></p><p>这个=&gt; expr表示  { return expr; }.<br>expr只能是表达式而不能是语句</p><p>一个函数可以有两种类型得参数，必须的和可选的。如果是必须的参数，那么它会排在前面，然后后面跟着可选参数，我们可以用注解@require来标志必须的参数。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>当调用一个参数时，可以指定命名参数，例如paramName: value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enableFlags （bold ：true ，hidden ：false ）;</div></pre></td></tr></table></figure></p><p>当定义一个方法时，使用 {param1, param2, …} 来指定命名参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void enableFlags(&#123;bool bold, bool hidden&#125;) &#123;...&#125;</div></pre></td></tr></table></figure></p><p>Flutter实例创建表达式可能变得复杂，因此窗口小部件构造函数仅使用命名参数<br>我们可以在任何Dart的代码中使用@required注解，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const Scrollbar （&#123; Key key ，@required Widget child &#125;）</div></pre></td></tr></table></figure></p><p>当一个Scrollbar构造时，如果child不存在，那么将会报错。<br>required定一个meta包中，使用时我们需要先引入包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import package:meta/meta.dart</div><div class="line"></div><div class="line">//flutter</div><div class="line">package:flutter/material.dart.</div></pre></td></tr></table></figure></p><p>我们可以通过[]来设置一个可选参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String say(String from, String msg, [String device]) &#123;</div><div class="line">  var result = &apos;$from says $msg&apos;;</div><div class="line">  if (device != null) &#123;</div><div class="line">    result = &apos;$result with a $device&apos;;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>下面两个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//不传可选参数</div><div class="line">assert(say(&apos;Bob&apos;, &apos;Howdy&apos;) == &apos;Bob says Howdy&apos;);</div><div class="line">//传可选参数</div><div class="line">assert(say(&apos;Bob&apos;, &apos;Howdy&apos;, &apos;smoke signal&apos;) ==</div><div class="line">    &apos;Bob says Howdy with a smoke signal&apos;);</div></pre></td></tr></table></figure></p><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>在函数中，我们可以定义默认的值，这个默认值必须是编译时常量，如果没有设置默认值，那么编译器会给它一个默认值，null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/// Sets the [bold] and [hidden] flags ...</div><div class="line">void enableFlags(&#123;bool bold = false, bool hidden = false&#125;) &#123;...&#125;</div><div class="line"></div><div class="line">// bold will be true; hidden will be false.</div><div class="line">enableFlags(bold: true);</div></pre></td></tr></table></figure></p><p>同样的，也能设置list和map的默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void doStuff(</div><div class="line">    &#123;List&lt;int&gt; list = const [1, 2, 3],</div><div class="line">    Map&lt;String, String&gt; gifts = const &#123;</div><div class="line">      &apos;first&apos;: &apos;paper&apos;,</div><div class="line">      &apos;second&apos;: &apos;cotton&apos;,</div><div class="line">      &apos;third&apos;: &apos;leather&apos;</div><div class="line">    &#125;&#125;) &#123;</div><div class="line">  print(&apos;list:  $list&apos;);</div><div class="line">  print(&apos;gifts: $gifts&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>每一个app都会有一个顶层的main方法，作为app的入口。这个main方法将会返回void并且接收List<string>的可选参数。<br>下面是一个web的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void main() &#123;</div><div class="line">  querySelector(&apos;#sample_text_id&apos;)</div><div class="line">    ..text = &apos;Click me!&apos;</div><div class="line">    ..onClick.listen(reverseText);</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p><p>其中，..是一个流的使用标识符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void main(List&lt;String&gt; arguments) &#123;</div><div class="line">  print(arguments);</div><div class="line"></div><div class="line">  assert(arguments.length == 2);</div><div class="line">  assert(int.parse(arguments[0]) == 1);</div><div class="line">  assert(arguments[1] == &apos;test&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以将一个函数作为参数传入另外一个方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void printElement(int element) &#123;</div><div class="line">  print(element);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var list = [1, 2, 3];</div><div class="line"></div><div class="line">// Pass printElement as a parameter.</div><div class="line">list.forEach(printElement);</div></pre></td></tr></table></figure></p><p>我们也能够将一个方法赋值给变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var loudify = (msg) =&gt; &apos;!!! $&#123;msg.toUpperCase()&#125; !!!&apos;;</div><div class="line">assert(loudify(&apos;hello&apos;) == &apos;!!! HELLO !!!&apos;);</div></pre></td></tr></table></figure></p><h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>大部分的方法都是有名称的，比如说main() 或者 printElement(). 当然我们也能够创建匿名方法，有些时候也被称为lambda或者闭包。所以我们能够给一个变量赋值为匿名方法。下面一个是一个匿名函数声明方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">([[Type] param1[, …]]) &#123;</div><div class="line">  codeBlock;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>括号内接收入参，花括号处表示执行的代码块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var list = [&apos;apples&apos;, &apos;bananas&apos;, &apos;oranges&apos;];</div><div class="line">list.forEach((item) &#123;</div><div class="line">  print(&apos;$&#123;list.indexOf(item)&#125;: $item&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="语法范围"><a href="#语法范围" class="headerlink" title="语法范围"></a>语法范围</h3><p>Dart也有自己的语法范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">bool topLevel = true;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var insideMain = true;</div><div class="line"></div><div class="line">  void myFunction() &#123;</div><div class="line">    var insideFunction = true;</div><div class="line"></div><div class="line">    void nestedFunction() &#123;</div><div class="line">      var insideNestedFunction = true;</div><div class="line"></div><div class="line">      assert(topLevel);</div><div class="line">      assert(insideMain);</div><div class="line">      assert(insideFunction);</div><div class="line">      assert(insideNestedFunction);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="词汇闭包"><a href="#词汇闭包" class="headerlink" title="词汇闭包"></a>词汇闭包</h3><p>在语法范围内，一个函数闭包也能被使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/// Returns a function that adds [addBy] to the</div><div class="line">/// function&apos;s argument.</div><div class="line">Function makeAdder(num addBy) &#123;</div><div class="line">  return (num i) =&gt; addBy + i;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  // Create a function that adds 2.</div><div class="line">  var add2 = makeAdder(2);</div><div class="line"></div><div class="line">  // Create a function that adds 4.</div><div class="line">  var add4 = makeAdder(4);</div><div class="line"></div><div class="line">  assert(add2(3) == 5);</div><div class="line">  assert(add4(3) == 7);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Function定义出来一个函数闭包，然后在main方法中，将这个函数闭包赋值给add2和add4</p><h3 id="测试方法是否相等"><a href="#测试方法是否相等" class="headerlink" title="测试方法是否相等"></a>测试方法是否相等</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void foo() &#123;&#125; // A top-level function</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">  static void bar() &#123;&#125; // A static method</div><div class="line">  void baz() &#123;&#125; // An instance method</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var x;</div><div class="line"></div><div class="line">  // Comparing top-level functions.</div><div class="line">  x = foo;</div><div class="line">  assert(foo == x);</div><div class="line"></div><div class="line">  // Comparing static methods.</div><div class="line">  x = A.bar;</div><div class="line">  assert(A.bar == x);</div><div class="line"></div><div class="line">  // Comparing instance methods.</div><div class="line">  var v = A(); // Instance #1 of A</div><div class="line">  var w = A(); // Instance #2 of A</div><div class="line">  var y = w;</div><div class="line">  x = w.baz;</div><div class="line"></div><div class="line">  // These closures refer to the same instance (#2),</div><div class="line">  // so they&apos;re equal.</div><div class="line">  assert(y.baz == x);</div><div class="line"></div><div class="line">  // These closures refer to different instances,</div><div class="line">  // so they&apos;re unequal.</div><div class="line">  assert(v.baz != w.baz);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>所有的函数都会返回值，如果没有指定返回值，那么会默认返回null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo() &#123;&#125;</div><div class="line"></div><div class="line">assert(foo() == null);</div></pre></td></tr></table></figure></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Dart也具有</p><ul><li>三目运算符, expr1 ? expr2 : expr3</li><li>类型判断和转化 as    is    is!,<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (emp is Person) &#123;</div><div class="line">  // Type check</div><div class="line">  emp.firstName = &apos;Bob&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>如果is为true，那么将会直接将原对象转化为指定对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(emp as Person).firstName = &apos;Bob&apos;;</div></pre></td></tr></table></figure><p>使用emp不是person类型，那么将会直接抛异常</p><ul><li>/, 默认是double，如果需要返回int值，那么需要使用~/</li></ul><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Assign value to a</div><div class="line">a = value;</div><div class="line">// Assign value to b if b is null; otherwise, b stays the same</div><div class="line">b ??= value;</div></pre></td></tr></table></figure><p>??= 将会判断b是否为null，如果为null了再执行赋值操作。</p><h3 id="扩展表达式"><a href="#扩展表达式" class="headerlink" title="扩展表达式"></a>扩展表达式</h3><ul><li>三目运算符 condition ? expr1 : expr2</li><li>evls表示表达式，expr1 ?? expr2，如果expr1非null，那么返回expr1，否则返回expr2</li></ul><p>###流式使用<br>需要使用..符号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">querySelector(&apos;#confirm&apos;) // Get an object.</div><div class="line">  ..text = &apos;Confirm&apos; // Use its members.</div><div class="line">  ..classes.add(&apos;important&apos;)</div><div class="line">  ..onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));</div></pre></td></tr></table></figure></p><p>第一个方法，将会返回一个对象，如果后续紧跟..，那么将会持续的返回相同的对象，并且进行操作。上面的语句相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var button = querySelector(&apos;#confirm&apos;);</div><div class="line">button.text = &apos;Confirm&apos;;</div><div class="line">button.classes.add(&apos;important&apos;);</div><div class="line">button.onClick.listen((e) =&gt; window.alert(&apos;Confirmed!&apos;));</div></pre></td></tr></table></figure></p><p>而且..可以嵌套使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">final addressBook = (AddressBookBuilder()</div><div class="line">      ..name = &apos;jenny&apos;</div><div class="line">      ..email = &apos;jenny@example.com&apos;</div><div class="line">      ..phone = (PhoneNumberBuilder()</div><div class="line">            ..number = &apos;415-555-0100&apos;</div><div class="line">            ..label = &apos;home&apos;)</div><div class="line">          .build())</div><div class="line">    .build();</div></pre></td></tr></table></figure></p><p>需要注意的是，我们只能在有返回值的方法后使用..，如果在一个返回值为void的方法之后使用..将会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sb = StringBuffer();</div><div class="line">sb.write(&apos;foo&apos;)</div><div class="line">  ..write(&apos;bar&apos;); // Error: method &apos;write&apos; isn&apos;t defined for &apos;void&apos;.</div></pre></td></tr></table></figure></p><h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><ul><li>()表示一个方法</li><li>[]表示一个list的位置</li><li>.属性</li><li>?.表示不为null的取值</li></ul><h3 id="循环语句基本与其他语言一致"><a href="#循环语句基本与其他语言一致" class="headerlink" title="循环语句基本与其他语言一致"></a>循环语句基本与其他语言一致</h3><ul><li><p>if and else</p></li><li><p>for loops</p></li><li><p>while and do-while loops</p></li><li><p>break and continue</p></li><li><p>switch and case</p></li><li><p>assert</p></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类的创建可以使用new也能不使用new,两个调用的操作是一致的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p1 = Point(2, 2);</div><div class="line">var p2 = Point.fromJson(&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;);</div><div class="line"></div><div class="line">var p1 = new Point(2, 2);</div><div class="line">var p2 = new Point.fromJson(&#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125;);</div></pre></td></tr></table></figure></p><p>有一些class会提供常量级的构造函数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var p = const ImmutablePoint(2, 2);</div></pre></td></tr></table></figure></p><p>如果是常量级构造函数，那么其构造出来的对象是相同的。</p><h3 id="获取对象类型"><a href="#获取对象类型" class="headerlink" title="获取对象类型"></a>获取对象类型</h3><p>如果要在运行时获取对象类型，可以通过对象属性runtimeType，它会返回对象的类型。</p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x; // Declare instance variable x, initially null.</div><div class="line">  num y; // Declare y, initially null.</div><div class="line">  num z = 0; // Declare z, initially 0.</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果没有初始化实例变量，那么默认的初始化值会是null<br>所有的实例变量都会有一个默认的get方法，如果这个类非final的，那么也会生成默认的set方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  Point(num x, num y) &#123;</div><div class="line">    // There&apos;s a better way to do this, stay tuned.</div><div class="line">    this.x = x;</div><div class="line">    this.y = y;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于构造函数，有一个比较简便的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  // Syntactic sugar for setting x and y</div><div class="line">  // before the constructor body runs.</div><div class="line">  Point(this.x, this.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>默认构造函数是无参的。构造函数不能被继承<br>使用命名的构造函数可以让类的创建更加清晰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  Point(this.x, this.y);</div><div class="line"></div><div class="line">  // Named constructor</div><div class="line">  Point.origin() &#123;</div><div class="line">    x = 0;</div><div class="line">    y = 0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="创建一个非默认的超类构造函数"><a href="#创建一个非默认的超类构造函数" class="headerlink" title="创建一个非默认的超类构造函数"></a>创建一个非默认的超类构造函数</h3><p>通常情况下，超类有一个未命名的构造函数，超类的构造函数是再子类构造函数开始的时候调用的，如果一个初始化的list开始使用，它将会经过下面的三个过程：</p><ul><li>initializer list</li><li>superclass’s no-arg constructor</li><li>main class’s no-arg constructor</li></ul><p>如果父类没有未命名的构造函数，那么我们需要显式的调用父类的构造函数。通过：来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Employee extends Person &#123;</div><div class="line">  Employee() : super.fromJson(getDefaultData());</div><div class="line">  // ···</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在构造函数后面显式的调用父类的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Point.fromJson(Map&lt;String, num&gt; json)</div><div class="line">    : x = json[&apos;x&apos;],</div><div class="line">      y = json[&apos;y&apos;] &#123;</div><div class="line">  print(&apos;In Point.fromJson(): ($x, $y)&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在构造函数的方法执行之前，使用:进行赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">  final num x;</div><div class="line">  final num y;</div><div class="line">  final num distanceFromOrigin;</div><div class="line"></div><div class="line">  Point(x, y)</div><div class="line">      : x = x,</div><div class="line">        y = y,</div><div class="line">        distanceFromOrigin = sqrt(x * x + y * y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main() &#123;</div><div class="line">  var p = new Point(2, 3);</div><div class="line">  print(p.distanceFromOrigin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h3><p>用factory关键字标志，从cache中返回实例</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>实例方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &apos;dart:math&apos;;</div><div class="line"></div><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line"></div><div class="line">  Point(this.x, this.y);</div><div class="line"></div><div class="line">  num distanceTo(Point other) &#123;</div><div class="line">    var dx = x - other.x;</div><div class="line">    var dy = y - other.y;</div><div class="line">    return sqrt(dx * dx + dy * dy);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="重写get和set"><a href="#重写get和set" class="headerlink" title="重写get和set"></a>重写get和set</h3><p>我们可以利用get、set关键字重写get和set方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Rectangle &#123;</div><div class="line">  num left, top, width, height;</div><div class="line"></div><div class="line">  Rectangle(this.left, this.top, this.width, this.height);</div><div class="line"></div><div class="line">  // Define two calculated properties: right and bottom.</div><div class="line">  num get right =&gt; left + width;</div><div class="line">  set right(num value) =&gt; left = value - width;</div><div class="line">  num get bottom =&gt; top + height;</div><div class="line">  set bottom(num value) =&gt; top = value - height;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var rect = Rectangle(3, 4, 20, 15);</div><div class="line">  assert(rect.left == 3);</div><div class="line">  rect.right = 12;</div><div class="line">  assert(rect.left == -8);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>抽象方法只能存在于抽象类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">abstract class Doer &#123;</div><div class="line">  // Define instance variables and methods...</div><div class="line"></div><div class="line">  void doSomething(); // Define an abstract method.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h3><p>每个类都隐式定义一个接口，该接口包含该类的所有实例成员及其实现的任何接口。如果要在不继承B实现的情况下创建支持B类API的A类，则A类应实现B接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// A person. The implicit interface contains greet().</div><div class="line">class Person &#123;</div><div class="line">  // In the interface, but visible only in this library.</div><div class="line">  final _name;</div><div class="line"></div><div class="line">  // Not in the interface, since this is a constructor.</div><div class="line">  Person(this._name);</div><div class="line"></div><div class="line">  // In the interface.</div><div class="line">  String greet(String who) =&gt; &apos;Hello, $who. I am $_name.&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// An implementation of the Person interface.</div><div class="line">class Impostor implements Person &#123;</div><div class="line">  get _name =&gt; &apos;&apos;;</div><div class="line"></div><div class="line">  String greet(String who) =&gt; &apos;Hi $who. Do you know who I am?&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String greetBob(Person person) =&gt; person.greet(&apos;Bob&apos;);</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  print(greetBob(Person(&apos;Kathy&apos;)));</div><div class="line">  print(greetBob(Impostor()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>@verride注解表示复写</p><h3 id="重载操作符"><a href="#重载操作符" class="headerlink" title="重载操作符"></a>重载操作符</h3><p>operator关键字</p><h3 id="noSuchMethod"><a href="#noSuchMethod" class="headerlink" title="noSuchMethod()"></a>noSuchMethod()</h3><p>为了检测是否有地方尝试访问不存在的方法或者变量，我们可以复写noSuchMethod方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">  // Unless you override noSuchMethod, using a</div><div class="line">  // non-existent member results in a NoSuchMethodError.</div><div class="line">  @override</div><div class="line">  void noSuchMethod(Invocation invocation) &#123;</div><div class="line">    print(&apos;You tried to use a non-existent member: &apos; +</div><div class="line">        &apos;$&#123;invocation.memberName&#125;&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果有满足下面的地方，我们就能够调用一个未实现的方法</p><ul><li>接收者的类型是dynamic</li><li>接收者是静态类型，定义了未实现的方法，或者动态类型的接收者实现了 noSuchMethod()方法</li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum Color &#123; red, green, blue &#125;</div></pre></td></tr></table></figure><p>每一个枚举都有相应的位置，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">assert(Color.red.index == 0);</div><div class="line">assert(Color.green.index == 1);</div><div class="line">assert(Color.blue.index == 2);</div></pre></td></tr></table></figure></p><p>可以直接从枚举中获取出所有的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Color&gt; colors = Color.values;</div><div class="line">assert(colors[2] == Color.blue);</div></pre></td></tr></table></figure></p><p>获取出来就是一个list</p><h3 id="类的特性：-Mixins-混入"><a href="#类的特性：-Mixins-混入" class="headerlink" title="类的特性： Mixins- 混入"></a>类的特性： Mixins- 混入</h3><p>混入主要是用来重用代码的，我们可以使用with多个混入的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Musician extends Performer with Musical &#123;</div><div class="line">  // ···</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Maestro extends Person</div><div class="line">    with Musical, Aggressive, Demented &#123;</div><div class="line">  Maestro(String maestroName) &#123;</div><div class="line">    name = maestroName;</div><div class="line">    canConduct = true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了实现混入，我们需要创建一个没有构造函数的类，而且没有调用super的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">abstract class Musical &#123;</div><div class="line">  bool canPlayPiano = false;</div><div class="line">  bool canCompose = false;</div><div class="line">  bool canConduct = false;</div><div class="line"></div><div class="line">  void entertainMe() &#123;</div><div class="line">    if (canPlayPiano) &#123;</div><div class="line">      print(&apos;Playing piano&apos;);</div><div class="line">    &#125; else if (canConduct) &#123;</div><div class="line">      print(&apos;Waving hands&apos;);</div><div class="line">    &#125; else &#123;</div><div class="line">      print(&apos;Humming to self&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="类变量和方法"><a href="#类变量和方法" class="headerlink" title="类变量和方法"></a>类变量和方法</h3><p>静态变量，在类的外部也能够使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Queue &#123;</div><div class="line">  static const initialCapacity = 16;</div><div class="line">  // ···</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  assert(Queue.initialCapacity == 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>静态方法,内部不能使用this<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import &apos;dart:math&apos;;</div><div class="line"></div><div class="line">class Point &#123;</div><div class="line">  num x, y;</div><div class="line">  Point(this.x, this.y);</div><div class="line"></div><div class="line">  static num distanceBetween(Point a, Point b) &#123;</div><div class="line">    var dx = a.x - b.x;</div><div class="line">    var dy = a.y - b.y;</div><div class="line">    return sqrt(dx * dx + dy * dy);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void main() &#123;</div><div class="line">  var a = Point(2, 2);</div><div class="line">  var b = Point(4, 4);</div><div class="line">  var distance = Point.distanceBetween(a, b);</div><div class="line">  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);</div><div class="line">  print(distance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h3><p>跟java基本一致</p><h2 id="使用libraries"><a href="#使用libraries" class="headerlink" title="使用libraries"></a>使用libraries</h2><p>内置的包以dart:开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;dart:html&apos;;</div></pre></td></tr></table></figure></p><p>本地的包，以 package: scheme开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;package:test/test.dart&apos;;</div></pre></td></tr></table></figure></p><p>我们还可以给lib指定别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import &apos;package:lib1/lib1.dart&apos;;</div><div class="line">import &apos;package:lib2/lib2.dart&apos; as lib2;</div><div class="line"></div><div class="line">// Uses Element from lib1.</div><div class="line">Element element1 = Element();</div><div class="line"></div><div class="line">// Uses Element from lib2.</div><div class="line">lib2.Element element2 = lib2.Element();</div></pre></td></tr></table></figure></p><p>我们还可以导入一个包的部分元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Import only foo.</div><div class="line">import &apos;package:lib1/lib1.dart&apos; show foo;</div><div class="line"></div><div class="line">// Import all names EXCEPT foo.</div><div class="line">import &apos;package:lib2/lib2.dart&apos; hide foo;</div></pre></td></tr></table></figure></p><p>我们还可以延迟加载包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &apos;package:greetings/hello.dart&apos; deferred as hello;</div></pre></td></tr></table></figure></p><p>如果我们需要这个包，我们可以在代码中load这个包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Future greet() async &#123;</div><div class="line">  await hello.loadLibrary();</div><div class="line">  hello.printGreeting();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>async表示同步，await表示阻塞，Future对象出现再Dart的包中，通畅同步的的方法中会返回对象，如果一个future完成了，那么它的值就可以被使用了。<br>所以，Future会结合async和await使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Future checkVersion() async &#123;</div><div class="line">  var version = await lookUpVersion();</div><div class="line">  // Do something with version</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿# A Tour of the Dart Language&lt;/p&gt;
&lt;p&gt;下面是一个比较基础的Dart的方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PathMeasure动画使用</title>
    <link href="https://xjlhhz.com/2018/07/29/20180729PathMeasure%E7%9A%84%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2018/07/29/20180729PathMeasure的动画使用/</id>
    <published>2018-07-29T05:14:00.000Z</published>
    <updated>2018-09-11T11:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>##PathMeasure的简单使用<br>pathMeasure是android给我们提供的一个用于自定义View的绘制的类。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public PathMeasure() &#123;</div><div class="line">       mPath = null;</div><div class="line">       native_instance = native_create(0, false);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>创建出一个空的pathMeasure对象，如果我们需要调用其中的方法，那么我们需要提前调用setPath</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public PathMeasure(Path path, boolean forceClosed) &#123;</div><div class="line">        // The native implementation does not copy the path, prevent it from being GC&apos;d</div><div class="line">        mPath = path;</div><div class="line">        native_instance = native_create(path != null ? path.readOnlyNI() : 0,</div><div class="line">                                        forceClosed);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>创建出一个带path的PathMeasure对象，forceClosed表示是否需要强制将path进行连接</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>获取当前的path的总长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the total length of the current contour, or 0 if no path is</div><div class="line"> * associated with this measure object.</div><div class="line"> */</div><div class="line">public float getLength() &#123;</div><div class="line">    return native_getLength(native_instance);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取当前距离所在的坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean getPosTan(float distance, float pos[], float tan[]) &#123;</div><div class="line">        if (pos != null &amp;&amp; pos.length &lt; 2 ||</div><div class="line">            tan != null &amp;&amp; tan.length &lt; 2) &#123;</div><div class="line">            throw new ArrayIndexOutOfBoundsException();</div><div class="line">        &#125;</div><div class="line">        return native_getPosTan(native_instance, distance, pos, tan);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>获取两个指定点之间的片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * Given a start and stop distance, return in dst the intervening</div><div class="line">    * segment(s). If the segment is zero-length, return false, else return</div><div class="line">    * true. startD and stopD are pinned to legal values (0..getLength()).</div><div class="line">    * If startD &gt;= stopD then return false (and leave dst untouched).</div><div class="line">    * Begin the segment with a moveTo if startWithMoveTo is true.</div><div class="line">    *</div><div class="line">    * &lt;p&gt;On &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; and earlier</div><div class="line">    * releases, the resulting path may not display on a hardware-accelerated</div><div class="line">    * Canvas. A simple workaround is to add a single operation to this path,</div><div class="line">    * such as &lt;code&gt;dst.rLineTo(0, 0)&lt;/code&gt;.&lt;/p&gt;</div><div class="line">    */</div><div class="line">   public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) &#123;</div><div class="line">       // Skia used to enforce this as part of it&apos;s API, but has since relaxed that restriction</div><div class="line">       // so to maintain consistency in our API we enforce the preconditions here.</div><div class="line">       float length = getLength();</div><div class="line">       if (startD &lt; 0) &#123;</div><div class="line">           startD = 0;</div><div class="line">       &#125;</div><div class="line">       if (stopD &gt; length) &#123;</div><div class="line">           stopD = length;</div><div class="line">       &#125;</div><div class="line">       if (startD &gt;= stopD) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return native_getSegment(native_instance, startD, stopD, dst.mutateNI(), startWithMoveTo);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>这个方法将会将指定点的距离路径set到传入的path中。</p><h2 id="圆环动画实现"><a href="#圆环动画实现" class="headerlink" title="圆环动画实现"></a>圆环动画实现</h2><p>对于一个圆环进度条动画，我们也可以通过这个PathMeasure来实现。</p><h3 id="创建圆环PathMeasure"><a href="#创建圆环PathMeasure" class="headerlink" title="创建圆环PathMeasure"></a>创建圆环PathMeasure</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private fun initPathMeasure() &#123;</div><div class="line">        pathMeasure = PathMeasure()</div><div class="line">    &#125;</div><div class="line">//创建circle</div><div class="line"> circlePath.addCircle(centerX, centerY, dip(35).toFloat(), Path.Direction.CW)</div><div class="line">//设置path</div><div class="line">pathMeasure.setPath(circlePath, false)</div></pre></td></tr></table></figure><h3 id="获取进度"><a href="#获取进度" class="headerlink" title="获取进度"></a>获取进度</h3><p>对于不同的业务场景下，我们可以通过不同的方式获取进度。</p><ul><li><p>通过ValueAnimator获取进度</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  private ValueAnimator initTranslateAnimator(final ImageView imageView) &#123;</div><div class="line"></div><div class="line">    ValueAnimator valueAnimator = ValueAnimator.ofFloat(0, 1);</div><div class="line">    valueAnimator.setDuration(VIEW_ANIMATION_DURING);</div><div class="line">    valueAnimator.setInterpolator(new LinearInterpolator());</div><div class="line">    valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAnimationUpdate(ValueAnimator animation) &#123;</div><div class="line">            float value = (float) animation.getAnimatedValue();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return valueAnimator;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  这个value就是获取到的实时进度</p></li><li><p>根据业务场景获取进度<br>  比如说我项目中的场景是一个录音的按钮，那么总的录制时长就是最大进度，当前的录制时长就是实时的进度</p></li></ul><h3 id="获取片段"><a href="#获取片段" class="headerlink" title="获取片段"></a>获取片段</h3><p>通过PathMeasure的getSegment获取当前的片段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pathMeasure.getSegment(getDistance(getLastRecordTime()), getDistance(time), rPath, true)</div></pre></td></tr></table></figure></p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>在onDraw方法中绘制获取出来的path<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas?.drawPath(path, recordPaint)</div></pre></td></tr></table></figure></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="需要有暂停，并且暂停有间隔"><a href="#需要有暂停，并且暂停有间隔" class="headerlink" title="需要有暂停，并且暂停有间隔"></a>需要有暂停，并且暂停有间隔</h3><p>比如下面图片中的例子：<br><img src="http://onu21exz8.bkt.clouddn.com/record.jpeg" alt=""><br>这个动画需要可以暂停，然后每次暂停后都会有分隔符。<br>处理方案： 我们需要将path缓存起来，并且每次生成小间隔，在onDraw时先绘制之前缓存的path，在计算进度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//绘制之前的进度</div><div class="line">       destPathList.forEachIndexed &#123; index, path -&gt;</div><div class="line">           //0表示录音path，1表示间隔path</div><div class="line">           canvas?.drawPath(path, if (index % 2 == 0) recordPaint else dividerPaint)</div><div class="line">       &#125;</div><div class="line">       //需要先空出间隔的时间不绘制</div><div class="line">       if (durationStack.isEmpty()) &#123;</div><div class="line">           val path = Path()</div><div class="line">           pathMeasure.getSegment(getDistance(getLastRecordTime()), getDistance(currentTime + getLastRecordTime()), path, true)</div><div class="line">           canvas?.drawPath(path, recordPaint)</div><div class="line">       &#125; else if (currentTime &gt;= dividerStep) &#123;</div><div class="line">           //再进行此时的绘制, 肯定是录音绘制</div><div class="line">           val path = Path()</div><div class="line">           pathMeasure.getSegment(getDistance(getLastRecordTime()), getDistance(currentTime + getLastRecordTime() - dividerStep), path, true)</div><div class="line">           canvas?.drawPath(path, recordPaint)</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><h4 id="onDraw并没有手动执行"><a href="#onDraw并没有手动执行" class="headerlink" title="onDraw并没有手动执行"></a>onDraw并没有手动执行</h4><p>在设置的时候，发现onDraw方法在request或者invaliate方法触发下并不会执行，是因为ViewGroup默认情况下，出于性能考虑，会被设置成WILL_NOT_DROW，这样，ondraw就不会被执行了。<br>解决方案,在构造函数中，设置WILL_NOT_DROW为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setWillNotDraw（false）</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##PathMeasure的简单使用&lt;br&gt;pathMeasure是android给我们提供的一个用于自定义View的绘制的类。&lt;/p&gt;
&lt;h3 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ViewSwitcher的使用</title>
    <link href="https://xjlhhz.com/2018/07/18/20180718ViewSwitcher%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2018/07/18/20180718ViewSwitcher的使用/</id>
    <published>2018-07-18T05:14:00.000Z</published>
    <updated>2018-07-18T14:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ViewSwitcher简单使用"><a href="#ViewSwitcher简单使用" class="headerlink" title="ViewSwitcher简单使用"></a>ViewSwitcher简单使用</h2><p>ViewSwitcher，从字面的意义上来说，它就是一个基本View切换的动画实现，内部给我们封装了切换动画，我们只需要设置相应的动画及View的切换就可以了</p><h3 id="实现Factory接口"><a href="#实现Factory接口" class="headerlink" title="实现Factory接口"></a>实现Factory接口</h3><p>实现Factory接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Creates views in a ViewSwitcher.</div><div class="line">     */</div><div class="line">    public interface ViewFactory &#123;</div><div class="line">        /**</div><div class="line">         * Creates a new &#123;@link android.view.View&#125; to be added in a</div><div class="line">         * &#123;@link android.widget.ViewSwitcher&#125;.</div><div class="line">         *</div><div class="line">         * @return a &#123;@link android.view.View&#125;</div><div class="line">         */</div><div class="line">        View makeView();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这个工厂接口里面的makeView就是用来生产ViewSwitcher里的View的。这个是我们必须要实现的一个接口。返回相应的View。</p><h3 id="设置动画和工厂"><a href="#设置动画和工厂" class="headerlink" title="设置动画和工厂"></a>设置动画和工厂</h3><p>当我们实现完了Factory之后，只需要设置相应的参数就可以愉快的使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private fun initFrameSwitchView() &#123;</div><div class="line">        //设置对应的工厂</div><div class="line">        recordImageSwitch.setFactory(this)</div><div class="line">        //设置动画</div><div class="line">        recordImageSwitch.setInAnimation(this, R.anim.alpha_in)</div><div class="line">        recordImageSwitch.setOutAnimation(this, R.anim.alpha_out)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="切换View"><a href="#切换View" class="headerlink" title="切换View"></a>切换View</h3><p>设置完了View之后，我们只需要调用切换View的方法就可以看到相应的动画了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Manually shows the next child.</div><div class="line">     */</div><div class="line">    @android.view.RemotableViewMethod</div><div class="line">    public void showNext() &#123;</div><div class="line">        setDisplayedChild(mWhichChild + 1);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * Manually shows the previous child.</div><div class="line">     */</div><div class="line">    @android.view.RemotableViewMethod</div><div class="line">    public void showPrevious() &#123;</div><div class="line">        setDisplayedChild(mWhichChild - 1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h2 id="ViewSwitcher的原理"><a href="#ViewSwitcher的原理" class="headerlink" title="ViewSwitcher的原理"></a>ViewSwitcher的原理</h2><p>其实它的内部原理特别简单，就是在ViewSwitcher中构造了两个View，然后再我们调用切换View的方法的时候去调用设置的动画来进行切换。</p><h3 id="setFactory"><a href="#setFactory" class="headerlink" title="setFactory"></a>setFactory</h3><p>在我们初始化时，需要设置了工厂，在设置工厂的同时会初始化两个需要Switch的View。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void setFactory(ViewFactory factory) &#123;</div><div class="line">        mFactory = factory;</div><div class="line">        obtainView();</div><div class="line">        obtainView();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-----&gt;</div><div class="line">private View obtainView() &#123;</div><div class="line">        View child = mFactory.makeView();</div><div class="line">        LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">        if (lp == null) &#123;</div><div class="line">            lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</div><div class="line">        &#125;</div><div class="line">        addView(child, lp);</div><div class="line">        return child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在obtainView中，首先会通过makeView这个方法，获取出相应的View，然后添加ViewGroup中。</p><h3 id="showNext"><a href="#showNext" class="headerlink" title="showNext"></a>showNext</h3><p>内部会调用DisplayedChild切换View。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public void setDisplayedChild(int whichChild) &#123;</div><div class="line">        //设置当前的子View id</div><div class="line">        mWhichChild = whichChild;</div><div class="line">        if (whichChild &gt;= getChildCount()) &#123;</div><div class="line">            //到了子view的最大值，那么清0返回</div><div class="line">            mWhichChild = 0;</div><div class="line">        &#125; else if (whichChild &lt; 0) &#123;</div><div class="line">            //到了子View的最小值，那么回到最大值</div><div class="line">            mWhichChild = getChildCount() - 1;</div><div class="line">        &#125;</div><div class="line">        boolean hasFocus = getFocusedChild() != null;</div><div class="line">        // This will clear old focus if we had it</div><div class="line">        showOnly(mWhichChild);</div><div class="line">        if (hasFocus) &#123;</div><div class="line">            // Try to retake focus if we had it</div><div class="line">            requestFocus(FOCUS_FORWARD);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">-------&gt; showOnly</div><div class="line">void showOnly(int childIndex, boolean animate) &#123;</div><div class="line">        final int count = getChildCount();</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            //获取子View</div><div class="line">            final View child = getChildAt(i);</div><div class="line">            if (i == childIndex) &#123;</div><div class="line">                //如果是当前要显示的View，那么需要执行入场动画</div><div class="line">                if (animate &amp;&amp; mInAnimation != null) &#123;</div><div class="line">                    child.startAnimation(mInAnimation);</div><div class="line">                &#125;</div><div class="line">                child.setVisibility(View.VISIBLE);</div><div class="line">                mFirstTime = false;</div><div class="line">            &#125; else &#123;</div><div class="line">                //出场的View，需要执行出场动画</div><div class="line">                if (animate &amp;&amp; mOutAnimation != null &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;</div><div class="line">                    child.startAnimation(mOutAnimation);</div><div class="line">                &#125; else if (child.getAnimation() == mInAnimation)</div><div class="line">                    child.clearAnimation();</div><div class="line">                child.setVisibility(View.GONE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><h2 id="ViewSwitcher的扩展"><a href="#ViewSwitcher的扩展" class="headerlink" title="ViewSwitcher的扩展"></a>ViewSwitcher的扩展</h2><p>默认的实现的ImageView，我们可以扩展这个实现，比如说扩展为SimpleDreeViewSwitcher，再或者，我们可以扩展为ViewGroup。<br>比如我们添加了一个FrameLayout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">override fun makeView(): View &#123;</div><div class="line">        val layoutParams = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</div><div class="line">        val frameLayout = FrameLayout(this)</div><div class="line">        frameLayout.layoutParams = layoutParams</div><div class="line"></div><div class="line">        //中间SimpleDraweeView</div><div class="line">        val simple = SimpleDraweeView(this)</div><div class="line">        val centerLayoutParam = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT)</div><div class="line">        centerLayoutParam.gravity = Gravity.CENTER</div><div class="line">        simple.tag = 1</div><div class="line">        val hierarchy = simple.hierarchy</div><div class="line">        hierarchy.actualImageScaleType = ScalingUtils.ScaleType.FIT_XY</div><div class="line">        simple.hierarchy = hierarchy</div><div class="line">        simple.adjustViewBounds = true</div><div class="line">        simple.layoutParams = centerLayoutParam</div><div class="line"></div><div class="line">        //背景ImageView</div><div class="line">        val bgSimple = SimpleDraweeView(this)</div><div class="line">        val bgLayoutParam = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)</div><div class="line">        bgSimple.tag = 2</div><div class="line">        val bgHierarchy = bgSimple.hierarchy</div><div class="line">        bgHierarchy.actualImageScaleType = ScalingUtils.ScaleType.CENTER_CROP</div><div class="line">        bgSimple.hierarchy = bgHierarchy</div><div class="line">        bgSimple.layoutParams = bgLayoutParam</div><div class="line"></div><div class="line"></div><div class="line">        frameLayout.addView(bgSimple)</div><div class="line">        frameLayout.addView(simple)</div><div class="line">        return frameLayout</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在代码中创建了一个FrameLayout，并且创建添加两个子View，设置tag。</p><p>在每次切换View之前，都需要对View进行相应的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fun setImageUrl(imageUrl : String, scaleType: Int, isGif: Boolean) &#123;</div><div class="line">      val layout = this.nextView as FrameLayout</div><div class="line">      val centerSimpleDraweeView = layout.findViewWithTag&lt;SimpleDraweeView&gt;(1)</div><div class="line">      val bgSimpleDraweeView = layout.findViewWithTag&lt;SimpleDraweeView&gt;(2)</div><div class="line"></div><div class="line">      //对View进行处理</div><div class="line"></div><div class="line">      showNext()</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ViewSwitcher简单使用&quot;&gt;&lt;a href=&quot;#ViewSwitcher简单使用&quot; class=&quot;headerlink&quot; title=&quot;ViewSwitcher简单使用&quot;&gt;&lt;/a&gt;ViewSwitcher简单使用&lt;/h2&gt;&lt;p&gt;ViewSwitcher，从
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CoordinateLayout使用</title>
    <link href="https://xjlhhz.com/2018/05/12/20180512CoordinateLayout%E4%BD%BF%E7%94%A8/"/>
    <id>https://xjlhhz.com/2018/05/12/20180512CoordinateLayout使用/</id>
    <published>2018-05-12T05:14:00.000Z</published>
    <updated>2018-05-13T10:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Material Design 是专为设计适用于多个平台和设备的视觉、运动与互动效果而制定的综合指南。 Android 现在已支持 Material Design 应用。 如果要在您的 Android 应用中使用 Material Design，请遵循Material Design 规范内定义的指导方针，并使用 Android 5.0（API 级别 21）及以上版本所提供的新组件和功能。</p><p>而CoordinateLayout就是其中一个比较难的组件。</p><h2 id="coordinateLayout"><a href="#coordinateLayout" class="headerlink" title="coordinateLayout"></a>coordinateLayout</h2><p>coordinateLayout作为一个功能较为强大的FrameLayout，但是它并没有直接继承于FrameLayout。而是作为ViewGroup的直接子类。主要用在以下的场景：</p><ul><li>作为一个顶层布局</li><li>需要与一个获多个子视图进行特殊交互，主要是指的滑动交互。</li></ul><p>可以通过Behaviors来指定子视图</p><h3 id="引入coordinateLayout"><a href="#引入coordinateLayout" class="headerlink" title="引入coordinateLayout"></a>引入coordinateLayout</h3><p>既然Material Design作为android的一个新特性，需要我们在gradle文件中引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &apos;com.android.support:design:&apos; + rootProject.supportLibVersion</div></pre></td></tr></table></figure></p><p>###基本使用</p><h4 id="coordinateLayout结合AppBarLayout"><a href="#coordinateLayout结合AppBarLayout" class="headerlink" title="coordinateLayout结合AppBarLayout"></a>coordinateLayout结合AppBarLayout</h4><p>AppBarLayout是具有Material Design特性的垂直的线性布局，直接继承于LinearLayout，需要作为coordinateLayout的直接子View才有作用，在appLayout中的子View将会依据scrollFlag随着滑动进行变化，可以通过scrollFlag属性来设置其中的子View来设置滑动特性，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//代码中</div><div class="line">appBarLayout.setScrollFlags(int)</div><div class="line">//xml中</div><div class="line">app:layout_scrollFlags</div></pre></td></tr></table></figure></p><h4 id="scrollFlag"><a href="#scrollFlag" class="headerlink" title="scrollFlag"></a>scrollFlag</h4><ul><li>scroll:值设为scroll的View会跟随滚动事件一起发生移动。就好像这个View也是列表的某个item，会随着滑动消失和出现</li><li>enterAlways：只要外部的scrollView或recyclerView有向下的滑动事件，那么这个View就有出现</li><li>exitUntilCollapsed：需要结合属性miniHeight使用，在滑动时，将会先将这个View滑动到指定的最低高度，再滑动recyclerView元素。</li><li>enterAlwaysCollapsed： 这个属性需要结合enterAlway和miniHeight使用，在recyclerView有向下滑动的时候，会先触发enterAlways，让这个View出现到最低高度，然后等到recyclerView向下滑到不能再滑动时，再滑动这个View到原始高度。</li><li>snap: 这个属性将会在滑动结束时，让这个View完全可见或者完全不可见。如果滑动结束后，这个View显示的高度低于0.25,那么这个View将会直接不可见，如果这个View显示的高度大于0.75,那么这个View将会完全可见</li></ul><p>###AppBarLayout结合CollapsingToolbarLayout<br>CollapsingToolbarLayout是一个折叠式的toolBar，直接继承于FrameLayout，需要作为AppBarLayout的直接子View，有下面几个特性供我们使用</p><ul><li>折叠标题： 标题布局在完全可见时更大，但随着屏幕滚动将会折叠并且变小，通过setTitle来设置标题，并且通过collapsedTextAppearance和expandedTextAppearance来改变标题外观</li><li>toolbar内容填充：当屏幕滚动至折叠到toolbar高度时，会给toolbard设置背景，通过setContentScrim(Drawable)设置</li><li>statusBar内容填充：当屏幕滚动至折叠到toolbar高度时，会给状态栏设置背景，通过setStatusBarScrim(Drawable)设置，只有在5.0以上起作用</li><li>滑动视差效果：子View的滑动可以和外部recylerView形成视察效果，通过设置子view的layout_collapseMode为parallax开启，通过setParallaxMultiplier(float)来设置视差的效果。</li><li>固定子view位置：在屏幕滚动时，如果我们设置了子view的layout_collapseMode为pin的话，那么这个子View将会固定在顶部，当然，我们可以同时设置多个子View为pin</li><li>我们最好不要在运行时动态的给toolbar添加子View，否则title的大小计算可能会出问题</li></ul><h3 id="xml例子"><a href="#xml例子" class="headerlink" title="xml例子"></a>xml例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;android.support.design.widget.CoordinateLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:id=&quot;@+id/main_layout&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:background=&quot;@color/color_F7F9FA&quot;&gt;</div><div class="line"></div><div class="line">    &lt;android.support.design.widget.AppBarLayout</div><div class="line">        android:id=&quot;@+id/app_bar_layout&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:theme=&quot;@color/color_ffffff&quot;&gt;</div><div class="line"></div><div class="line">        &lt;android.support.design.widget.CollapsingToolbarLayout</div><div class="line">            android:id=&quot;@+id/collap_tool_bar_layout&quot;</div><div class="line">            android:layout_width=&quot;match_parent&quot;</div><div class="line">            android:layout_height=&quot;wrap_content&quot;</div><div class="line">            android:background=&quot;@color/color_FFFFFF&quot;</div><div class="line">            app:contentScrim=&quot;@color/color_ffffff&quot;</div><div class="line">            app:expandedTitleGravity=&quot;center_horizontal&quot;</div><div class="line">            app:expandedTitleMarginEnd=&quot;64dp&quot;</div><div class="line">            app:expandedTitleMarginStart=&quot;48dp&quot;</div><div class="line">            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</div><div class="line">            app:scrimVisibleHeightTrigger=&quot;@dimen/dimens_80dp&quot;&gt;</div><div class="line"></div><div class="line">            &lt;com.facebook.drawee.view.SimpleDraweeView</div><div class="line">                android:id=&quot;@+id/bg_collaps&quot;</div><div class="line">                android:layout_width=&quot;match_parent&quot;</div><div class="line">                android:layout_height=&quot;375dp&quot;</div><div class="line">                android:scaleType=&quot;centerCrop&quot;</div><div class="line">                app:layout_collapseMode=&quot;parallax&quot; /&gt;</div><div class="line"></div><div class="line">            &lt;android.support.v7.widget.Toolbar</div><div class="line">                android:id=&quot;@+id/toolbar&quot;</div><div class="line">                android:layout_width=&quot;match_parent&quot;</div><div class="line">                android:layout_height=&quot;@dimen/toolbar_height&quot;</div><div class="line">                app:layout_collapseMode=&quot;pin&quot;</div><div class="line">                app:layout_scrollFlags=&quot;scroll|enterAlways&quot;&gt;</div><div class="line"></div><div class="line">            &lt;/android.support.v7.widget.Toolbar&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</div><div class="line">    &lt;/android.support.design.widget.AppBarLayout&gt;</div><div class="line">    &lt;RecyclerView</div><div class="line">        android:id=&quot;@+id/recycler_view&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior</div><div class="line">        /&gt;</div><div class="line">&lt;/android.support.design.widget.CoordinateLayout&gt;</div></pre></td></tr></table></figure><p>上面这个就是简单的CoordinateLayout、AppBarLayout及CollapsingToolbarLayout的结合使用，只要记得它必须是直接子View，和使用一些特性的属性就行。<br>上面非常重要的一点时，如何让可滑动的View和CoordinateLayout这些View建立联系，能够监听其滑动？其实只需要一个属性，在上面的recyclerView中，添加了一个layout_behavior属性，这个属性就标识了appBarLayout将会依赖于这个RecyclerView的滑动做处理。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="layout-behavior绑定过程"><a href="#layout-behavior绑定过程" class="headerlink" title="layout_behavior绑定过程"></a>layout_behavior绑定过程</h4><p>既然AppBarLayout和recyclerView的滑动是通过app:layout_behavior这个属性维系的，那么它究竟是如何通过这个属性来绑定的,我们需要来看看CoordinateLayout的源码实现了，</p><h5 id="layout-behavior的创建"><a href="#layout-behavior的创建" class="headerlink" title="layout_behavior的创建"></a>layout_behavior的创建</h5><p>CoordinateLayout内部自定义了一个LayoutParam类，这个类包含了对Behavior的解析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">LayoutParams(Context context, AttributeSet attrs) &#123;</div><div class="line">            super(context, attrs);</div><div class="line"></div><div class="line">            final TypedArray a = context.obtainStyledAttributes(attrs,</div><div class="line">                    R.styleable.CoordinatorLayout_Layout);</div><div class="line">            ...</div><div class="line">            mBehaviorResolved = a.hasValue(</div><div class="line">                    R.styleable.CoordinatorLayout_Layout_layout_behavior);</div><div class="line">            if (mBehaviorResolved) &#123;</div><div class="line">                //如果存在layout_behavior属性，那么将会尝试解析behavior</div><div class="line">                mBehavior = parseBehavior(context, attrs, a.getString(</div><div class="line">                        R.styleable.CoordinatorLayout_Layout_layout_behavior));</div><div class="line">            &#125;</div><div class="line">            a.recycle();</div><div class="line"></div><div class="line">            if (mBehavior != null) &#123;</div><div class="line">                // 如果解析出behavior，那么将会绑定这个layoutParam</div><div class="line">                mBehavior.onAttachedToLayoutParams(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>在我们了解behavior的解析操作前，我们需要先了解一下app:layout_behavior的默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;string name=&quot;appbar_scrolling_view_behavior&quot; translatable=&quot;false&quot;&gt;android.support.design.widget.AppBarLayout$ScrollingViewBehavior&lt;/string&gt;</div></pre></td></tr></table></figure></p><p>通过parseBehavior创建Behavior实例，如果存在，那就直接复用，不存在就通过反射创建实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static Behavior parseBehavior(Context context, AttributeSet attrs, String name) &#123;</div><div class="line">        if (TextUtils.isEmpty(name)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        //拼出全拼</div><div class="line">        final String fullName;</div><div class="line">        if (name.startsWith(&quot;.&quot;)) &#123;</div><div class="line">            // Relative to the app package. Prepend the app package name.</div><div class="line">            fullName = context.getPackageName() + name;</div><div class="line">        &#125; else if (name.indexOf(&apos;.&apos;) &gt;= 0) &#123;</div><div class="line">            // Fully qualified package name.</div><div class="line">            fullName = name;</div><div class="line">        &#125; else &#123;</div><div class="line">            // Assume stock behavior in this package (if we have one)</div><div class="line">            fullName = !TextUtils.isEmpty(WIDGET_PACKAGE_NAME)</div><div class="line">                    ? (WIDGET_PACKAGE_NAME + &apos;.&apos; + name)</div><div class="line">                    : name;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        try &#123;</div><div class="line">            //用threadLocal存储Behavior</div><div class="line">            Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get();</div><div class="line">            if (constructors == null) &#123;</div><div class="line">                constructors = new HashMap&lt;&gt;();</div><div class="line">                sConstructors.set(constructors);</div><div class="line">            &#125;</div><div class="line">            //判断是否已经有相应的behavior</div><div class="line">            Constructor&lt;Behavior&gt; c = constructors.get(fullName);</div><div class="line">            if (c == null) &#123;</div><div class="line">                //没有就创建，通过反射创建实例</div><div class="line">                final Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) context.getClassLoader()</div><div class="line">                        .loadClass(fullName);</div><div class="line">                c = clazz.getConstructor(CONSTRUCTOR_PARAMS);</div><div class="line">                c.setAccessible(true);</div><div class="line">                constructors.put(fullName, c);</div><div class="line">            &#125;</div><div class="line">            return c.newInstance(context, attrs);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new RuntimeException(&quot;Could not inflate Behavior subclass &quot; + fullName, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在创建后需要将behavior绑定layoutParam。<br>coordirnateLayout在传递事件时，如果子View存在Behavior，那么会将滑动事件和子View都交给behavior来处理。</p><h5 id="Behavior的事件"><a href="#Behavior的事件" class="headerlink" title="Behavior的事件"></a>Behavior的事件</h5><h6 id="Coordinatelayout-Behavior"><a href="#Coordinatelayout-Behavior" class="headerlink" title="Coordinatelayout.Behavior"></a>Coordinatelayout.Behavior</h6><p>在coordinateLyout中定义了一个Behavior的抽象类，所有的Behavior都需要继承于该类，我们看看一个最基本的Behavior具有比较重要的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">//设置两个View的依赖        </div><div class="line">public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//依赖的View改变</div><div class="line">public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//依赖View的移除</div><div class="line">public void onDependentViewRemoved(CoordinatorLayout parent, V child, View dependency) &#123;&#125;</div><div class="line">//准备开始移动的回调</div><div class="line">public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                return onStartNestedScroll(coordinatorLayout, child, directTargetChild,</div><div class="line">                        target, axes);</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//滑动事件被接收的回调</div><div class="line">public void onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                onNestedScrollAccepted(coordinatorLayout, child, directTargetChild,</div><div class="line">                        target, axes);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">public void onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View directTargetChild, @NonNull View target,</div><div class="line">                @ScrollAxis int axes) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//停止滑动事件的回调</div><div class="line">public void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                onStopNestedScroll(coordinatorLayout, child, target);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">public void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//滑动事件的接收</div><div class="line">public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child,</div><div class="line">                @NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type) &#123;</div><div class="line">            if (type == ViewCompat.TYPE_TOUCH) &#123;</div><div class="line">                onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed,</div><div class="line">                        dxUnconsumed, dyUnconsumed);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child,</div><div class="line">                @NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                int dxUnconsumed, int dyUnconsumed) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//滑动事件前的回调</div><div class="line">public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child,</div><div class="line">                @NonNull View target, int dxConsumed, int dyConsumed,</div><div class="line">                int dxUnconsumed, int dyUnconsumed) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">public void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, int dx, int dy, @NonNull int[] consumed) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">//fling事件回调</div><div class="line">public boolean onNestedFling(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, float velocityX, float velocityY,</div><div class="line">                boolean consumed) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">//fling事件前回调</div><div class="line">public boolean onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout,</div><div class="line">                @NonNull V child, @NonNull View target, float velocityX, float velocityY) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>AppBarLayout也有一个默认的behavior，我们不需要显示的指定这个Behavior的使用，因为AppBarLayout在代码中添加了注解，来给CoordinateLayout添加默认behavior。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)</div></pre></td></tr></table></figure></p><p>appBarLayout中用的behavior，同样的也是继承于CoordinateLayout中的behavior，通过重写其中的方法，来做相应的滑动处理。</p><h3 id="CoordinateLayout实现可放大的封面"><a href="#CoordinateLayout实现可放大的封面" class="headerlink" title="CoordinateLayout实现可放大的封面"></a>CoordinateLayout实现可放大的封面</h3><p>这个是参照的网上的实现</p><ul><li><p>设置需要传递放大的View，View的正常高度和可放大的最大高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void setPullZoom(View zoomView, int zoomViewHeight, int maxZoomViewHeight, IPullZoom pullZoom) &#123;</div><div class="line">        this.mZoomView = zoomView;</div><div class="line">        mZoomViewHeight = zoomViewHeight;</div><div class="line">        mZoomViewMaxHeight = maxZoomViewHeight;</div><div class="line">        mPullZoom = pullZoom;</div><div class="line">        //防止 onInterceptTouchEvent的ACTION_MOVE事件不执行，避免就是子view的down事件返回fasle</div><div class="line">        mZoomView.setClickable(true);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>重写事件拦截器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">public boolean onInterceptTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (!isPullToZoomEnabled()) &#123;</div><div class="line">            //如果没有传入需要放大的view，那么不拦截</div><div class="line">            return super.onInterceptTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final int action = event.getAction();</div><div class="line"></div><div class="line">        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123;</div><div class="line">            //如果是取消或者抬起事件，那么不拦截</div><div class="line">            mIsBeingDragged = false;</div><div class="line">            return super.onInterceptTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (action != MotionEvent.ACTION_DOWN &amp;&amp; mIsBeingDragged) &#123;</div><div class="line">            //如果已经处于放大中状态，且事件是down，那么直接拦截</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                //开始触发的放大的条件</div><div class="line">                if (isReadyForPullStart()) &#123;</div><div class="line">                    </div><div class="line">                    final float y = event.getY(), x = event.getX();</div><div class="line">                    final float diff, oppositeDiff, absDiff;</div><div class="line">                    // 计算此次位移的距离</div><div class="line">                    diff = y - mLastMotionY;</div><div class="line">                    oppositeDiff = x - mLastMotionX;</div><div class="line">                    absDiff = Math.abs(diff);</div><div class="line">                    </div><div class="line">                </div><div class="line">                    </div><div class="line">                    if (absDiff &gt; mTouchSlop &amp;&amp; absDiff &gt; Math.abs(oppositeDiff)) &#123;</div><div class="line">                        </div><div class="line">                        if (diff &gt;= 1f &amp;&amp; isReadyForPullStart()) &#123;</div><div class="line">                    //修改last位置，并且设置mIsBeingDragged为ture</div><div class="line">                            mLastMotionY = y;</div><div class="line">                            mLastMotionX = x;</div><div class="line">                            mIsBeingDragged = true;</div><div class="line">                        &#125;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mIsBeingDragged = false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                if (isReadyForPullStart()) &#123;</div><div class="line">                    mLastMotionY = mInitialMotionY = event.getY();</div><div class="line">                    mLastMotionX = mInitialMotionX = event.getX();</div><div class="line">                    mIsBeingDragged = false;</div><div class="line">                &#125; else &#123;</div><div class="line">                    mIsBeingDragged = false;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //利用mIsBeingDragged标志是否拦截事件</div><div class="line">        return mIsBeingDragged || super.onInterceptTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>onTouchEvent做事件处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        if (!isPullToZoomEnabled()) &#123;</div><div class="line">            return super.onTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; event.getEdgeFlags() != 0) &#123;</div><div class="line">            return super.onTouchEvent(event);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (event.getAction()) &#123;</div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                if (mIsBeingDragged) &#123;</div><div class="line">                    //开始进行拖动放大，通过pullEvent放大</div><div class="line">                    mLastMotionY = event.getY();</div><div class="line">                    mLastMotionX = event.getX();</div><div class="line">                    pullEvent();</div><div class="line">                    isZooming = true;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                if (isReadyForPullStart()) &#123;</div><div class="line">                    mLastMotionY = mInitialMotionY = event.getY();</div><div class="line">                    mLastMotionX = mInitialMotionX = event.getX();</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_CANCEL:</div><div class="line">            case MotionEvent.ACTION_UP: &#123;</div><div class="line">                if (mIsBeingDragged) &#123;</div><div class="line">                    mIsBeingDragged = false;</div><div class="line">                    // 如果up和cancel事件前，处于放大状态，那么需要还原到先前的位置</div><div class="line">                    if (isZooming()) &#123;</div><div class="line">                        //首先滑动到顶部</div><div class="line">                        smoothScrollToTop();</div><div class="line">                        if (onPullZoomListener != null) &#123;</div><div class="line">                            onPullZoomListener.onPullZoomEnd();</div><div class="line">                        &#125;</div><div class="line">                        if (mPullZoom != null) &#123;</div><div class="line">                            mPullZoom.onPullZoomEnd();</div><div class="line">                        &#125;</div><div class="line">                        isZooming = false;</div><div class="line">                        return true;</div><div class="line">                    &#125;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(event);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>放大的动画pullEvent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private void pullEvent() &#123;</div><div class="line">        final int newScrollValue;</div><div class="line">        final float initialMotionValue, lastMotionValue;</div><div class="line"></div><div class="line">        //按下的位置，y</div><div class="line">        initialMotionValue = mInitialMotionY;</div><div class="line">        //此次滑动到的y坐标</div><div class="line">        lastMotionValue = mLastMotionY;</div><div class="line"></div><div class="line">        //计算新的scroll距离，距离/3</div><div class="line">        newScrollValue = Math.round(Math.min(initialMotionValue - lastMotionValue, 0) / FRICTION);</div><div class="line">        //做动画处理</div><div class="line">        pullHeaderToZoom(newScrollValue);</div><div class="line">        if (onPullZoomListener != null) &#123;</div><div class="line">            onPullZoomListener.onPullZooming(newScrollValue);</div><div class="line">        &#125;</div><div class="line">        if (mPullZoom != null) &#123;</div><div class="line">            mPullZoom.onPullZooming(newScrollValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>pullHeaderToZoom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void pullHeaderToZoom(int newScrollValue) &#123;</div><div class="line">        //放大动画是否结束，没结束先停止回到原始高度的动画</div><div class="line">        if (mScalingRunnable != null &amp;&amp; !mScalingRunnable.isFinished()) &#123;</div><div class="line">            mScalingRunnable.abortAnimation();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        ViewGroup.LayoutParams localLayoutParams = mZoomView.getLayoutParams();</div><div class="line">        //计算最新View的高度</div><div class="line">        int toHeight = Math.abs(newScrollValue) + mZoomViewHeight;</div><div class="line">        if (mZoomViewMaxHeight &gt; 0 &amp;&amp; toHeight &gt; mZoomViewMaxHeight) &#123;</div><div class="line">            toHeight = mZoomViewMaxHeight;</div><div class="line">        &#125;</div><div class="line">        localLayoutParams.height = toHeight;</div><div class="line">        mZoomView.setLayoutParams(localLayoutParams);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Material Design 是专为设计适用于多个平台和设备的视觉、运动与互动效果而制定的综合指南。 Android 现在已支持 Material Design 应用。 如果要在您的 Android 应用中使用 Material Design，请遵循Material De
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(6) - anko Layout绘制原理</title>
    <link href="https://xjlhhz.com/2018/05/10/20180510Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/05/10/20180510Kotlin入门记录/</id>
    <published>2018-05-10T05:14:00.000Z</published>
    <updated>2018-05-10T10:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ViewManager"><a href="#ViewManager" class="headerlink" title="ViewManager"></a>ViewManager</h2><p>在了解anko之前，我们必须要先了解一下ViewManager这个类，这个是一个接口，通过这个接口，我们可以在Activity中添加、移除和更新View，我们可以通过 Context.getSystemService()来或者这个类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void addView(View view, ViewGroup.LayoutParams params);</div><div class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params);</div><div class="line">public void removeView(View view);</div></pre></td></tr></table></figure></p><p>也就是说，只有实现了这个接口的类才能够在activity中对view进行操作。系统的ViewGroup就实现了这个接口。</p><h2 id="AnkoContext"><a href="#AnkoContext" class="headerlink" title="AnkoContext"></a>AnkoContext</h2><p>在anko中，所有的View的操作是通过AnkoContext这个类来实现 的，所以，AnkoContext实现了ViewManager接口，但是AnkoContext只提供添加功能，不提供view的移除和更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">interface AnkoContext&lt;out T&gt; : ViewManager &#123;</div><div class="line">    val ctx: Context</div><div class="line">    val owner: T</div><div class="line">    val view: View</div><div class="line"></div><div class="line">    override fun updateViewLayout(view: View, params: ViewGroup.LayoutParams) &#123;</div><div class="line">        throw UnsupportedOperationException()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    override fun removeView(view: View) &#123;</div><div class="line">        throw UnsupportedOperationException()</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>一旦我们调用了updateViewLayout或者removeView方法，那么将会抛异常，UnsupportedOperationException，不支持这种操作。<br>这个类中包含了下面的三个参数</p><ul><li>ctx: Context– 上下文信息</li><li>owner: T– 这个owner是这个UI的依附者，可能是Activity、fragment、viewHolder</li><li>view： View–AnkoComponent生成并返回的View<br>下面来看看ankoContext提供的几个静态方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">companion object &#123;</div><div class="line">        fun create(ctx: Context, setContentView: Boolean = false): AnkoContext&lt;Context&gt;</div><div class="line">                = AnkoContextImpl(ctx, ctx, setContentView)</div><div class="line"></div><div class="line">        fun createReusable(ctx: Context, setContentView: Boolean = false): AnkoContext&lt;Context&gt;</div><div class="line">                = ReusableAnkoContext(ctx, ctx, setContentView)</div><div class="line"></div><div class="line">        fun &lt;T&gt; create(ctx: Context, owner: T, setContentView: Boolean = false): AnkoContext&lt;T&gt;</div><div class="line">                = AnkoContextImpl(ctx, owner, setContentView)</div><div class="line"></div><div class="line">        fun &lt;T&gt; createReusable(ctx: Context, owner: T, setContentView: Boolean = false): AnkoContext&lt;T&gt;</div><div class="line">                = ReusableAnkoContext(ctx, owner, setContentView)</div><div class="line"></div><div class="line">        fun &lt;T: ViewGroup&gt; createDelegate(owner: T): AnkoContext&lt;T&gt; = DelegatingAnkoContext(owner)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>这4个方法返回的都是AnkoContext实体，那么区别是什么？</p><ul><li>create表示直接创建出AnkoContext，并且不能重用，一旦已经绑定了View，那么将抛出异常。</li><li>createReusable表示创建出可以复用的AnkoContext,如果一个AnkoContext已经添加了子View，那么它会重新add View</li><li>createDelegate；表示将view添加到相应的委托对象中，用来在自定义View中代替inflate方法。<br>我们来看看这几个方法的实现：<h3 id="AnkoContextImpl"><a href="#AnkoContextImpl" class="headerlink" title="AnkoContextImpl"></a>AnkoContextImpl</h3>create方法返回的是AnkoContextImpl<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">open class AnkoContextImpl&lt;T&gt;(</div><div class="line">        override val ctx: Context,</div><div class="line">        override val owner: T,</div><div class="line">        private val setContentView: Boolean</div><div class="line">) : AnkoContext&lt;T&gt; &#123;</div><div class="line">    private var myView: View? = null</div><div class="line"></div><div class="line">    override val view: View</div><div class="line">        get() = myView ?: throw IllegalStateException(&quot;View was not set previously&quot;)</div><div class="line"></div><div class="line">    //将View添加到context中</div><div class="line">    override fun addView(view: View?, params: ViewGroup.LayoutParams?) &#123;</div><div class="line">        </div><div class="line">        if (view == null) return</div><div class="line"></div><div class="line">        if (myView != null) &#123;</div><div class="line">            //如果myView！=null，表示已经添加了View了，如果是create方法调用的，那么将会抛出异常</div><div class="line">            alreadyHasView()</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.myView = view</div><div class="line"></div><div class="line">        if (setContentView) &#123;</div><div class="line">            //如果需要setContentView，那么执行addView操作</div><div class="line">            doAddView(ctx, view)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private fun doAddView(context: Context, view: View) &#123;</div><div class="line">        when (context) &#123;</div><div class="line">            //找到activity，然后执行setContentView</div><div class="line">            is Activity -&gt; context.setContentView(view)</div><div class="line">            is ContextWrapper -&gt; doAddView(context.baseContext, view)</div><div class="line">            else -&gt; throw IllegalStateException(&quot;Context is not an Activity, can&apos;t set content view&quot;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    open protected fun alreadyHasView(): Unit = throw IllegalStateException(&quot;View is already set: $myView&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="ReusableAnkoContext"><a href="#ReusableAnkoContext" class="headerlink" title="ReusableAnkoContext"></a>ReusableAnkoContext</h3><p>createReusable返回的是ReusableAnkoContext实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">internal class ReusableAnkoContext&lt;T&gt;(</div><div class="line">        override val ctx: Context,</div><div class="line">        override val owner: T,</div><div class="line">        setContentView: Boolean</div><div class="line">) : AnkoContextImpl&lt;T&gt;(ctx, owner, setContentView) &#123;</div><div class="line">    override fun alreadyHasView() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为createReusable表示创建的是可重用布局，而AnkoContextImpl在已经绑定了View的时候，将会通过alreadyHasView抛出异常。所以ReusableAnkoContext通过复写alreadyHasView，并且来让布局可重用。</p><h3 id="DelegatingAnkoContext"><a href="#DelegatingAnkoContext" class="headerlink" title="DelegatingAnkoContext"></a>DelegatingAnkoContext</h3><p>createDelegate(owner: T)返回的是DelegatingAnkoContext实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">internal class DelegatingAnkoContext&lt;T: ViewGroup&gt;(override val owner: T): AnkoContext&lt;T&gt; &#123;</div><div class="line">    override val ctx: Context = owner.context</div><div class="line">    override val view: View = owner</div><div class="line"></div><div class="line">    override fun addView(view: View?, params: ViewGroup.LayoutParams?) &#123;</div><div class="line">        if (view == null) return</div><div class="line"></div><div class="line">        if (params == null) &#123;</div><div class="line">            owner.addView(view)</div><div class="line">        &#125; else &#123;</div><div class="line">            owner.addView(view, params)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>DelegatingAnkoContext会将view添加到owner上，而不是Activity。</p><h2 id="AnkoComponen"><a href="#AnkoComponen" class="headerlink" title="AnkoComponen"></a>AnkoComponen</h2><p>在Anko中，如果我们想要它的预览特性，那么我们就需要用到AnkoComponen，只有继承了AnkoComponen，并且结合anko support，就能�够预览了，我们需要在实现createView方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface AnkoComponent&lt;in T&gt; &#123;</div><div class="line">    fun createView(ui: AnkoContext&lt;T&gt;): View</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们通过createView方法绘制我们想要的View并返回。AnkoComponent有一个扩展方法setContentView,是用来给Activity设置ContentView的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : Activity&gt; AnkoComponent&lt;T&gt;.setContentView(activity: T): View =</div><div class="line">        createView(AnkoContextImpl(activity, activity, true))</div></pre></td></tr></table></figure></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>AnkoContext内部添加了几个扩展函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline fun Context.UI(setContentView: Boolean, init: AnkoContext&lt;Context&gt;.() -&gt; Unit): AnkoContext&lt;Context&gt; =</div><div class="line">        createAnkoContext(this, init, setContentView)</div><div class="line"></div><div class="line">inline fun Context.UI(init: AnkoContext&lt;Context&gt;.() -&gt; Unit): AnkoContext&lt;Context&gt; =</div><div class="line">        createAnkoContext(this, init)</div><div class="line"></div><div class="line">inline fun Fragment.UI(init: AnkoContext&lt;Fragment&gt;.() -&gt; Unit): AnkoContext&lt;Fragment&gt; =</div><div class="line">        createAnkoContext(activity, init)</div></pre></td></tr></table></figure></p><p>在Activity和fragment中，可以直接通过UI的方式调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UI &#123; </div><div class="line">   .....</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>然后内部会调用createAnkoContext，将UI里面的View传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T&gt; T.createAnkoContext(</div><div class="line">           ctx: Context,</div><div class="line">           init: AnkoContext&lt;T&gt;.() -&gt; Unit,</div><div class="line">           setContentView: Boolean = false</div><div class="line">   ): AnkoContext&lt;T&gt; &#123;</div><div class="line">       val dsl = AnkoContextImpl(ctx, this, setContentView)</div><div class="line">       dsl.init()</div><div class="line">       return dsl</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>内部还是调用AnkoContextImpl，并且调用内部还是调用AnkoContextImpl的init方法，初始化UI，并添加ctx中.</p><h2 id="AnkoUI布局的动态创建"><a href="#AnkoUI布局的动态创建" class="headerlink" title="AnkoUI布局的动态创建"></a>AnkoUI布局的动态创建</h2><p>在了解AnkoUI的布局的创建之前，我们需要先了解一下anko支持的dsl.</p><h3 id="DSL-Domain-Specific-Language"><a href="#DSL-Domain-Specific-Language" class="headerlink" title="DSL(Domain-Specific-Language)"></a>DSL(Domain-Specific-Language)</h3><p>dsl指的是特定领域的语言，kotlin的DSL特性支持就是扩展，anko通过dsl，才有了anko layout库。</p><h3 id="带接收者的函数字面值"><a href="#带接收者的函数字面值" class="headerlink" title="带接收者的函数字面值"></a>带接收者的函数字面值</h3><p>在kotlin中，支持给函数指定接收者对象，而无需额外的限定符，有点类似于扩展函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">init: (@AnkoViewDslMarker _RelativeLayout).() -&gt; Unit</div></pre></td></tr></table></figure></p><p>相当于() -&gt; Unit指定的接收者对象为_RelativeLayout<br>如果在函数体内部可以调用接收者对象的方法，那么假若这个方法又是带接收者类型的方法，那么就可以不断的往下调用了。</p><h3 id="anko布局"><a href="#anko布局" class="headerlink" title="anko布局"></a>anko布局</h3><p>下面是一个简单的anko布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">relativeLayout &#123;</div><div class="line">                imageView &#123;</div><div class="line">                    adjustViewBounds = true</div><div class="line">                    scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">                    imageResource = R.drawable.bg_members</div><div class="line">                &#125;.lparams(width = matchParent, height = matchParent)</div><div class="line">                statusBar = view &#123;</div><div class="line">                    id = statusBarHolder</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>anko给ViewManager添加了大部分组件的扩展函数,这个根节点relativeLayout将会调用到扩展函数中，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">inline fun ViewManager.relativeLayout(): android.widget.RelativeLayout = relativeLayout() &#123;&#125;</div><div class="line">inline fun ViewManager.relativeLayout(init: (@AnkoViewDslMarker _RelativeLayout).() -&gt; Unit): android.widget.RelativeLayout &#123;</div><div class="line">    return ankoView(`$$Anko$Factories$Sdk15ViewGroup`.RELATIVE_LAYOUT, theme = 0) &#123; init() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面这个relativeLayout方法中，接收一个() -&gt; Unit的lambada表达式，这个表达式限定于relativeLayout，所以这个参数就是relativelayout里面的元素,在上面的例子就是这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">imageView &#123;</div><div class="line">        adjustViewBounds = true</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        imageResource = R.drawable.bg_members</div><div class="line">        &#125;.lparams(width = matchParent, height =matchParent)&#123;</div><div class="line">            statusBar = view &#123;</div><div class="line">            id = statusBarHolder</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>有一个注解AnkoViewDslMarker，这个参数会给对应_RelativeLayout的View对象扩展一个applyRecursively方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@DslMarker</div><div class="line">@Target(AnnotationTarget.TYPE)</div><div class="line">annotation class AnkoViewDslMarker</div><div class="line"></div><div class="line">/**</div><div class="line"> * Apply [f] to this [View] and to all of its children recursively.</div><div class="line"> * </div><div class="line"> * @return the receiver.</div><div class="line"> */</div><div class="line">inline fun &lt;T : View&gt; T.applyRecursively(noinline f: (View) -&gt; Unit): T &#123;</div><div class="line">    AnkoInternals.applyRecursively(this, f)</div><div class="line">    return this</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>applyRecursively扩展T对象，并且接收一个f函数，在这里指的是View的init方法，会先执行f方法，然后遍历所有的子元素，并进行创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fun applyRecursively(v: View, style: (View) -&gt; Unit) &#123;</div><div class="line">       //执行init方法，创建对象</div><div class="line">       style(v)</div><div class="line">       if (v is ViewGroup) &#123;</div><div class="line">       //如果是ViewGroup，那么可以添加子View，看看是否有子View</div><div class="line">           val maxIndex = v.childCount - 1</div><div class="line">           for (i in 0 .. maxIndex) &#123;</div><div class="line">               //对子View执行applyRecursively方法</div><div class="line">               v.getChildAt(i)?.let &#123; applyRecursively(it, style) &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>将会调用ViewManager的ankoView方法。</p><h4 id="anko默认支持的工厂"><a href="#anko默认支持的工厂" class="headerlink" title="anko默认支持的工厂"></a>anko默认支持的工厂</h4><p>我们上面的用的构造工厂是sdk15提供的工厂，我们看看工厂里面的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">internal object `$$Anko$Factories$Sdk15ViewGroup` &#123;</div><div class="line">    val APP_WIDGET_HOST_VIEW = &#123; ctx: Context -&gt; _AppWidgetHostView(ctx) &#125;</div><div class="line">    val ABSOLUTE_LAYOUT = &#123; ctx: Context -&gt; _AbsoluteLayout(ctx) &#125;</div><div class="line">    val FRAME_LAYOUT = &#123; ctx: Context -&gt; _FrameLayout(ctx) &#125;</div><div class="line">    val GALLERY = &#123; ctx: Context -&gt; _Gallery(ctx) &#125;</div><div class="line">    val GRID_LAYOUT = &#123; ctx: Context -&gt; _GridLayout(ctx) &#125;</div><div class="line">    val GRID_VIEW = &#123; ctx: Context -&gt; _GridView(ctx) &#125;</div><div class="line">    val HORIZONTAL_SCROLL_VIEW = &#123; ctx: Context -&gt; _HorizontalScrollView(ctx) &#125;</div><div class="line">    val IMAGE_SWITCHER = &#123; ctx: Context -&gt; _ImageSwitcher(ctx) &#125;</div><div class="line">    val LINEAR_LAYOUT = &#123; ctx: Context -&gt; _LinearLayout(ctx) &#125;</div><div class="line">    val RADIO_GROUP = &#123; ctx: Context -&gt; _RadioGroup(ctx) &#125;</div><div class="line">    val RELATIVE_LAYOUT = &#123; ctx: Context -&gt; _RelativeLayout(ctx) &#125;</div><div class="line">    val SCROLL_VIEW = &#123; ctx: Context -&gt; _ScrollView(ctx) &#125;</div><div class="line">    val TABLE_LAYOUT = &#123; ctx: Context -&gt; _TableLayout(ctx) &#125;</div><div class="line">    val TABLE_ROW = &#123; ctx: Context -&gt; _TableRow(ctx) &#125;</div><div class="line">    val TEXT_SWITCHER = &#123; ctx: Context -&gt; _TextSwitcher(ctx) &#125;</div><div class="line">    val VIEW_ANIMATOR = &#123; ctx: Context -&gt; _ViewAnimator(ctx) &#125;</div><div class="line">    val VIEW_SWITCHER = &#123; ctx: Context -&gt; _ViewSwitcher(ctx) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对于每一个View，内部都有一个相对应的构建方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">open class _RelativeLayout(ctx: Context): RelativeLayout(ctx) &#123;</div><div class="line">     ...</div><div class="line">     inline fun &lt;T: View&gt; T.lparams(</div><div class="line">            width: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">            height: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">            init: RelativeLayout.LayoutParams.() -&gt; Unit</div><div class="line">    ): T &#123;</div><div class="line">        val layoutParams = RelativeLayout.LayoutParams(width, height)</div><div class="line">        layoutParams.init()</div><div class="line">        this@lparams.layoutParams = layoutParams</div><div class="line">        return this</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个_RelativeLayout内部都是重载的lparams，也就是通过这个方法来创建布局的param属性。</p><h3 id="ankoView的实现"><a href="#ankoView的实现" class="headerlink" title="ankoView的实现"></a>ankoView的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T : View&gt; ViewManager.ankoView(factory: (ctx: Context) -&gt; T, theme: Int, init: T.() -&gt; Unit): T &#123;</div><div class="line">    //获取需要依附的context对象</div><div class="line">    val ctx = AnkoInternals.wrapContextIfNeeded(AnkoInternals.getContext(this), theme)</div><div class="line">    //通过工厂模式返回View</div><div class="line">    val view = factory(ctx)</div><div class="line">    view.init()</div><div class="line">    //添加View，并返回</div><div class="line">    AnkoInternals.addView(this, view)</div><div class="line">    return view</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个ankoView将会接收工厂方法，返回View，然后执行init方法。这个init方法就行上面的工厂对象的构造函数。下面看看View添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : View&gt; addView(manager: ViewManager, view: T) = when (manager) &#123;</div><div class="line">      //针对于根节点下的View</div><div class="line">      is ViewGroup -&gt; manager.addView(view)</div><div class="line">      //针对于根节点</div><div class="line">      is AnkoContext&lt;*&gt; -&gt; manager.addView(view, null)</div><div class="line">      else -&gt; throw AnkoException(&quot;$manager is the wrong parent&quot;)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>将会直接添加到parent节点或者context下。</p><p>下面是一个自己理解的ankoView的绘制步骤:<br><img src="http://onu21exz8.bkt.clouddn.com/ankoView.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ViewManager&quot;&gt;&lt;a href=&quot;#ViewManager&quot; class=&quot;headerlink&quot; title=&quot;ViewManager&quot;&gt;&lt;/a&gt;ViewManager&lt;/h2&gt;&lt;p&gt;在了解anko之前，我们必须要先了解一下ViewManager这个类
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(5) - anko Layout使用</title>
    <link href="https://xjlhhz.com/2018/05/08/20180508Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/05/08/20180508Kotlin入门记录/</id>
    <published>2018-05-08T05:14:00.000Z</published>
    <updated>2018-05-10T10:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anko"><a href="#anko" class="headerlink" title="anko"></a>anko</h2><p>Anko 是一个用 Kotlin 写的Android DSL (Domain-Specific Language)。 内部提供很多工具，详情可点<a href="https://github.com/Kotlin/anko" target="_blank" rel="external">https://github.com/Kotlin/anko</a><br>在这里我们主要涉及的是anko的layout部分，长久以来，Android视图都是用XML来完成布局的。用xml写布局有下面这些缺点：</p><ul><li>不是类型安全的;</li><li>不是null-safe;</li><li>强迫你对每个layout编写几乎相同的代码;</li><li>在设备上解析XML费电费CPU;</li><li>最惨的是代码不可复用<br>所以，如果可以，我们可以尝试用anko来绘制布局。</li></ul><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>因为anko版本发布的并不是很多，用户量也不是很多，所有网上能找到的资源是非常少的，所以配置的时候总会出现许许多多的问题。现在android studio默认已经集成了kotlin了，我们需要配置的就是anko support，也就是anko preview，用来预览anko写的ui布局的工具。</p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><h5 id="as联网下载"><a href="#as联网下载" class="headerlink" title="as联网下载"></a>as联网下载</h5><p>我们可以从android studio内置的下载器中下载，从Preference-&gt;Plugins中搜索Anko Support，并进行下载。<br><img src="http://onu21exz8.bkt.clouddn.com/as%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6" alt=""></p><h5 id="官网下载导入"><a href="#官网下载导入" class="headerlink" title="官网下载导入"></a>官网下载导入</h5><p>我们也能够从官网中下载指定的anko support版本，点击<a href="https://plugins.jetbrains.com/plugin/7734-anko-support，选择指定版本进行下载，然后在as导入。" target="_blank" rel="external">https://plugins.jetbrains.com/plugin/7734-anko-support，选择指定版本进行下载，然后在as导入。</a><br><img src="http://onu21exz8.bkt.clouddn.com/as%E5%AF%BC%E5%85%A5%E6%8F%92%E4%BB%B6" alt=""><br>在android选择项目的页面，选择configuration-&gt;plugins-&gt;install plugin from disk,选择相应的plugin包导入。</p><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><p>目前官网最新的anko support插件版本是0.10.5,如果我们的as版本是3.0，那么还是将会出现anko preview不能预览的情况，报错情况为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Anko Support threw an uncaught NoSuchMethodError</div></pre></td></tr></table></figure></p><p>这个是因为as3.0的问题不支持anko support，这个时候我们只需要更新as的版本到3.1之后，anko support就能够使用了。</p><h2 id="开始使用anko"><a href="#开始使用anko" class="headerlink" title="开始使用anko"></a>开始使用anko</h2><p>首先需要先引入anko依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &quot;org.jetbrains.anko:anko:0.10.5&quot;</div></pre></td></tr></table></figure></p><p>这个是anko给我们集成的一个包含anko所有功能的库，包含了</p><ul><li>anko commons： 一些常用的扩展函数，包括intent、dialog、log、resources等</li><li>ankoLayout： anko布局</li><li>ankoSqlite： anko优化的数据库操作</li><li>anko Coroutines: anko对于kotlin协程的扩展</li></ul><p>如果我们需要大部分的anko的功能，我们可以直接这么引入，否则我们需要单独引入每一个功能的依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    // Anko Commons</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-commons:$anko_version&quot;</div><div class="line"></div><div class="line">    // Anko Layouts</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-sdk25:$anko_version&quot; // sdk15, sdk19, sdk21, sdk23 are also available</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-appcompat-v7:$anko_version&quot;</div><div class="line"></div><div class="line">    // Coroutine listeners for Anko Layouts</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-sdk25-coroutines:$anko_version&quot;</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-appcompat-v7-coroutines:$anko_version&quot;</div><div class="line"></div><div class="line">    // Anko SQLite</div><div class="line">    implementation &quot;org.jetbrains.anko:anko-sqlite:$anko_version&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们只需要从中引入我们所必须的库就ok了。在这里我们需要注意的是anko-sdk的引入需要和我们build.gradle中的minSdkVersion做下适配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">org.jetbrains.anko:anko-sdk15 ： 15 &lt;= minSdkVersion &lt; 19</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk19 ： 19 &lt;= minSdkVersion &lt; 21</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk21 ： 21 &lt;= minSdkVersion &lt; 23</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk23 ： 23 &lt;= minSdkVersion &lt; 25</div><div class="line"></div><div class="line">org.jetbrains.anko:anko-sdk25 ： 25 &lt;= minSdkVersion</div></pre></td></tr></table></figure></p><p>如果没有按照要求做sdk适配，那么一旦运行在不符合的版本，将会直接崩溃～切记</p><h3 id="AnkoComponent"><a href="#AnkoComponent" class="headerlink" title="AnkoComponent"></a>AnkoComponent</h3><p>我们可以在activity的onCreate、fragemnt的onCreateView中直接绘制ui，但是这样就让ui绘制代码�与activity、fragment代码有了耦合了。所有我们可以将Anko代码定义到另外一个class中，作为对应的UiClass，这就需要AnkoComponent。</p><h4 id="定义UIClass"><a href="#定义UIClass" class="headerlink" title="定义UIClass"></a>定义UIClass</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MemberCenterActivityUI : AnkoComponent&lt;MemberCenterActivity&gt; &#123;</div><div class="line">        override fun createView(ui: AnkoContext&lt;MemberCenterActivity&gt;) : View = with(ui)&#123;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>在我们定义了相应的uiclass之后，我们需要实现其中的oncreateView方法，这个类的返回就是一个View，就是我们anko绘制的布局。<br>添加上with(ui)，是为了让dsl代码块能够以this的形式持有AnkoContext，这个AnkoContext是一个非常有用的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">val ctx: Context</div><div class="line">val owner: T</div><div class="line">val view: View</div></pre></td></tr></table></figure></p><p>ctx就是上下文信息，owner就是uiclass依附的类的实例，在这个例子里面指的是MemberCenterActivity，我们可以通过owner调用MemberCenterActivity的任意public方法。</p><h4 id="绘制布局"><a href="#绘制布局" class="headerlink" title="绘制布局"></a>绘制布局</h4><h5 id="所有布局"><a href="#所有布局" class="headerlink" title="所有布局"></a>所有布局</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">relativeLayout &#123;</div><div class="line">    imageView &#123;</div><div class="line">        adjustViewBounds = true</div><div class="line">        scaleType = ImageView.ScaleType.CENTER_CROP</div><div class="line">        imageResource = R.drawable.bg_members</div><div class="line">    &#125;.lparams(width = matchParent, height = matchParent)</div><div class="line">    statusBar = view &#123;</div><div class="line">        id = statusBarHolder</div><div class="line">    &#125;.lparams &#123;</div><div class="line">        height = statusBarHeight(ctx)</div><div class="line">        width = matchParent</div><div class="line">    &#125;</div><div class="line">    toolbar &#123;</div><div class="line"></div><div class="line">        id = toolbarId</div><div class="line">        backgroundColor = R.color.color_00000000</div><div class="line"></div><div class="line">        imageView &#123;</div><div class="line">            imageResource = R.drawable.ic_arrow_back_white</div><div class="line">            onClick &#123;</div><div class="line">                owner.finish()</div><div class="line">            &#125;</div><div class="line">        &#125;.lparams(height = wrapContent, width = wrapContent) &#123;</div><div class="line">            padding = dip(5)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        textView(&quot;会员中心&quot;) &#123;</div><div class="line">            textColor = R.color.color_ffffff</div><div class="line">            textSize = R.dimen.dimens_18sp.toFloat()</div><div class="line">        &#125;.lparams(width = wrapContent, height = wrapContent) &#123;</div><div class="line">            gravity = Gravity.CENTER</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;.lparams(height = dip(50), width = matchParent) &#123;</div><div class="line">        below(statusBar)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    memberRv = recyclerView &#123;</div><div class="line">        itemAnimator.changeDuration = 0</div><div class="line">        layoutManager = LinearLayoutManager(context)</div><div class="line">        adapter = MemberCenterAdapter(context, null)</div><div class="line">        memberAdapter = adapter as MemberCenterAdapter</div><div class="line">    &#125;.lparams(width = matchParent, height = matchParent) &#123;</div><div class="line">        below(toolbarId)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>每一个anko布局，最多只能有一个根节点，在这个例子中最外层的根节点就是relativelayout，这个组件的名称都是以小写字母开头的，就是anko给java的View多包装了一层，以便在dsl使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">imageView &#123;</div><div class="line">       ....</div><div class="line">       &#125;.lparams(width = matchParent, height = matchParent)&#123;</div><div class="line">       .....</div><div class="line">       &#125;</div></pre></td></tr></table></figure></p><p>控件直接包含的区域是添加控件的直接参数的，比如说imageView的src，scaleType，TextView的text，textSize，textColor等。而lparams是用来定义组件的大小，布局、位置属性的，包括height、width、gravity等等。<br>当然，我们也可以不指定lparams，这样的话，它会有默认的宽高,即wrap_content。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T: View&gt; T.lparams(</div><div class="line">            width: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT,</div><div class="line">            height: Int = android.view.ViewGroup.LayoutParams.WRAP_CONTENT</div><div class="line">    ): T &#123;</div><div class="line">        val layoutParams = FrameLayout.LayoutParams(width, height)</div><div class="line">        this@lparams.layoutParams = layoutParams</div><div class="line">        return this</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>整个imageView域是有返回值的，返回的就是这个imageView实体，我们也可以理解成这个域创建了imageView实体并返回。</p><h5 id="anko扩展View"><a href="#anko扩展View" class="headerlink" title="anko扩展View"></a>anko扩展View</h5><p>当我们想要用自定义View或者anko没有支持的View，我们可以扩展ankoView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">inline fun ViewManager.mapView() = mapView(theme = 0) &#123;&#125;</div><div class="line"></div><div class="line">inline fun ViewManager.mapView(init: MapView.() -&gt; Unit): MapView &#123;</div><div class="line">    return ankoView(&#123; MapView(it) &#125;, theme = 0, init = init)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个mapView就是我们想要扩展的View，这个是官网给的例子，下面我们来扩展fresco的simpledraweeView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">inline fun ViewManager.simpleDraweeView(theme: Int = 0) = simpleDraweeView(theme) &#123;&#125;</div><div class="line">inline fun ViewManager.simpleDraweeView(theme: Int = 0, init: SimpleDraweeView.() -&gt; Unit) : SimpleDraweeView &#123;</div><div class="line">    return ankoView(&#123; SimpleDraweeView(it) &#125;, theme, init)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样我们就能在anko dsl中直接使用simpleDraweeView了</p><h5 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a>onclick</h5><p>anko中已经给我们添加了onclick方法，我们可以在每个View中添加onClick，并且指定其实现，anko将会给这个View设置listener<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">fun android.view.View.onClick(</div><div class="line">        context: CoroutineContext = UI,</div><div class="line">        handler: suspend CoroutineScope.(v: android.view.View?) -&gt; Unit</div><div class="line">) &#123;</div><div class="line">    setOnClickListener &#123; v -&gt;</div><div class="line">        launch(context) &#123;</div><div class="line">            handler(v)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="一些小点"><a href="#一些小点" class="headerlink" title="一些小点"></a>一些小点</h5><ul><li>用了anko之后，我们如果需要对于id的诉求只有一个，那就是在relativelayout中指定位置时，需要通过id，才指定below、above、left、right的位置，对于id的设置，我们需要自己定义Id的int值，我们得保证它不会重复。</li><li>对于imageView，不再有src属性，因为anko内部其实是动态代码创建view，所有对于这个src，替代的就是在代码中指定的imageResouce</li><li>对于color，需要的就是color的值，而非项目中的colorId</li><li>对于textView，它的textSize指定为f，而非sp</li><li>如果我们想要用recyclerView，那么我们需要引入anko的依赖库，或者直接扩展ankoView</li><li>对于dp计算，anko内部给我们实现了dip方法计算。</li></ul><h4 id="anko-preivew"><a href="#anko-preivew" class="headerlink" title="anko preivew"></a>anko preivew</h4><p>对于anko support，虽然可能它的代码效率比较高，但是它在预览的时候并没有办法做到像在xml里面实时预览，只有在代码build之后才能够看到预览页面，而且每次修改都必须要进行rebuild，这个是一个非常让人无法接受的点，刚开始效率肯定会低，但是随着代码的熟练，效率还是会有所提升的，毕竟anko的ui绘制效率要笔xml高。可以通过command+f9进行build。</p><h4 id="ankoComponent元素的调用"><a href="#ankoComponent元素的调用" class="headerlink" title="ankoComponent元素的调用"></a>ankoComponent元素的调用</h4><p>我们免不了需要在activity，framgent等类中更新uiClass的元素的状态。所以了解uiClass与activity，fragment及viewHolder的绑定及调用还是有必要的。</p><h5 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h5><h6 id="activity"><a href="#activity" class="headerlink" title="activity"></a>activity</h6><p>activity绑定ankoComponent可以通过下面这种方式来绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MemberCenterActivityUI().setContentView();</div></pre></td></tr></table></figure></p><h6 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val view = MemberCenterFragmentUI().createView(AnkoContext.create(ctx, MemberCenterFragment()))</div></pre></td></tr></table></figure><p>在onCreateView中返回这个View，就和fragment进行绑定了。</p><h6 id="viewHolder"><a href="#viewHolder" class="headerlink" title="viewHolder"></a>viewHolder</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MemberCenterItemUI().createView(AnkoContext.create(context, parent)</div></pre></td></tr></table></figure><h5 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h5><p>在自定义View中，对于anko来说是一个比较不方便的使用，因为在anko support的支持预览的前提是使用AnkoComponent，而自定义View的View绑定却不通过AnkoComponent，也有可能是我现在没发现，目前发现的支持绑定的方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  constructor(context: Context) : super(context) &#123;</div><div class="line">        initView()</div><div class="line">    &#125;</div><div class="line"> private fun initView() = AnkoContext.createDelegate(this).apply &#123;</div><div class="line">...init anko view</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在java的自定义View中，是通过构造函数调用inflate方法，来将xml设置到该自定义View中。<br>在anko中，利用AnkoContext.createDelegate(this).apply来替代inflate。</p><p>我们可以先通过AnkoComponent来预览界面，然后预览完成之后再将anko代码放在AnkoContext.createDelegate(this).apply中。</p><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>对于三者的调用其实都是一致的，我们只需要缓存AnkoComponent类的实例就能够通过这个实例引用其内部的ui组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//in activity</div><div class="line">mainUI = MemberCenterActivityUI()</div><div class="line">    mainUI.setContentView(this)</div><div class="line">    </div><div class="line"> TextUtils.isEmpty(chargeTip?.chargeButtonDesc).yes &#123;</div><div class="line">                mainUI.bottomMemberOpenDesc.visibility = View.GONE</div><div class="line">            &#125;.no &#123;</div><div class="line">                mainUI.bottomMemberOpenDesc.visibility = View.VISIBLE</div><div class="line">                mainUI.bottomMemberOpenDesc.text = chargeTip?.chargeButtonDesc</div><div class="line">            &#125;</div><div class="line">            TextUtils.isEmpty(chargeTip?.chargeButtonUrl).yes &#123;</div><div class="line">                mainUI.btnOpenViewIcon.visibility = View.GONE</div><div class="line">            &#125;.no &#123;</div><div class="line">                mainUI.btnOpenViewIcon.visibility = View.VISIBLE</div><div class="line">                KKGifPlayer</div><div class="line">                        .with(this)</div><div class="line">                        .load(chargeTip?.chargeButtonUrl)</div><div class="line">                        .playPolicy(KKGifPlayer.PlayPolicy.Auto_Always)</div><div class="line">                        .into(openViewIcon)</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;anko&quot;&gt;&lt;a href=&quot;#anko&quot; class=&quot;headerlink&quot; title=&quot;anko&quot;&gt;&lt;/a&gt;anko&lt;/h2&gt;&lt;p&gt;Anko 是一个用 Kotlin 写的Android DSL (Domain-Specific Language)。 内部提
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(4)</title>
    <link href="https://xjlhhz.com/2018/05/07/20180507Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/05/07/20180507Kotlin入门记录/</id>
    <published>2018-05-07T05:14:00.000Z</published>
    <updated>2018-05-05T15:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="onAttachedToWindow和onDetachedFromWindow"><a href="#onAttachedToWindow和onDetachedFromWindow" class="headerlink" title="onAttachedToWindow和onDetachedFromWindow"></a>onAttachedToWindow和onDetachedFromWindow</h2><p>这个是无关kotlin的，只是刚好在写kt代码时遇到的一个问题，<br>关于onAttachedToWindow和onDetachedFromWindow的触发时机，</p><h3 id="onAttachedToWindow就是在这个View被添加到Window时触发的"><a href="#onAttachedToWindow就是在这个View被添加到Window时触发的" class="headerlink" title="onAttachedToWindow就是在这个View被添加到Window时触发的"></a>onAttachedToWindow就是在这个View被添加到Window时触发的</h3><p>顾名思义，onAttachedToWindow就是在这个View被添加到Window时触发的，通过了dispatchAttachedToWindow这个方法触发的，那么View被添加到window的时机又是什么，其实就是对应的activity在生命周期onResume的时候调用的，activity对应的view在onResume的时候被添加添加到window。且每一个view都只会被调用一次，父view调用在前，不论view的visibility状态都会被调用，适合做些view特定的初始化操作；</p><h3 id="onDetachedFromWindow"><a href="#onDetachedFromWindow" class="headerlink" title="onDetachedFromWindow"></a>onDetachedFromWindow</h3><p>onDetachedFromWindow方法是在activity的生命周期destroy的时候被调用的，也就是act对应的view从window中移除的时候，且每个view只会被调用一次，父view的调用在后，也不论view的visibility状态都会被调用，适合做最后的清理操作；</p><h2 id="kotlin类的继承性"><a href="#kotlin类的继承性" class="headerlink" title="kotlin类的继承性"></a>kotlin类的继承性</h2><p>java的class默认都是可以继承的，只有在声明为final的class才是不可继承的。而kotlin却是相反的，默认的类都是不可继承的，也就是默认的修饰符为final，只有显式的声明为open的类才是可以继承的。而对于抽象类，java和kotlin默认都是可以继承的，但是子类必须是抽象类或者实现了该类的所有抽象方法。</p><h2 id="kotlin扩展函数的java调用方式"><a href="#kotlin扩展函数的java调用方式" class="headerlink" title="kotlin扩展函数的java调用方式"></a>kotlin扩展函数的java调用方式</h2><p>kotlin中的扩展函数是非常方便的，刚开始以为在java中不能够调用到kotlin中的扩展函数，后面发现不是的，对于我们定义的扩展函数类，在java中有相应的使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//KotlinExt.kt</div><div class="line">fun Int.dp2px(context: Context?): Int &#123;</div><div class="line">    val scale = context?.resources?.displayMetrics?.density?.toInt()</div><div class="line">    return (this * (scale ?: 2) + 0.5f).toInt()</div><div class="line">&#125;</div><div class="line">//java中调用</div><div class="line">KotlinExtKt.dp2px(2, getContext());</div></pre></td></tr></table></figure></p><p>我们只需要import相应的kotlinExt文件，然后就可以调用其中的方法，但使用方式和kotlin有不一致的地方，对于kt的扩展函数的接收者，也就是上面的Int，在java中会被认为是第一个入参， 如果扩展函数接受的是普通参数，那么这个参数就直接作为后续的入参。<br>如果扩展数据的第二个参数是lambda表达式，那么有java相应的生成方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//KotlinExt.kt</div><div class="line">inline fun &lt;T&gt; Boolean.yes(action: () -&gt; T): Boolean &#123;</div><div class="line">    if (this) action()</div><div class="line">    return this</div><div class="line">&#125;</div><div class="line">//java中调用</div><div class="line">KotlinExtKt.yes(true, new Function0&lt;Object&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public Object invoke() &#123;</div><div class="line">                        return null;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p><p>上面的Boolean的扩展yes方法，接收一个高阶函数，kt中用lambda表示，而在java中，需要以一个匿名内部类的方式替代，</p><h2 id="kotlin中内部类"><a href="#kotlin中内部类" class="headerlink" title="kotlin中内部类"></a>kotlin中内部类</h2><p>在java中，如果定义一个非静态类内部类，默认将会持有外部类的引用，经常会造成外部类无法被回收，导致内存泄漏，而kotlin中，内部类默认不会持有外部类的引用，只有添加上inner关键字修饰，才会持有外部引用。</p><h2 id="kotlin-密封类"><a href="#kotlin-密封类" class="headerlink" title="kotlin 密封类"></a>kotlin 密封类</h2><p>kotlin的密封类是java所没有的，在kotlin中，如果一个类被标明为密封类，那么其所有的子类都需要在父类中列出，作为密封类的嵌套内部类</p><h2 id="kotlin中的惰性集合操作"><a href="#kotlin中的惰性集合操作" class="headerlink" title="kotlin中的惰性集合操作"></a>kotlin中的惰性集合操作</h2><p>kotlin中一些集合操作，比如说map和filter，对于我们来说是非常方便的，比如说筛选一个人群的年龄大于30的人的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.map(it.name).filter&#123;it.age &gt; 30&#125;</div></pre></td></tr></table></figure></p><p>但是上面这种方式，在链式调用的链足够长时，将会产生性能问题，因为链式调用的每一个步骤都会创建一个中间集合，用来存储中间结果，也就是说，每一个步骤的结果都存储在另外一个变量中。所以，kotlin给我们提供了另外一种使用方式，来避免创建中间对象。也就是惰性集合。sequencez作为惰性集合操作，可以优化map和filter等操作，将不会生成任何中间对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.asSequence().map(people.name).filter(it.startWith(&quot;a&quot;)).toList()</div></pre></td></tr></table></figure></p><p>sequencez会将元数据生成一个流式对象，对于集合的每一个元素利用iterator遍历，执行map和filter，筛选出符合条件的数据。<br>惰性集合的操作包含了中间操作和末端操作，中间操作就是转换操作，末端操作就是筛选操作，在上面的例子里面，map是中间操作，filter是末端操作，如果没有末端操作，那么，中间操作也不会执行，既然这样，如果我们末端操作停止了，中间操作也会停止，也就是说，并不会保证所有的中间操作都能够执行。</p><h2 id="butterknife库的使用"><a href="#butterknife库的使用" class="headerlink" title="butterknife库的使用"></a>butterknife库的使用</h2><p>在java中，butterknife库是一个众所周知的代替findViewId操作的库，如果我们直接在kotlin中想要使用butterknife这个库，那还是需要一些额外的操作的。</p><h3 id="引入KotterKnife或者自己提供extension"><a href="#引入KotterKnife或者自己提供extension" class="headerlink" title="引入KotterKnife或者自己提供extension"></a>引入KotterKnife或者自己提供extension</h3><p>这个是butterknife作者提供的另外一个kotlin版本的替代库。使用方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val updateTime by bind&lt;TextView&gt;(R.id.update_time)</div></pre></td></tr></table></figure></p><p>虽然我没看KotterKnife内部实现，但是应该跟我们自己提供扩展函数的实现方式是一样的，我们可以通过自己提供扩展函数来设置做这些操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">fun &lt;T : View&gt; Activity.bind(@IdRes idRes: Int): Lazy&lt;T&gt; &#123;</div><div class="line">    return lazy &#123; findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T : View&gt; View.bind(@IdRes idRes: Int): Lazy&lt;T&gt; &#123;</div><div class="line">    return lazy &#123; findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T : View&gt; android.support.v7.widget.RecyclerView.ViewHolder.bind(@IdRes idRes: Int): Lazy&lt;T&gt; &#123;</div><div class="line">    return lazy &#123; this.itemView.findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun &lt;T : View&gt; Fragment.bind(@IdRes idRes: Int): Lazy&lt;T?&gt; &#123;</div><div class="line">    return lazy &#123; this.view?.findViewById&lt;T&gt;(idRes) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个扩展数据其实就是代替我们执行findViewById操作，虽然我们是在初始化的时候定义了View的对象，但是它并不会马上执行，lazy关键字修饰的对象将会等到使用时再执行相应方法。也就是说，这个findViewById将会在setContentView之后执行，因为我们使用这个对象肯定是在其之后的。</p><h3 id="仍然使用butterknife"><a href="#仍然使用butterknife" class="headerlink" title="仍然使用butterknife"></a>仍然使用butterknife</h3><p>其实在kotlin中，我们还是可以使用butterknife的，只是我们需要将butterknife的注解解释器替换为kotlin annotation Processor tool，这样，在kt文件中就能够使用butterknife的注解了，我们不需要担心会对之前的注解产生影响，因为kapt是兼容了annotationProcessor的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</div><div class="line">====&gt;</div><div class="line">kapt &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;</div></pre></td></tr></table></figure></p><p>替换了kapt之后，就可以进行第二步了,在kt中利用laterinit修饰对象，来保证view对象可以在通过butterknife库赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@BindView(R.id.user_v_layout)</div><div class="line">   lateinit var vLayout: ImageView</div><div class="line">   @BindView(R.id.comment_user_icon)</div><div class="line">   lateinit var userIconIV: ImageView</div><div class="line">   @BindView(R.id.comment_user_name)</div><div class="line">   lateinit var userNameTV: TextView</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;onAttachedToWindow和onDetachedFromWindow&quot;&gt;&lt;a href=&quot;#onAttachedToWindow和onDetachedFromWindow&quot; class=&quot;headerlink&quot; title=&quot;onAttachedToWi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(3)</title>
    <link href="https://xjlhhz.com/2018/04/21/20180421Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/04/21/20180421Kotlin入门记录/</id>
    <published>2018-04-21T05:14:00.000Z</published>
    <updated>2018-05-05T15:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="todo标注"><a href="#todo标注" class="headerlink" title="todo标注"></a>todo标注</h2><p>在java中，使用todo标识并不会出现什么问题，在kotlin中，一旦我们实现了接口或者抽象类，那么我们自动生成的实现方法，将会带上kotlin的todo标注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override fun refreshServerTime(time: Long?) &#123;</div><div class="line">        TODO(&quot;not implemented&quot;) //To change body of created functions use File | Settings | File Templates.</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>如果我们没有删除掉todo这行代码，那么kotlin将会直接报错，kotlin.NotImplementedError，因为这个todo是kotlin默认我们将会删除掉的，如果在运行时还存在，那么执行到todo，并不会跳过，而是会执行，然后报错。</p><h2 id="kotlin标注"><a href="#kotlin标注" class="headerlink" title="kotlin标注"></a>kotlin标注</h2><p>在kotlin中，如果需要在kotlin的高阶函数表达式返回，而不需要直接在外层函数中返回，或者嵌套循环，想从内层循环终止外层循环等，这种时候我们就需要用到kotlin的label了。比如说下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private fun canAutoContinue(pos: Int): Boolean &#123;</div><div class="line">        if (commonGoodList == null || continueGoodList == null || commonGoodList!!.size &lt; pos) &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">        val commonGood: RechargeGood? = commonGoodList!![pos]</div><div class="line"></div><div class="line">        continueGoodList!!.forEach &#123;</div><div class="line">            if (it.upRenewId == commonGood?.id) &#123;</div><div class="line">                return true</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(&quot;1111&quot;)</div><div class="line">        return false</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>上面的在forEach中，return的执行将会直接将会结束掉canAutoContinue方法，如果我们只想结束掉forEach，我们可以像下面这样做。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private fun canAutoContinue(pos: Int): Boolean &#123;</div><div class="line">        if (commonGoodList == null || continueGoodList == null || commonGoodList!!.size &lt; pos) &#123;</div><div class="line">            return false</div><div class="line">        &#125;</div><div class="line">        val commonGood: RechargeGood? = commonGoodList!![pos]</div><div class="line"></div><div class="line">        continueGoodList!!.forEach lit@&#123;</div><div class="line">            if (it.upRenewId == commonGood?.id) &#123;</div><div class="line">                return@lit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        print(&quot;1111&quot;)</div><div class="line">        return false</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>如上面的lit label，那么这样return将会结束lit所指定的lable循环，从而继续往下执行。<br>比如说for循环嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">outFor@ for(x in 1..5) &#123;</div><div class="line">            for (y in 1..6) &#123;</div><div class="line">                if(x == y) &#123;</div><div class="line">                    break@outFor</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>一旦满足了x==y，然么将会直接跳出外层的for循环，否则一般的break，只会中断内层的for循环。要为一个表达式加标签，我们只要在其前加标签即可。<br>在返回和跳转语句中，可以指定标签来表示结束哪个标签对应的代码段<br>如果需要在lambda表达式</p><h2 id="kotlin-定义属性时的get和set方法"><a href="#kotlin-定义属性时的get和set方法" class="headerlink" title="kotlin 定义属性时的get和set方法"></a>kotlin 定义属性时的get和set方法</h2><p>kotlin定义属性时，可以同时定义get和set方法，而不需要再重新定义方法去赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private var delayTime: Long</div><div class="line">        private set(value) &#123;</div><div class="line">            delayTime = value</div><div class="line">        &#125;</div><div class="line">        get() &#123;</div><div class="line">            return KKConfigManager.getInstance().</div><div class="line">                    getConfig(KKConfigManager.ConfigType.GET_RECHARGE_ORDER_DELAY)</div><div class="line">                    .toLongOrNull() ?: 1000</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p><p>而且，可以添加上访问限定符。而这个get和set方法的设置，主要是通过代码中的位置来标示修饰的哪个变量。</p><h2 id="kotlin的幕后字段"><a href="#kotlin的幕后字段" class="headerlink" title="kotlin的幕后字段"></a>kotlin的幕后字段</h2><p>Kotlin 中的类不能有字段， 然而我们在有时在自定义访问器时，也就是get和set方法时，需要又一个幕后字段，这个字段是kotlin提供的，field,我们可以直接使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var counter = 0 // 注意:这个初始器直接为幕后字段赋值 set(value) &#123;</div><div class="line">if (value &gt;= 0) field = value &#125;</div><div class="line"></div><div class="line"></div><div class="line">val nameHash:Int = 3</div><div class="line">        get() &#123;</div><div class="line">            field = 5</div><div class="line">            return 10</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>有可能我们需要临时缓存变量的值，因为可能其变量的值可能和返回的值不一致，所以一旦我们需要知道变量的值，我们便可以通过幕后字段来访问。</p><h2 id="kotlin的幕后属性"><a href="#kotlin的幕后属性" class="headerlink" title="kotlin的幕后属性"></a>kotlin的幕后属性</h2><p>幕后属性主要用于外部只能读，内部可以读写的需求下出现的。例如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val counter get() = _counter</div><div class="line">private var _counter = 0</div></pre></td></tr></table></figure></p><p>这个_counter就是counter的幕后属性，外部只能访问counter，不能访问_counter，而counter的值又是_counter来指定的。</p><h2 id="kotlin的扩展"><a href="#kotlin的扩展" class="headerlink" title="kotlin的扩展"></a>kotlin的扩展</h2><p>在kotlin中，if else的三目运算符如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(a) x else y</div></pre></td></tr></table></figure></p><p>而我们也能通过扩展函数来扩展boolean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inline fun &lt;T&gt; Boolean.yes(action: () -&gt; T): Boolean &#123;</div><div class="line">    if (this) action()</div><div class="line">    return this</div><div class="line">&#125;</div><div class="line"></div><div class="line">inline fun &lt;T&gt; Boolean.no(action: () -&gt; T): Boolean &#123;</div><div class="line">    if (!this) action()</div><div class="line">    return this</div></pre></td></tr></table></figure></p><p>这样，我们在kt文件中，只要引入相应的类，定义在文件内，而非class下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import com.kuaikan.community.extend.yes</div></pre></td></tr></table></figure></p><p>扩展函数是静态解析的，所以不能够进行重载，这就意味着我们，我们不能重载类原有的方法，比如说collection的add方法等..<br>对于扩展函数还有一个非常好用的东西，被扩展的类型可以为空，被称为可空接收者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fun Any?.toString(): String &#123;</div><div class="line">if (this == null) return &quot;null&quot;</div><div class="line">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数</div><div class="line">return toString()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="kotlin的扩展属性"><a href="#kotlin的扩展属性" class="headerlink" title="kotlin的扩展属性"></a>kotlin的扩展属性</h2><p>既然kotlin支持扩展函数，当然也支持扩展属性了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex: Int</div><div class="line">   get() = size - 1</div></pre></td></tr></table></figure></p><p>这样就给了List的一个属性lastIndex</p><h2 id="kotlin的范型"><a href="#kotlin的范型" class="headerlink" title="kotlin的范型"></a>kotlin的范型</h2><p>关于out和in这两个关键字，out是用来输出的，也就是生产者，所以只能作为返回类型，相当于java中的extends，用来界定类型上限；in是用来输入的，所以只能作为消费类型，in类似于java中的super，用来界定类型下限</p><h2 id="kotlin的单例"><a href="#kotlin的单例" class="headerlink" title="kotlin的单例"></a>kotlin的单例</h2><p>在kotlin中，声明单例变得非常简单，只需要一个关键字object用来修饰对象，就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句右边，对象的初始化是线程安全的。如果需要引用该对象，我们只需要通过其名称来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">object DataProviderManager &#123;</div><div class="line">fun registerDataProvider(provider: DataProvider) &#123;</div><div class="line">// ......</div><div class="line">&#125;</div><div class="line">val allDataProviders: Collection&lt;DataProvider&gt; get() = // ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">//调用</div><div class="line">DataProviderManager.registerDataProvider(......)</div></pre></td></tr></table></figure></p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>类内部的伴生对象的声明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class MyClass &#123; </div><div class="line">    companion object &#123; &#125;</div><div class="line">&#125;</div><div class="line">val x = MyClass.Companion</div></pre></td></tr></table></figure></p><p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interface Factory&lt;T&gt; &#123; fun create(): T</div><div class="line">&#125;</div><div class="line">class MyClass &#123;</div><div class="line">companion object : Factory&lt;MyClass&gt; &#123;</div><div class="line">override fun create(): MyClass = MyClass() &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果我们想将伴生对象的成员生成为真正的静态方法和字段，我们我们可以使用@JvmStatic注解</p><h2 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h2><p>对象表达式和对象声明之间有一个重要的语义差别:</p><ul><li>对象表达式是在使用他们的地方立即执行(及初始化)的;</li><li>对象声明是在第一次被访问到时延迟初始化的;</li><li>伴生对象的初始化是在相应的类被加载(解析)时，与 Java 静态初始化器的语义相匹配。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;todo标注&quot;&gt;&lt;a href=&quot;#todo标注&quot; class=&quot;headerlink&quot; title=&quot;todo标注&quot;&gt;&lt;/a&gt;todo标注&lt;/h2&gt;&lt;p&gt;在java中，使用todo标识并不会出现什么问题，在kotlin中，一旦我们实现了接口或者抽象类，那么我们自
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(2)</title>
    <link href="https://xjlhhz.com/2018/04/11/20180411Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/04/11/20180411Kotlin入门记录/</id>
    <published>2018-04-11T05:14:00.000Z</published>
    <updated>2018-04-11T14:35:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>kotlin中当含有非空的构造函数得继承，有以下这几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class MemberCenterAdapter(context: Context?, mixFindInfoList: ArrayList&lt;MixFindInfo&gt;?) : TopicTabListAdapter(context, mixFindInfoList)</div></pre></td></tr></table></figure></p><p>相当于子类的构造器声明就放在了class的定义上，然后会对应父类相应的构造器。还有另外一种实现方式，主要用于多个构造器的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor(context: Context?, mixFindInfoList: ArrayList&lt;MixFindInfo&gt;?): super(context, mixFindInfoList)</div></pre></td></tr></table></figure></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表元素访问"><a href="#列表元素访问" class="headerlink" title="列表元素访问"></a>列表元素访问</h3><p>在kotlin中，推荐我们使用下标的方式来访问元素，就像在访问数组一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private var itemTypeList: ArrayList&lt;Int&gt; = ArrayList()</div><div class="line">itemTypeList[2] = ITEM_TYPE_ACTIVITY</div></pre></td></tr></table></figure></p><h3 id="列表元素遍历"><a href="#列表元素遍历" class="headerlink" title="列表元素遍历"></a>列表元素遍历</h3><p>对于kotlin中的列表遍历，增加了许多遍历方式。最简单的如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//kotlin </div><div class="line">for (i in startIndex..mixFindInfoList!!.size )</div><div class="line">//java</div><div class="line">for(int i = startIndex; i &lt; mixFindInfoList.size(); i++)</div></pre></td></tr></table></figure></p><p>在kotlin中，推荐我们使用until的方式进行遍历，这样，我们处理起来也就像是在处理流一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// a until b表示从a到b进行遍历，并且将遍历的值传递给下游，</div><div class="line">// map将上游传递过来的值进行转化，并传递给下游</div><div class="line">// forEach对转化后的值进行处理</div><div class="line">(startIndex until mixFindInfoList!!.size)</div><div class="line">                .map &#123; mixFindInfoList[it] &#125;</div><div class="line">                .forEach &#123;</div><div class="line">                    itemTypeList.add(it.item_type)</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>之前在java中用惯了三目运算符，看着kotlin的三目运算符挺不习惯的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//java, 如果a为true，则取b，否则取c </div><div class="line">a ? b : c</div><div class="line">//kotlin, 利用if else组成三目运算符，但是不需要括号</div><div class="line">if(a) b else c</div></pre></td></tr></table></figure></p><h2 id="函数中流程语句的返回值"><a href="#函数中流程语句的返回值" class="headerlink" title="函数中流程语句的返回值"></a>函数中流程语句的返回值</h2><p>在kotlin中，如果多个分支语句都返回值，那么我们可以将返回值放在分支语句的外侧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//最原始的版本</div><div class="line">when (position) &#123;</div><div class="line">    0, 2 -&gt; return null</div><div class="line">    1 -&gt; return Utility.getSafely(mixFindInfoList, 0)</div><div class="line">    else -&gt; &#123;</div><div class="line">        return Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)</div><div class="line">            &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>优化后的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">return when (position) &#123;</div><div class="line">    0, 2 -&gt; null</div><div class="line">    1 -&gt; Utility.getSafely(mixFindInfoList, 0)</div><div class="line">    else -&gt; &#123;</div><div class="line">    Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)                &#125;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>这种时候，就能够返回每一个when分支对应的值<br>对于if else语句也能这么使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">return if (activityListExist()) &#123;</div><div class="line">           if (vipBannerExist()) &#123;</div><div class="line">               when (position) &#123;</div><div class="line">                   0, 2 -&gt; null</div><div class="line">                   1 -&gt; Utility.getSafely(mixFindInfoList, 0)</div><div class="line">                   else -&gt; &#123;</div><div class="line">                       Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; else &#123;</div><div class="line">               if (position == 0 || position == 1) &#123;</div><div class="line">                   null</div><div class="line">               &#125; else &#123;</div><div class="line">                   Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 2)</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">           if (position == 0) &#123;</div><div class="line">               null</div><div class="line">           &#125; else &#123;</div><div class="line">               Utility.getSafely&lt;MixFindInfo&gt;(mixFindInfoList, position - 1)</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>这种时候，每一种判断的分支对应一个值，返回命中的分支对应的值</p><h2 id="类型判断和类型转换"><a href="#类型判断和类型转换" class="headerlink" title="类型判断和类型转换"></a>类型判断和类型转换</h2><p>java中类型判断和转化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (holder instance of MemberVipHeaderHolder) &#123;</div><div class="line">    ((MemberVipHeaderHolder)holder).bindData(title, TYPE_VIP_HEADER, isVip, isBtnShow);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>java中利用instance of进行类型判断，然后直接通过(type)instance进行类型强转，将instance转化为type类型的实例。如果instance不是type类型，那么将会抛出类型转化异常。<br>而在kotlin中，可以通过as和is关键字进行类型判断和转化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) &#123;</div><div class="line">        when (getItemViewType(position)) &#123;</div><div class="line">            ITEM_TYPE_ACTIVITY -&gt; &#123;</div><div class="line">                if (holder is MemberAssignViewHolder) &#123;</div><div class="line">                    holder.bindData(activityList)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            ITEM_TYPE_MEMBER_INFO_CARD -&gt; &#123;</div><div class="line">                if (holder is MemberInfoCardViewHolder) &#123;</div><div class="line">                    holder.bindData()</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else -&gt; &#123;</div><div class="line">                holder.itemView.setPadding(0, 0, 0, if (position == itemCount - 1) UIUtil.dp2px(40f) else 0)</div><div class="line">                if (holder is BaseViewHolder) &#123;</div><div class="line">                    holder.holderType = BaseViewHolder.TYPE_MEMBER</div><div class="line">                &#125;</div><div class="line">                super.onBindViewHolder(holder, position)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>利用 a is type 来判断a是否是type类型，如果是type类型的话，那么kotlin将会自动为我们将a转化为type类型，而不需要我们再手动的利用as进行类型转化。如果kotlin直接利用as进行类型转化的话，如果类型不一致或者a为null时，也会抛出异常，但是kotlin提供了类型不一致时的安全转化，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val x: String ?= y as? String</div></pre></td></tr></table></figure></p><p>上面的例子中，as?是一个安全转化符，如果失败，将会返回null，而不会直接进行类型转化。</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>在java中，需要升级到java8才支持lambda表达，而kotlin天生支持lambda表达式，lambda表达式的完成语法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val sum = &#123; x: Int, y: Int -&gt; x + y &#125;</div></pre></td></tr></table></figure></p><p>上面的例子定义了一个函数，求得sum = x + y,lambda表达式总是括在大括号中，完整的参数声明和表达式都放在大括号内，函数体在-&gt;之后，-&gt;之前都是参数，并且可能有类型标注，如果推断出该lambda的返回值类型不是Unit，也就是返回值不为空，那么该lambda主体的最后一个表达式将被视为返回值<br>下面是某一个lambda的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FindExchangeManager.getInstance().loadExchangeData(mContext, findInfo.discoveryModuleId,</div><div class="line">                    holder.adapterPosition, findInfo, FindExchangeManager.ExchangeCallback &#123; data, position, discoveryModuleId -&gt;</div><div class="line">                if (Utility.isEmpty(mContext)) &#123;</div><div class="line">                    return@ExchangeCallback</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                val info = getMixInfoFromPosition(position)</div><div class="line">                if (data != null &amp;&amp; info != null) &#123;</div><div class="line">                    info.topics = data</div><div class="line">                    notifyItemChanged(position)</div><div class="line">                &#125;</div><div class="line">            &#125;)</div></pre></td></tr></table></figure></p><p>如果在lambda表达式中调用return，将会直接return掉整个上层函数，因为lambda表达式只是一个代码块，虽然看起来功能像是函数，不过也不能说在lambda表达式中不能够return，只要给return指定一个标签，就会结束掉标签所指定的代码块，就像上面的例子，这个lambda表达式是在ExchangeCallback中使用的，如果要结束这个lambda，那么只需要在lambda中return代码添加上@ExchangeCallback标签就行，就绘结束掉ExchangeCallback的这个方法。</p><h2 id="ViewHolder中使用kotlin-extension"><a href="#ViewHolder中使用kotlin-extension" class="headerlink" title="ViewHolder中使用kotlin extension"></a>ViewHolder中使用kotlin extension</h2><p>kotlin extension的使用需要先导入相应的xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在上一篇的activity中</div><div class="line">import kotlinx.android.synthetic.main.activity_member_center.*</div><div class="line"></div><div class="line">//在这个viewHolder中</div><div class="line">import kotlinx.android.synthetic.main.listitem_assign.view.*</div></pre></td></tr></table></figure></p><p>对于这个导包操作，需要注意的是，kotlinx.android.synthetic.main是固定前缀，后面的是当前页面的layout文件名称，如果是activity，只需要再在后面添加上.<em>，那就能够在activity中直接以id的形式调用对应的View。如果是在viewHolder中，那么还需要添加上.view,在添加.</em>才能够使用，而且在viewHolder中，需要以其itemView为持有者来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">init &#123;</div><div class="line">        context = itemView.context</div><div class="line">        itemView.btn_get_gift.setOnClickListener(this)</div><div class="line">        itemView.btn_not_gift.setOnClickListener(this)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>如上所示，利用itemView来持有其中的view的id，并直接调用。<br>这个init块，通常都是来做类的初始化的，在构造器执行完之后，会调用这个init块，我们如果有什么需要做初始化的，只需要放在这个init块中</p><h2 id="String-转其他类型"><a href="#String-转其他类型" class="headerlink" title="String 转其他类型"></a>String 转其他类型</h2><p>java中String转long类型的话，需要调用Long.paras(string)进行转化，如果string不是相应的的类型，那么将会抛出异常。而在kotlin中也有这个方法，不过还新增了几个转化的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//如果string不是一个合法的类型，那么将会抛出异常NumberFormatException</div><div class="line">string.toLong()</div><div class="line"></div><div class="line">//如果string不是一个合法的类型，那么将会返回null</div><div class="line">string.toLongOrNull()</div></pre></td></tr></table></figure></p><h2 id="结合rxjava"><a href="#结合rxjava" class="headerlink" title="结合rxjava"></a>结合rxjava</h2><p>kotlin中有专门的rx-kotlin库，刚开始并没有引入这个库，所以尝试着还是使用rxjava<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable.timer(getDelayTime(), TimeUnit.MILLISECONDS)</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(&#123;</div><div class="line">                    getGrabResult(activityId, thirdId)</div><div class="line">                &#125;)</div></pre></td></tr></table></figure></p><p>还是一样的用法，不过好的一点是可以使用lambda表达式了，subscribe({})中间的花括号就是lambda表达式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;kotlin中当含有非空的构造函数得继承，有以下这几种方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin入门学习记录(1)</title>
    <link href="https://xjlhhz.com/2018/04/09/20180409Kotlin%E5%85%A5%E9%97%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://xjlhhz.com/2018/04/09/20180409Kotlin入门记录/</id>
    <published>2018-04-09T05:14:00.000Z</published>
    <updated>2018-04-11T14:35:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h1><p>随着google将kotlin捧为官方语言，众多的app从java开始迁移到kotlin的大军中，我也想用kotlin开发android，虽然团队中的其他人并没有这个想法，我还是想试试，所以从今天起，开始学习kotlin。</p><h2 id="我的kotlin学习"><a href="#我的kotlin学习" class="headerlink" title="我的kotlin学习"></a>我的kotlin学习</h2><p>我用了很少的时间看了kotlin的基本语法，存粹的做语法笔记似乎对我来说并没有什么用途，所以我打算通过我日常写的项目中的java文件，将其一步一步转为kotlin，并且记录一些未知的点，因为只有来自于实践的学习才能更深入，记得更久</p><h2 id="将一个activity的java文件转为kotlin文件"><a href="#将一个activity的java文件转为kotlin文件" class="headerlink" title="将一个activity的java文件转为kotlin文件"></a>将一个activity的java文件转为kotlin文件</h2><h3 id="最简单的转化方式"><a href="#最简单的转化方式" class="headerlink" title="最简单的转化方式"></a>最简单的转化方式</h3><p>android stutdio支持一键转化的方式，通过快捷键ctrl +alt + shift + k将整个java文件转化为kt文件，不过可能需要自己解决一些代码不一致的冲突，而且有些时候转化后的代码和我们直接写的代码还是有差别的。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="kotlin库引入"><a href="#kotlin库引入" class="headerlink" title="kotlin库引入"></a>kotlin库引入</h4><p>android studio3.0默认支持kotlin，虽然是默认支持kotlin，但也是需要增加一些配置，不过这个as已经给我们做好了智能提示和自动添加的功能。在我们第一次创建出kt文件的时候，将会有一个kotlin的配置提示，我们只需要点击configure，然后选择全局配置，那么as将会在gradle中添加上kotlin的依赖<br><img src="http://onu21exz8.bkt.clouddn.com/%E9%85%8D%E7%BD%AEkotlin.jpeg" alt=""><br>gradle文件如下所示:<br><img src="http://onu21exz8.bkt.clouddn.com/kotlin%E7%9A%84gradle%E4%BF%AE%E6%94%B9.jpeg" alt=""><br>这样我们就使用kotlin的代码库了。</p><h4 id="kotlin-extension库引入"><a href="#kotlin-extension库引入" class="headerlink" title="kotlin extension库引入"></a>kotlin extension库引入</h4><p>之前项目中用的是view的绑定库是ButterKnife，就个人而言，还是觉得挺好用的，毕竟绑定View的代码都能自动生成，不过如果在kt文件中，不能直接引入这个库，需要重新引入kotlin中的ButterKnife库<a href="https://github.com/JakeWharton/kotterknife，不过我们可以不用这个库了，因为kotlin给我们提供了一套更为简便的库，我们只需要在gradle中引入kotlin-extension，并且在kt文件中import相对应的xml，就能直接通过id的方式引用view。" target="_blank" rel="external">https://github.com/JakeWharton/kotterknife，不过我们可以不用这个库了，因为kotlin给我们提供了一套更为简便的库，我们只需要在gradle中引入kotlin-extension，并且在kt文件中import相对应的xml，就能直接通过id的方式引用view。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在kt文件中</div><div class="line">import kotlinx.android.synthetic.main.activity_member_center.*</div><div class="line"></div><div class="line">//在gradle文件中</div><div class="line">apply plugin: &apos;kotlin-android-extensions&apos;</div></pre></td></tr></table></figure></p><p>比如说我们在xml中有这样一个View：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;android.support.v7.widget.RecyclerView</div><div class="line">       android:id=&quot;@+id/memberRv&quot;</div><div class="line">       android:layout_width=&quot;match_parent&quot;</div><div class="line">       android:layout_height=&quot;match_parent&quot;</div><div class="line">       android:layout_below=&quot;@+id/member_center_tool_bar&quot;</div><div class="line">       android:layout_centerHorizontal=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure></p><p>这样我们在kt文件中，可以像下面的方式这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private fun initRv() &#123;</div><div class="line">        adapter = MemberInfoAdapter(this, null)</div><div class="line">        memberRv.layoutManager = LinearLayoutManager(this)</div><div class="line">        memberRv.itemAnimator?.changeDuration = 0</div><div class="line">        memberRv.adapter = adapter</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这个memberRv就是RecyclerView在xml中指定的id。</p><h3 id="一些常用用法"><a href="#一些常用用法" class="headerlink" title="一些常用用法"></a>一些常用用法</h3><h4 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h4><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>在kotlin中，声明所有变量都需要3个关键字修饰，var、val和const。在kotlin中是没有final修饰符的，final修饰符在kotlin中其实就相当于val</p><ul><li>var:主要是用来修饰可变变量的。</li><li><p>val：主要是用来修饰不可变变量的，其实也不能说是不可变，更好的称呼是叫做只读变量，val在修饰变量的时候可以不初始化，但是它不能被赋值，在java中，用final修饰的变量必须要初始化，否则编译不能通过。举个val修饰不初始化的例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class a &#123;</div><div class="line">var c = 1;</div><div class="line">val b: String</div><div class="line">fun getB(): String &#123;</div><div class="line">    return c &gt; 3 ? &quot;haha&quot; : &quot;xixi&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun add() &#123;</div><div class="line">    c++</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>const:其实const就和java中的static final一致了，不能放在局部方法中，在编译期间必须确定变量值。</p><h5 id="静态变量及静态方法"><a href="#静态变量及静态方法" class="headerlink" title="静态变量及静态方法"></a>静态变量及静态方法</h5><p>在java中，静态属性和静态方法只需要一个static属性就能搞定了，但是在kotlin，它有一个单独的块来标识静态块的初始化，companion object:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">companion object &#123;</div><div class="line">        val intentFrom: String = &quot;intent_extra&quot;</div><div class="line">        fun startMemberCenterActivity(context: Context,                 launchMemberCenter: LaunchMemberCenter) &#123;</div><div class="line">            var intent = Intent(context, TestAc::class.java)</div><div class="line">            intent.putExtra(intentFrom, launchMemberCenter)</div><div class="line">            if (context is Activity) &#123;</div><div class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</div><div class="line">            &#125;</div><div class="line">            context.startActivity(intent)</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li></ul><p>这个代码块有几个需要注意的点，</p><ul><li>在kt定义Intent中，class的指定需要已类名::class.java的方式指定，否则在log中会提示找不到activity</li><li>在这个静态块中，定义的变量和方法都是静态的</li><li>在外部如果需要访问这个块的方法，如果是kotlin文件访问，可以直接通过类名.的方式调用，如果是java文件访问，需要通过类名.companion.的方式调用:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//在java文件中调用</div><div class="line">public void start() &#123;</div><div class="line">       TestAc.Companion.startMemberCenterActivity(context, this);</div><div class="line">   &#125;</div><div class="line">//在kt文件中调用</div><div class="line">public void start() &#123;</div><div class="line">       TestAc.startMemberCenterActivity(context, this);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li></ul><h5 id="kotlin的空指针安全"><a href="#kotlin的空指针安全" class="headerlink" title="kotlin的空指针安全"></a>kotlin的空指针安全</h5><p>在变量定义时，我们可以通过kotlin特有的方式来标识变量是否可空：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private var adapter: MemberInfoAdapter? = null</div></pre></td></tr></table></figure></p><p>只需要的变量类型后面添加?，就表示这个变量是可以为null的，如果不添加，默认这个变量不能为null。一旦我们添加了?，在后续的代码中，如果有引用到这个变量的地方，如果没有做判空处理将会编译不过，这个判空处理还是挺方便的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">override fun refreshDiscoveryList(mixFindInfoList: MutableList&lt;MixFindInfo&gt;?) &#123;</div><div class="line">       adapter?.notifyMixFindInfoChange(mixFindInfoList)</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>Equality check should be used instead of elvis for nullable boolean check<br>在调用时，如果adaper为空了，将不会执行后续的操作。<br>今天遇到了一个符号:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var xie = a ?: &quot;&quot;</div></pre></td></tr></table></figure></p><p>这个?:是kotlin的elvis用法，属于两目运算符，就是简单的if、else缩写，<br>当a不为null，取a的值，当a为null，取””</p><h4 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h4><p>kotlin接口和java接口的使用区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class TestAc : BaseMvpActivity&lt;MemberCenterPresent&gt;(), MemberCenterPresent.MemberInfoChange,</div><div class="line">        KKAccountManager.KKAccountChangeListener, View.OnClickListener &#123;</div></pre></td></tr></table></figure></p><p>其中BaseMvpActivity继承，而其他三个都是接口继承。</p><ul><li>java接口需要用implements关键字实现，而kotlin实现的方式和继承一样</li><li><p>java接口能够直接通过匿名内部类创建出来，而kotlin也需要先将接口对象创建出来</p><h4 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h4><p>在kotlin中，用when表达式将将java中的switch替换掉了。<br>最简单的形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">override fun onClick(v: View?) &#123;</div><div class="line">      when (v?.id) &#123;</div><div class="line">          R.id.icBack -&gt; finish()</div><div class="line">          R.id.btnOpenLayout -&gt; btnOpenLayoutClick()</div><div class="line">          else -&gt; &#123;</div><div class="line">          </div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>而且，when里面的条件判断可以加入比较复杂的判断，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> when (x) &#123;</div><div class="line">    in 1..10 -&gt; print(&quot;x is in the range&quot;)</div><div class="line">    in validNumbers -&gt; print(&quot;x is valid&quot;)</div><div class="line">    !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</div><div class="line">    else -&gt; print(&quot;none of the above&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kotlin&quot;&gt;&lt;a href=&quot;#kotlin&quot; class=&quot;headerlink&quot; title=&quot;kotlin&quot;&gt;&lt;/a&gt;kotlin&lt;/h1&gt;&lt;p&gt;随着google将kotlin捧为官方语言，众多的app从java开始迁移到kotlin的大军中，我也想用k
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BlockCanary解析</title>
    <link href="https://xjlhhz.com/2018/02/11/0211BlockCanary%E8%A7%A3%E6%9E%90/"/>
    <id>https://xjlhhz.com/2018/02/11/0211BlockCanary解析/</id>
    <published>2018-02-11T05:14:00.000Z</published>
    <updated>2018-11-21T02:27:56.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blockCanary"><a href="#blockCanary" class="headerlink" title="blockCanary"></a>blockCanary</h1><p>对于android里面的性能优化，最主要的问题就是UI线程的阻塞导致的，对于如何准确的计算UI的绘制所耗费的时间，是非常有必要的，blockCanary是基于这个需求出现的，同样的，也是基于LeakCanary，和LeakCanary有着显示页面和堆栈信息。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先在gradle引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implementation &apos;com.github.markzhai:blockcanary-android:1.5.0&apos;</div></pre></td></tr></table></figure></p><p>然后Application里面进行初始化和start<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BlockCanary.install(this, new BlockCanaryContext()).start();</div></pre></td></tr></table></figure></p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>其中BlockCanaryContext表示的就是我们监测的某些参数,包括卡顿的阈值、输出文件的路径等等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//默认卡顿阈值为1000ms</div><div class="line">public int provideBlockThreshold() &#123;</div><div class="line">        return 1000;</div><div class="line">    &#125;</div><div class="line">//输出的log</div><div class="line"> public String providePath() &#123;</div><div class="line">        return &quot;/blockcanary/&quot;;</div><div class="line">    &#125;</div><div class="line">//支持文件上传</div><div class="line">public void upload(File zippedFile) &#123;</div><div class="line">        throw new UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">//可以在卡顿提供自定义操作</div><div class="line">@Override</div><div class="line">    public void onBlock(Context context, BlockInfo blockInfo) &#123;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>其中，init只是创建出BlockCanary实例。主要是start方法的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">  * Start monitoring.</div><div class="line">  */</div><div class="line"> public void start() &#123;</div><div class="line">     if (!mMonitorStarted) &#123;</div><div class="line">         mMonitorStarted = true;</div><div class="line">         Looper.getMainLooper().setMessageLogging(mBlockCanaryCore.monitor);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>其实就是给主线程的Looper设置一个monitor。<br>我们可以先看看主线程的looper实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">    ...</div><div class="line">    for (;;) &#123;</div><div class="line">        ...</div><div class="line">        // This must be in a local variable, in case a UI event sets the logger</div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                    msg.callback + &quot;: &quot; + msg.what);</div><div class="line">        &#125;</div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在上面的loop循环的代码中，msg.target.dispatchMessage就是我们UI线程收到每一个消息需要执行的操作，都在其内部执行。<br>系统也在其执行的前后都会执行logging类的print的方法，这个方法是我们可以自定义的。所以只要我们在运行的前后都添加一个时间戳，用运行后的时间减去运行前的时间，一旦这个时间超过了我们设定的阈值，那么就可以说这个操作卡顿，阻塞了UI线程，最后通过dump出此时的各种信息，来分析各种性能瓶颈。<br>那么接下来可以看看这个monitor的println方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void println(String x) &#123;</div><div class="line">        //如果当前是在调试中，那么直接返回，不做处理</div><div class="line">        if (mStopWhenDebugging &amp;&amp; Debug.isDebuggerConnected()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mPrintingStarted) &#123;</div><div class="line">            //执行操作前</div><div class="line">            mStartTimestamp = System.currentTimeMillis();</div><div class="line">            mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();</div><div class="line">            mPrintingStarted = true;</div><div class="line">            startDump();</div><div class="line">        &#125; else &#123;</div><div class="line">            //执行操作后</div><div class="line">            final long endTime = System.currentTimeMillis();</div><div class="line">            mPrintingStarted = false;</div><div class="line">            //是否卡顿</div><div class="line">            if (isBlock(endTime)) &#123;</div><div class="line">                notifyBlockEvent(endTime);</div><div class="line">            &#125;</div><div class="line">            stopDump();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>在ui操作执行前，将会记录当前的时间戳，同时会startDump。<br>在ui操作执行后，将会计算当前是否卡顿了，如果卡顿了，将会回调到onBlock的onBlock方法。同时将会停止dump。<br>为什么操作之前就开启了startDump，而操作执行之后就stopDump呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private void startDump() &#123;</div><div class="line">        if (null != BlockCanaryInternals.getInstance().stackSampler) &#123;</div><div class="line">            BlockCanaryInternals.getInstance().stackSampler.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (null != BlockCanaryInternals.getInstance().cpuSampler) &#123;</div><div class="line">            BlockCanaryInternals.getInstance().cpuSampler.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void start() &#123;</div><div class="line">        if (mShouldSample.get()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        mShouldSample.set(true);</div><div class="line"></div><div class="line">        HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);</div><div class="line">        HandlerThreadFactory.getTimerThreadHandler().postDelayed(mRunnable,</div><div class="line">                BlockCanaryInternals.getInstance().getSampleDelay());</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>其实startDump的时候并没有马上start，而是会postDelay一个runnable，这个runnable就是执行dump的真正的操作，delay的时间就是我们设置的阈值的0.8<br>也就是，一旦我们的stop在设置的延迟时间之前执行，就不会真正的执行dump操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void stop() &#123;</div><div class="line">       if (!mShouldSample.get()) &#123;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       mShouldSample.set(false);</div><div class="line">       HandlerThreadFactory.getTimerThreadHandler().removeCallbacks(mRunnable);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>只有当stop操作在设置的延迟时间之后执行，才会执行dump操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private Runnable mRunnable = new Runnable() &#123;</div><div class="line">       @Override</div><div class="line">       public void run() &#123;</div><div class="line">           doSample();</div><div class="line"></div><div class="line">           if (mShouldSample.get()) &#123;</div><div class="line">               HandlerThreadFactory.getTimerThreadHandler()</div><div class="line">                       .postDelayed(mRunnable, mSampleInterval);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure></p><p>这个doSameple分别会dump出stack信息和cpu信息。<br>cpu:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">          cpuReader = new BufferedReader(new InputStreamReader(</div><div class="line">                  new FileInputStream(&quot;/proc/stat&quot;)), BUFFER_SIZE);</div><div class="line">          String cpuRate = cpuReader.readLine();</div><div class="line">          if (cpuRate == null) &#123;</div><div class="line">              cpuRate = &quot;&quot;;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (mPid == 0) &#123;</div><div class="line">              mPid = android.os.Process.myPid();</div><div class="line">          &#125;</div><div class="line">          pidReader = new BufferedReader(new InputStreamReader(</div><div class="line">                  new FileInputStream(&quot;/proc/&quot; + mPid + &quot;/stat&quot;)), BUFFER_SIZE);</div><div class="line">          String pidCpuRate = pidReader.readLine();</div><div class="line">          if (pidCpuRate == null) &#123;</div><div class="line">              pidCpuRate = &quot;&quot;;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          parse(cpuRate, pidCpuRate);</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><p>stack:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">protected void doSample() &#123;</div><div class="line">       StringBuilder stringBuilder = new StringBuilder();</div><div class="line"></div><div class="line">       for (StackTraceElement stackTraceElement : mCurrentThread.getStackTrace()) &#123;</div><div class="line">           stringBuilder</div><div class="line">                   .append(stackTraceElement.toString())</div><div class="line">                   .append(BlockInfo.SEPARATOR);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       synchronized (sStackMap) &#123;</div><div class="line">           if (sStackMap.size() == mMaxEntryCount &amp;&amp; mMaxEntryCount &gt; 0) &#123;</div><div class="line">               sStackMap.remove(sStackMap.keySet().iterator().next());</div><div class="line">           &#125;</div><div class="line">           sStackMap.put(System.currentTimeMillis(), stringBuilder.toString());</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p><p>这样，整个blockCanary的执行过程就完毕了。</p><h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><p>当卡顿时间大于一定值之后，将会造成ANR，那么Android系统的ANR是如何检测出来的呢？其实就是通过Watchdog来实现的，这个Watchdog是一个线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class Watchdog extends Thread &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们主要看一下其中的run方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void run() &#123;</div><div class="line">       boolean waitedHalf = false;</div><div class="line">       while (true) &#123;</div><div class="line">           final ArrayList&lt;HandlerChecker&gt; blockedCheckers;</div><div class="line">           final String subject;</div><div class="line">           final boolean allowRestart;</div><div class="line">           int debuggerWasConnected = 0;</div><div class="line">           synchronized (this) &#123;</div><div class="line">               long timeout = CHECK_INTERVAL;</div><div class="line">               // Make sure we (re)spin the checkers that have become idle within</div><div class="line">               // this wait-and-check interval</div><div class="line">               for (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123;</div><div class="line">                   HandlerChecker hc = mHandlerCheckers.get(i);</div><div class="line">                   hc.scheduleCheckLocked();</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               if (debuggerWasConnected &gt; 0) &#123;</div><div class="line">                   debuggerWasConnected--;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               // NOTE: We use uptimeMillis() here because we do not want to increment the time we</div><div class="line">               // wait while asleep. If the device is asleep then the thing that we are waiting</div><div class="line">               // to timeout on is asleep as well and won&apos;t have a chance to run, causing a false</div><div class="line">               // positive on when to kill things.</div><div class="line">               long start = SystemClock.uptimeMillis();</div><div class="line">               while (timeout &gt; 0) &#123;</div><div class="line">                   if (Debug.isDebuggerConnected()) &#123;</div><div class="line">                       debuggerWasConnected = 2;</div><div class="line">                   &#125;</div><div class="line">                   try &#123;</div><div class="line">                       wait(timeout);</div><div class="line">                   &#125; catch (InterruptedException e) &#123;</div><div class="line">                       Log.wtf(TAG, e);</div><div class="line">                   &#125;</div><div class="line">                   if (Debug.isDebuggerConnected()) &#123;</div><div class="line">                       debuggerWasConnected = 2;</div><div class="line">                   &#125;</div><div class="line">                   timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</div><div class="line">               &#125;</div></pre></td></tr></table></figure></p><p>在这个run方法中，会开启一个死循环,主要用于持续检测ANR<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (true) &#123;</div><div class="line"></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>通过wait，设置每一次休眠时间，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">long start = SystemClock.uptimeMillis();</div><div class="line">               while (timeout &gt; 0) &#123;</div><div class="line">                   if (Debug.isDebuggerConnected()) &#123;</div><div class="line">                       debuggerWasConnected = 2;</div><div class="line">                   &#125;</div><div class="line">                   try &#123;</div><div class="line">                       wait(timeout);</div><div class="line">                   &#125; catch (InterruptedException e) &#123;</div><div class="line">                       Log.wtf(TAG, e);</div><div class="line">                   &#125;</div><div class="line">                   if (Debug.isDebuggerConnected()) &#123;</div><div class="line">                       debuggerWasConnected = 2;</div><div class="line">                   &#125;</div><div class="line">                   timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</div><div class="line">               &#125;</div></pre></td></tr></table></figure></p><p>当timeout计算完毕之后，会尝试获取当前各个的线程的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final int waitState = evaluateCheckerCompletionLocked();</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private int evaluateCheckerCompletionLocked() &#123;</div><div class="line">     int state = COMPLETED;</div><div class="line">     for (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123;</div><div class="line">         HandlerChecker hc = mHandlerCheckers.get(i);</div><div class="line">         state = Math.max(state, hc.getCompletionStateLocked());</div><div class="line">     &#125;</div><div class="line">     return state;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public int getCompletionStateLocked() &#123;</div><div class="line">            if (mCompleted) &#123;</div><div class="line">                return COMPLETED;</div><div class="line">            &#125; else &#123;</div><div class="line">                long latency = SystemClock.uptimeMillis() - mStartTime;</div><div class="line">                if (latency &lt; mWaitMax/2) &#123;</div><div class="line">                    return WAITING;</div><div class="line">                &#125; else if (latency &lt; mWaitMax) &#123;</div><div class="line">                    return WAITED_HALF;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return OVERDUE;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>一旦有线程等待时间超过了最大等待时间，则表示当前已经有ANR。需要dump此时的堆栈信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (waitState == COMPLETED) &#123;</div><div class="line">                    // The monitors have returned; reset</div><div class="line">                    waitedHalf = false;</div><div class="line">                    continue;</div><div class="line">                &#125; else if (waitState == WAITING) &#123;</div><div class="line">                    // still waiting but within their configured intervals; back off and recheck</div><div class="line">                    continue;</div><div class="line">                &#125; else if (waitState == WAITED_HALF) &#123;</div><div class="line">                    if (!waitedHalf) &#123;</div><div class="line">                        // We&apos;ve waited half the deadlock-detection interval.  Pull a stack</div><div class="line">                        // trace and wait another half.</div><div class="line">                        ArrayList&lt;Integer&gt; pids = new ArrayList&lt;Integer&gt;();</div><div class="line">                        pids.add(Process.myPid());</div><div class="line">                        ActivityManagerService.dumpStackTraces(true, pids, null, null,</div><div class="line">                            getInterestingNativePids());</div><div class="line">                        waitedHalf = true;</div><div class="line">                    &#125;</div><div class="line">                    continue;</div><div class="line">                &#125;</div></pre></td></tr></table></figure></p><p>此外，还有一个第三方库，ANRWatchDog，也是用来检测Anr的，其实原理更加简单，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">        setName(&quot;|ANR-WatchDog|&quot;);</div><div class="line"></div><div class="line">        int lastTick;</div><div class="line">        int lastIgnored = -1;</div><div class="line">        while (!isInterrupted()) &#123;</div><div class="line">            lastTick = _tick;</div><div class="line">            _uiHandler.post(_ticker);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(_timeoutInterval);</div><div class="line">            &#125;</div><div class="line">            catch (InterruptedException e) &#123;</div><div class="line">                _interruptionListener.onInterrupted(e);</div><div class="line">                return ;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // If the main thread has not handled _ticker, it is blocked. ANR.</div><div class="line">            if (_tick == lastTick) &#123;</div><div class="line">                if (!_ignoreDebugger &amp;&amp; Debug.isDebuggerConnected()) &#123;</div><div class="line">                    if (_tick != lastIgnored)</div><div class="line">                        Log.w(&quot;ANRWatchdog&quot;, &quot;An ANR was detected but ignored because the debugger is connected (you can prevent this with setIgnoreDebugger(true))&quot;);</div><div class="line">                    lastIgnored = _tick;</div><div class="line">                    continue ;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ANRError error;</div><div class="line">                if (_namePrefix != null)</div><div class="line">                    error = ANRError.New(_namePrefix, _logThreadsWithoutStackTrace);</div><div class="line">                else</div><div class="line">                    error = ANRError.NewMainOnly();</div><div class="line">                _anrListener.onAppNotResponding(error);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>它会在线程中，利用uiHanlder抛出一个计数器，然后wait指定时间，一旦等待时间到达，那么它会检查计数的值是否发生改变，如果没有发生改变，表示uiHandler的计算方法并没有执行到。也就是出现了Anr，此时需要dump堆栈信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;blockCanary&quot;&gt;&lt;a href=&quot;#blockCanary&quot; class=&quot;headerlink&quot; title=&quot;blockCanary&quot;&gt;&lt;/a&gt;blockCanary&lt;/h1&gt;&lt;p&gt;对于android里面的性能优化，最主要的问题就是UI线程的阻塞导致
      
    
    </summary>
    
    
  </entry>
  
</feed>
