<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/xiejl.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/xiejl.github.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/xiejl.github.io/favicon.ico?v=5.1.0" />






<meta name="description" content="#tinker接入过程其实tinker接入对于一些第三方sdk接入来说算是一个比较复杂了。但是照着tinker团队提供的文档去实现，还是一件比较轻松的事情。
gradle修改gradle引入依赖修改通过gradle的方式引入tinker是最简单不过的了。首先通过在项目的根目录的build.gradle中添加依赖。12345buildscript &amp;#123;    dependencies &amp;#1">
<meta property="og:type" content="article">
<meta property="og:title" content="微信tinker接入尝试详解">
<meta property="og:url" content="https://xiejinlong.github.io/xiejl.github.io/2017/09/03/0903微信Tinker尝试/index.html">
<meta property="og:site_name" content="沉迷学习却日渐发福">
<meta property="og:description" content="#tinker接入过程其实tinker接入对于一些第三方sdk接入来说算是一个比较复杂了。但是照着tinker团队提供的文档去实现，还是一件比较轻松的事情。
gradle修改gradle引入依赖修改通过gradle的方式引入tinker是最简单不过的了。首先通过在项目的根目录的build.gradle中添加依赖。12345buildscript &amp;#123;    dependencies &amp;#1">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/dex_total.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/header.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/stringid.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/typeid.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/fileid.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/protoid.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/methodid.jpeg">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/classid.jpeg">
<meta property="og:updated_time" content="2017-09-10T05:39:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="微信tinker接入尝试详解">
<meta name="twitter:description" content="#tinker接入过程其实tinker接入对于一些第三方sdk接入来说算是一个比较复杂了。但是照着tinker团队提供的文档去实现，还是一件比较轻松的事情。
gradle修改gradle引入依赖修改通过gradle的方式引入tinker是最简单不过的了。首先通过在项目的根目录的build.gradle中添加依赖。12345buildscript &amp;#123;    dependencies &amp;#1">
<meta name="twitter:image" content="http://onu21exz8.bkt.clouddn.com/dex_total.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/xiejl.github.io/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiejinlong.github.io/xiejl.github.io/2017/09/03/0903微信Tinker尝试/"/>





  <title> 微信tinker接入尝试详解 | 沉迷学习却日渐发福 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/xiejl.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沉迷学习却日渐发福</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我会笑着迎接每一天</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/xiejl.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/xiejl.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/xiejl.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/09/03/0903微信Tinker尝试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="phiCoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沉迷学习却日渐发福">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                微信tinker接入尝试详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T13:14:00+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#tinker接入过程<br>其实tinker接入对于一些第三方sdk接入来说算是一个比较复杂了。但是照着tinker团队提供的文档去实现，还是一件比较轻松的事情。</p>
<h2 id="gradle修改"><a href="#gradle修改" class="headerlink" title="gradle修改"></a>gradle修改</h2><h3 id="gradle引入依赖修改"><a href="#gradle引入依赖修改" class="headerlink" title="gradle引入依赖修改"></a>gradle引入依赖修改</h3><p>通过gradle的方式引入tinker是最简单不过的了。首先通过在项目的根目录的build.gradle中添加依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath (&apos;com.tencent.tinker:tinker-patch-gradle-plugin:1.8.1&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>然后在app下的build.gradle也添加依赖和apply。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    //optional, help to generate the final application </div><div class="line">    provided(&apos;com.tencent.tinker:tinker-android-anno:1.8.1&apos;)</div><div class="line">    //tinker&apos;s main Android lib</div><div class="line">    compile(&apos;com.tencent.tinker:tinker-android-lib:1.8.1&apos;)</div><div class="line">&#125;</div><div class="line">...</div><div class="line">...</div><div class="line">apply plugin: &apos;com.tencent.tinker.patch&apos;</div></pre></td></tr></table></figure><br>这样，就在项目中引入了tinker了。</p>
<h3 id="gradle添加生成patch文件的task任务"><a href="#gradle添加生成patch文件的task任务" class="headerlink" title="gradle添加生成patch文件的task任务"></a>gradle添加生成patch文件的task任务</h3><p>这里直接参照tinker给的example来阅读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div></pre></td><td class="code"><pre><div class="line">//为了保证每一个需要打patch的版本不重复，tinker推荐每次打包生成的sha值都从git上拉取最新的提交。</div><div class="line">def gitSha() &#123;</div><div class="line">    try &#123;</div><div class="line">        String gitRev = &apos;git rev-parse --short HEAD&apos;.execute(null, project.rootDir).text.trim()</div><div class="line">        if (gitRev == null) &#123;</div><div class="line">            throw new GradleException(&quot;can&apos;t get git rev, you should add git to system path or just input test value, such as &apos;testTinkerId&apos;&quot;)</div><div class="line">        &#125;</div><div class="line">        return gitRev</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new GradleException(&quot;can&apos;t get git rev, you should add git to system path or just input test value, such as &apos;testTinkerId&apos;&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	//我们需要打开multiDexEnable开关。</div><div class="line">	multiDexEnabled true</div><div class="line">        buildConfigField &quot;String&quot;, &quot;TINKER_ID&quot;, &quot;\&quot;$&#123;getTinkerIdValue()&#125;\&quot;&quot;</div><div class="line">        buildConfigField &quot;String&quot;, &quot;PLATFORM&quot;,  &quot;\&quot;all\&quot;&quot;</div><div class="line">    &#125;</div><div class="line">   ....</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义生成的apk文件夹，buildDir就是我们项目中的output文件夹。</div><div class="line">def bakPath = file(&quot;$&#123;buildDir&#125;/bakApk/&quot;)</div><div class="line"></div><div class="line">//tinker相关的配置</div><div class="line">ext &#123;</div><div class="line">    //启用tinker</div><div class="line">    tinkerEnabled = true</div><div class="line">    tinkerOldApkPath = &quot;$&#123;bakPath&#125;/app-debug-1018-17-32-47.apk&quot;</div><div class="line">    tinkerApplyMappingPath = &quot;$&#123;bakPath&#125;/app-debug-1018-17-32-47-mapping.txt&quot;</div><div class="line">    tinkerApplyResourcePath = &quot;$&#123;bakPath&#125;/app-debug-1018-17-32-47-R.txt&quot;</div><div class="line">    tinkerBuildFlavorDirectory = &quot;$&#123;bakPath&#125;/app-1018-17-32-47&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">def getOldApkPath() &#123;</div><div class="line">    return hasProperty(&quot;OLD_APK&quot;) ? OLD_APK : ext.tinkerOldApkPath</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getApplyMappingPath() &#123;</div><div class="line">    return hasProperty(&quot;APPLY_MAPPING&quot;) ? APPLY_MAPPING : ext.tinkerApplyMappingPath</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getApplyResourceMappingPath() &#123;</div><div class="line">    return hasProperty(&quot;APPLY_RESOURCE&quot;) ? APPLY_RESOURCE : ext.tinkerApplyResourcePath</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getTinkerIdValue() &#123;</div><div class="line">    return hasProperty(&quot;TINKER_ID&quot;) ? TINKER_ID : gitSha()</div><div class="line">&#125;</div><div class="line"></div><div class="line">def buildWithTinker() &#123;</div><div class="line">    return hasProperty(&quot;TINKER_ENABLE&quot;) ? TINKER_ENABLE : ext.tinkerEnabled</div><div class="line">&#125;</div><div class="line"></div><div class="line">def getTinkerBuildFlavorDirectory() &#123;</div><div class="line">    return ext.tinkerBuildFlavorDirectory</div><div class="line">&#125;</div><div class="line"></div><div class="line">//tinker相关操作</div><div class="line">if (buildWithTinker()) &#123;</div><div class="line">    apply plugin: &apos;com.tencent.tinker.patch&apos;</div><div class="line"></div><div class="line">    tinkerPatch &#123;</div><div class="line">        //指定oldApk地址，这个apk地址将会与新apk做对比生成差异化的dex包</div><div class="line">	oldApk = &quot;/Users/xie/AndroidProject/tinker/tinker-sample-android/app/build/bakApk/app-debug-0522-10-24-41.apk&quot;</div><div class="line">        //是否忽略部分警告</div><div class="line">        ignoreWarning = true</div><div class="line">	//patch文件是否需要添加签名</div><div class="line">        useSign = true</div><div class="line"></div><div class="line">        //是否开启tinker</div><div class="line">        tinkerEnable = buildWithTinker()</div><div class="line"></div><div class="line">        buildConfig &#123;</div><div class="line">            //如果我们利用tinkerpatch生成apk，那么我们最好能够利用old apk的mapping file</div><div class="line">            applyMapping = getApplyMappingPath()</div><div class="line">            applyResourceMapping = getApplyResourceMappingPath()</div><div class="line">	    //获取tinkerId，为了保证效率，并不会对apk进行md5校验，这里会对apk做一个独特的id用于标识。</div><div class="line">            tinkerId = getTinkerIdValue()</div><div class="line">	    //打开这个开关将会降低dex文件的大小。</div><div class="line">            keepDexApply = false</div><div class="line"></div><div class="line">            //当开启了这个开关之后，patch info的文件将会包含所有的diff文件。</div><div class="line">            isProtectedApp = false</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        dex &#123;</div><div class="line">	    //支持的dex文件格式，可以为raw或者jar</div><div class="line">            dexMode = &quot;jar&quot;</div><div class="line">	    //apk中的dex期待的格式</div><div class="line">            pattern = [&quot;classes*.dex&quot;,</div><div class="line">                       &quot;assets/secondary-dex-?.jar&quot;]</div><div class="line">	    //这个非常重要，通过class不会在patch文件中改变，因此他们会从patch的dex文件中移除</div><div class="line">            loader = [</div><div class="line">                      &quot;tinker.sample.android.app.BaseBuildInfo&quot;</div><div class="line">            ]</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lib &#123;</div><div class="line">	    //tinkerpatch支持的lib文件格式</div><div class="line">            pattern = [&quot;lib/*/*.so&quot;]</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        res &#123;</div><div class="line">	    //项目中所有的资源文件，只有指定了之后，才会在新apk中生成</div><div class="line">            pattern = [&quot;res/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]</div><div class="line">            ignoreChange = [&quot;assets/sample_meta.txt&quot;]</div><div class="line">            largeModSize = 100</div><div class="line">        &#125;</div><div class="line">	//我们生成的patch文件为7zip格式</div><div class="line">	sevenZip &#123;</div><div class="line">           zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;String&gt; flavors = new ArrayList&lt;&gt;();</div><div class="line">    project.android.productFlavors.each &#123;flavor -&gt;</div><div class="line">        flavors.add(flavor.name)</div><div class="line">    &#125;</div><div class="line">    //生成的apk文件添加date后缀来标识</div><div class="line">    boolean hasFlavors = flavors.size() &gt; 0</div><div class="line">    def date = new Date().format(&quot;MMdd-HH-mm-ss&quot;)</div><div class="line"></div><div class="line">    android.applicationVariants.all &#123; variant -&gt;</div><div class="line">        def taskName = variant.name</div><div class="line">	//在这里定义了打包任务</div><div class="line">        tasks.all &#123;</div><div class="line">	    //如果打包生成的文件与这个任务名称一致，那么需要做额外的处理</div><div class="line">            if (&quot;assemble$&#123;taskName.capitalize()&#125;&quot;.equalsIgnoreCase(it.name)) &#123;</div><div class="line"></div><div class="line">                it.doLast &#123;</div><div class="line">                    copy &#123;</div><div class="line">                        def fileNamePrefix = &quot;$&#123;project.name&#125;-$&#123;variant.baseName&#125;&quot;</div><div class="line">                        def newFileNamePrefix = hasFlavors ? &quot;$&#123;fileNamePrefix&#125;&quot; : &quot;$&#123;fileNamePrefix&#125;-$&#123;date&#125;&quot;</div><div class="line">			//将生成的文件移动到bakapk下</div><div class="line">                        def destPath = hasFlavors ? file(&quot;$&#123;bakPath&#125;/$&#123;project.name&#125;-$&#123;date&#125;/$&#123;variant.flavorName&#125;&quot;) : bakPath</div><div class="line">                        from variant.outputs.outputFile</div><div class="line">                        into destPath</div><div class="line">                        rename &#123; String fileName -&gt;</div><div class="line">			    //重命名</div><div class="line">                            fileName.replace(&quot;$&#123;fileNamePrefix&#125;.apk&quot;, &quot;$&#123;newFileNamePrefix&#125;.apk&quot;)</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        from &quot;$&#123;buildDir&#125;/outputs/mapping/$&#123;variant.dirName&#125;/mapping.txt&quot;</div><div class="line">                        into destPath</div><div class="line">                        rename &#123; String fileName -&gt;</div><div class="line">                            fileName.replace(&quot;mapping.txt&quot;, &quot;$&#123;newFileNamePrefix&#125;-mapping.txt&quot;)</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        from &quot;$&#123;buildDir&#125;/intermediates/symbols/$&#123;variant.dirName&#125;/R.txt&quot;</div><div class="line">                        into destPath</div><div class="line">                        rename &#123; String fileName -&gt;</div><div class="line">                            fileName.replace(&quot;R.txt&quot;, &quot;$&#123;newFileNamePrefix&#125;-R.txt&quot;)</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //在打包任务执行完成之后，</div><div class="line">    project.afterEvaluate &#123;</div><div class="line">	//如果这个打包包含渠道，那么对于所有渠道生成执行patch更新。</div><div class="line">        if (hasFlavors) &#123;</div><div class="line">	    //对release包进行patch生成</div><div class="line">            task(tinkerPatchAllFlavorRelease) &#123;</div><div class="line">                group = &apos;tinker&apos;</div><div class="line">		//获取oldApk文件</div><div class="line">                def originOldPath = getTinkerBuildFlavorDirectory()</div><div class="line">                for (String flavor : flavors) &#123;</div><div class="line">		    //执行前面定义的tinkerPatch任务</div><div class="line">                    def tinkerTask = tasks.getByName(&quot;tinkerPatch$&#123;flavor.capitalize()&#125;Release&quot;)</div><div class="line">                    dependsOn tinkerTask</div><div class="line">                    def preAssembleTask = tasks.getByName(&quot;process$&#123;flavor.capitalize()&#125;ReleaseManifest&quot;)</div><div class="line">                    preAssembleTask.doFirst &#123;</div><div class="line">                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 15)</div><div class="line">                        project.tinkerPatch.oldApk = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-release.apk&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-release-mapping.txt&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyResourceMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-release-R.txt&quot;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            task(tinkerPatchAllFlavorDebug) &#123;</div><div class="line">                group = &apos;tinker&apos;</div><div class="line">                def originOldPath = getTinkerBuildFlavorDirectory()</div><div class="line">                for (String flavor : flavors) &#123;</div><div class="line">                    def tinkerTask = tasks.getByName(&quot;tinkerPatch$&#123;flavor.capitalize()&#125;Debug&quot;)</div><div class="line">                    dependsOn tinkerTask</div><div class="line">                    def preAssembleTask = tasks.getByName(&quot;process$&#123;flavor.capitalize()&#125;DebugManifest&quot;)</div><div class="line">                    preAssembleTask.doFirst &#123;</div><div class="line">                        String flavorName = preAssembleTask.name.substring(7, 8).toLowerCase() + preAssembleTask.name.substring(8, preAssembleTask.name.length() - 13)</div><div class="line">                        project.tinkerPatch.oldApk = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-debug.apk&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-debug-mapping.txt&quot;</div><div class="line">                        project.tinkerPatch.buildConfig.applyResourceMapping = &quot;$&#123;originOldPath&#125;/$&#123;flavorName&#125;/$&#123;project.name&#125;-$&#123;flavorName&#125;-debug-R.txt&quot;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
<h2 id="Application文件修改"><a href="#Application文件修改" class="headerlink" title="Application文件修改"></a>Application文件修改</h2><p>一旦我们接入了application，那么将会我们application文件将会以另外一种形态存在，DefaultApplicationLike。<br>下面也是官方文档中给的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//以注解的方式生成主次相应的application到DefaultApplicationLike中</div><div class="line">@SuppressWarnings(&quot;unused&quot;)</div><div class="line">@DefaultLifeCycle(application = &quot;tinker.sample.android.app.SampleApplication&quot;,</div><div class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</div><div class="line">                  loadVerifyFlag = false)</div><div class="line">public class SampleApplicationLike extends DefaultApplicationLike &#123;</div><div class="line">    private static final String TAG = &quot;Tinker.SampleApplicationLike&quot;;</div><div class="line"></div><div class="line">    public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag,</div><div class="line">                                 long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123;</div><div class="line">        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * install multiDex before install tinker</div><div class="line">     * so we don&apos;t need to put the tinker lib classes in the main dex</div><div class="line">     *</div><div class="line">     * @param base</div><div class="line">     */</div><div class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class="line">    @Override</div><div class="line">    public void onBaseContextAttached(Context base) &#123;</div><div class="line">        super.onBaseContextAttached(base);</div><div class="line">        //you must install multiDex whatever tinker is installed!</div><div class="line">     </div><div class="line">        MultiDex.install(base);</div><div class="line">				</div><div class="line">        SampleApplicationContext.application = getApplication();</div><div class="line">        SampleApplicationContext.context = getApplication();</div><div class="line"> </div><div class="line">       //对tinkerManager设置相应的ApplicationLike</div><div class="line">       TinkerManager.setTinkerApplicationLike(this);</div><div class="line"></div><div class="line">        TinkerManager.initFastCrashProtect();</div><div class="line">        //开启更新重试，必须在install调用前设置</div><div class="line">        TinkerManager.setUpgradeRetryEnable(true);</div><div class="line"></div><div class="line">        //optional set logIml, or you can use default debug log</div><div class="line">        TinkerInstaller.setLogIml(new MyLogImp());</div><div class="line"></div><div class="line">        //tinkerManager的install必须在multiDex之后执行</div><div class="line">        //初始化tinker</div><div class="line">        TinkerManager.installTinker(this);</div><div class="line">        Tinker tinker = Tinker.with(getApplication());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //给application注册相应的生命周期函数回调。</div><div class="line">    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</div><div class="line">    public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) &#123;</div><div class="line">        getApplication().registerActivityLifecycleCallbacks(callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="执行更新"><a href="#执行更新" class="headerlink" title="执行更新"></a>执行更新</h2><p>对于更新的执行，一旦我们load好了更新包之后，我们需要主动调用更新函数执行更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;);</div></pre></td></tr></table></figure><br>这个7zip文件就是我们指定的patch文件。</p>
<h2 id="tinker修复过程"><a href="#tinker修复过程" class="headerlink" title="tinker修复过程"></a>tinker修复过程</h2><p>首先从Application类的installTinker开始Tinker的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">TinkerManager.installTinker(this);</div><div class="line">====&gt;</div><div class="line"></div><div class="line"> public static void installTinker(ApplicationLike appLike) &#123;</div><div class="line">        if (isInstalled) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;install tinker, but has installed, ignore&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        LoadReporter loadReporter = new SampleLoadReporter(appLike.getApplication());</div><div class="line">        PatchReporter patchReporter = new SamplePatchReporter(appLike.getApplication());</div><div class="line">        PatchListener patchListener = new SamplePatchListener(appLike.getApplication());</div><div class="line">        AbstractPatch upgradePatchProcessor = new UpgradePatch();</div><div class="line"></div><div class="line">        //在这里直接实现install</div><div class="line">        TinkerInstaller.install(appLike,</div><div class="line">            loadReporter, patchReporter, patchListener,</div><div class="line">            SampleResultService.class, upgradePatchProcessor);</div><div class="line"></div><div class="line">        isInstalled = true;</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line">public static Tinker install(ApplicationLike applicationLike, LoadReporter loadReporter, PatchReporter patchReporter,</div><div class="line">                               PatchListener listener, Class&lt;? extends AbstractResultService&gt; resultServiceClass,</div><div class="line">                               AbstractPatch upgradePatchProcessor) &#123;</div><div class="line"></div><div class="line">        Tinker tinker = new Tinker.Builder(applicationLike.getApplication())</div><div class="line">            .tinkerFlags(applicationLike.getTinkerFlags())</div><div class="line">            .loadReport(loadReporter)</div><div class="line">            .listener(listener)</div><div class="line">            .patchReporter(patchReporter)</div><div class="line">            .tinkerLoadVerifyFlag(applicationLike.getTinkerLoadVerifyFlag()).build();</div><div class="line"></div><div class="line">        Tinker.create(tinker);</div><div class="line">        tinker.install(applicationLike.getTinkerResultIntent(), resultServiceClass, upgradePatchProcessor);</div><div class="line">        return tinker;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>首先会通过建造者模式创建出一个tinker实例，然后真正的调用该实例的install方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void install(Intent intentResult, Class&lt;? extends AbstractResultService&gt; serviceClass,</div><div class="line">                        AbstractPatch upgradePatch) &#123;</div><div class="line">        sInstalled = true;</div><div class="line">        //对TinkerPatchService设置更新Patch实例，TinkerPatchService是一个检测到有修复文件时会开启的新Service进程</div><div class="line">        TinkerPatchService.setPatchProcessor(upgradePatch, serviceClass);</div><div class="line">        </div><div class="line">        TinkerLog.i(TAG, &quot;try to install tinker, isEnable: %b, version: %s&quot;, isTinkerEnabled(), ShareConstants.TINKER_VERSION);</div><div class="line"></div><div class="line">        if (!isTinkerEnabled()) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;tinker is disabled&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (intentResult == null) &#123;</div><div class="line">            throw new TinkerRuntimeException(&quot;intentResult must not be null.&quot;);</div><div class="line">        &#125;</div><div class="line">        //tinkerLoadResult会解析tinker的返回值</div><div class="line">        tinkerLoadResult = new TinkerLoadResult();</div><div class="line">        //解析Tiner返回值</div><div class="line">        tinkerLoadResult.parseTinkerResult(getContext(), intentResult);</div><div class="line">        //当更新进程结束之后，调用这个方法解析返回code</div><div class="line">        loadReporter.onLoadResult(patchDirectory, tinkerLoadResult.loadCode, tinkerLoadResult.costTime);</div><div class="line"></div><div class="line">        if (!loaded) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;tinker load fail!&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>或者也可以通过下面的方法进行初始化：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">Tinker tinker = Tinker.with(getApplication());</div><div class="line">=====&gt;</div><div class="line">public static Tinker with(Context context) &#123;</div><div class="line">        if (!sInstalled) &#123;</div><div class="line">            throw new TinkerRuntimeException(&quot;you must install tinker before get tinker sInstance&quot;);</div><div class="line">        &#125;</div><div class="line">        if (sInstance == null) &#123;</div><div class="line">            synchronized (Tinker.class) &#123;</div><div class="line">                if (sInstance == null) &#123;</div><div class="line">                    sInstance = new Builder(context).build();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return sInstance;</div><div class="line">    &#125;</div><div class="line">======&gt;</div><div class="line">public Builder(Context context) &#123;</div><div class="line">            if (context == null) &#123;</div><div class="line">                throw new TinkerRuntimeException(&quot;Context must not be null.&quot;);</div><div class="line">            &#125;</div><div class="line">            this.context = context;</div><div class="line">            this.mainProcess = TinkerServiceInternals.isInMainProcess(context);</div><div class="line">            this.patchProcess = TinkerServiceInternals.isInTinkerPatchServiceProcess(context);</div><div class="line">            this.patchDirectory = SharePatchFileUtil.getPatchDirectory(context);</div><div class="line">            if (this.patchDirectory == null) &#123;</div><div class="line">                TinkerLog.e(TAG, &quot;patchDirectory is null!&quot;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            this.patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory.getAbsolutePath());</div><div class="line">            this.patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory.getAbsolutePath());</div><div class="line">            TinkerLog.w(TAG, &quot;tinker patch directory: %s&quot;, patchDirectory);</div><div class="line">        &#125;</div><div class="line">=====&gt;</div><div class="line">public Tinker build() &#123;</div><div class="line">            if (status == -1) &#123;</div><div class="line">                status = ShareConstants.TINKER_ENABLE_ALL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (loadReporter == null) &#123;</div><div class="line">                loadReporter = new DefaultLoadReporter(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (patchReporter == null) &#123;</div><div class="line">                patchReporter = new DefaultPatchReporter(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (listener == null) &#123;</div><div class="line">                listener = new DefaultPatchListener(context);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (tinkerLoadVerifyFlag == null) &#123;</div><div class="line">                tinkerLoadVerifyFlag = false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return new Tinker(context, status, loadReporter, patchReporter, listener, patchDirectory,</div><div class="line">                patchInfoFile, patchInfoLockFile, mainProcess, patchProcess, tinkerLoadVerifyFlag);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>在初始化完毕之后，就可以在收到修复文件的时候，开启修复进程了。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TinkerInstaller.onReceiveUpgradePatch(KKMHApp.getInstance(), </div><div class="line">    Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;);</div><div class="line"> </div></pre></td></tr></table></figure><br>通过TinkerInstaller的onReceiveUpgradePatch开启更新，必须传入相对应的修复文件的路径。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static void onReceiveUpgradePatch(Context context, String patchLocation) &#123;</div><div class="line">        Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>在这里获取相对应patchListener，并调用其onPatchReceived开始准备更新<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int onPatchReceived(String path) &#123;</div><div class="line">        //检查相应的更新包是否正确</div><div class="line">        int returnCode = patchCheck(path);</div><div class="line">        //如果patch正确，那么开启服务，进行更新，</div><div class="line">        if (returnCode == ShareConstants.ERROR_PATCH_OK) &#123;</div><div class="line">            TinkerPatchService.runPatchService(context, path);</div><div class="line">        &#125; else &#123;</div><div class="line">            Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(new File(path), returnCode);</div><div class="line">        &#125;</div><div class="line">        return returnCode;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>我们来看看tinker如何检测更新包的有效性。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">protected int patchCheck(String path) &#123;</div><div class="line">        Tinker manager = Tinker.with(context);</div><div class="line">        //判断是否允许tinker启动</div><div class="line">        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_DISABLE;</div><div class="line">        &#125;</div><div class="line">        //生成该文件</div><div class="line">        File file = new File(path);</div><div class="line"></div><div class="line">        //判断文件是否存在且合法</div><div class="line">        if (!SharePatchFileUtil.isLegalFile(file)) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_NOTEXIST;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果是PatchService的线程，那么不能发送更新请求</div><div class="line">        if (manager.isPatchProcess()) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_INSERVICE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果这个PatchService正在执行修复操作，那么应该阻塞</div><div class="line">        if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_RUNNING;</div><div class="line">        &#125;</div><div class="line">        //判断是否是diavik虚拟机</div><div class="line">        if (ShareTinkerInternals.isVmJit()) &#123;</div><div class="line">            return ShareConstants.ERROR_PATCH_JIT;</div><div class="line">        &#125;</div><div class="line">        return ShareConstants.ERROR_PATCH_OK;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>假如所有的检查都通过，那么就开启更新服务。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void runPatchService(Context context, String path) &#123;</div><div class="line">        try &#123;</div><div class="line">            Intent intent = new Intent(context, TinkerPatchService.class);</div><div class="line">            intent.putExtra(PATCH_PATH_EXTRA, path);</div><div class="line">            intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());</div><div class="line">            context.startService(intent);</div><div class="line">        &#125; catch (Throwable throwable) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;start patch service fail, exception:&quot; + throwable);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>这个PatchService是一个IntentService，当成功启动之后，我们会调用到它的onHandleIntent执行操作<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">protected void onHandleIntent(Intent intent) &#123;</div><div class="line">        final Context context = getApplicationContext();</div><div class="line">        Tinker tinker = Tinker.with(context);</div><div class="line">        tinker.getPatchReporter().onPatchServiceStart(intent);</div><div class="line"></div><div class="line">        if (intent == null) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;TinkerPatchService received a null intent, ignoring.&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //更新包的path会通过intent传递到这个Service中</div><div class="line">        String path = getPatchPathExtra(intent);</div><div class="line">        if (path == null) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;TinkerPatchService can&apos;t get the path extra, ignoring.&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        File patchFile = new File(path);</div><div class="line"></div><div class="line">        long begin = SystemClock.elapsedRealtime();</div><div class="line">        boolean result;</div><div class="line">        long cost;</div><div class="line">        Throwable e = null;</div><div class="line"></div><div class="line">        //提高优先级</div><div class="line">        increasingPriority();</div><div class="line">        //patchResult用于处理更新结果</div><div class="line">        PatchResult patchResult = new PatchResult();</div><div class="line">        try &#123;</div><div class="line">            if (upgradePatchProcessor == null) &#123;</div><div class="line">                throw new TinkerRuntimeException(&quot;upgradePatchProcessor is null.&quot;);</div><div class="line">            &#125;</div><div class="line">            //在这里开启更新</div><div class="line">            result = upgradePatchProcessor.tryPatch(context, path, patchResult);</div><div class="line">        &#125; catch (Throwable throwable) &#123;</div><div class="line">            e = throwable;</div><div class="line">            result = false;</div><div class="line">            tinker.getPatchReporter().onPatchException(patchFile, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //记录更新结果</div><div class="line">        cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">        tinker.getPatchReporter().</div><div class="line">            onPatchResult(patchFile, result, cost);</div><div class="line"></div><div class="line">        patchResult.isSuccess = result;</div><div class="line">        patchResult.rawPatchFilePath = path;</div><div class="line">        patchResult.costTime = cost;</div><div class="line">        patchResult.e = e;</div><div class="line">        AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>其实上面Service最重要的就是就是启动了一个线程，会调用了upgradePatch的tryPatch执行patch操作,下面我们来看看这个patch操作的处理<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line">public boolean tryPatch(Context context, String tempPatchPath, PatchResult patchResult) &#123;</div><div class="line">        Tinker manager = Tinker.with(context);</div><div class="line"></div><div class="line">        final File patchFile = new File(tempPatchPath);</div><div class="line">        </div><div class="line">        //tinker是否处于enable状态</div><div class="line">        if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:patch is disabled, just return&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        //是否是合法的patch文件</div><div class="line">        if (!SharePatchFileUtil.isLegalFile(patchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:patch file is not found, just return&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        //创建出ShareSecurityCheck，用于检查签名文件</div><div class="line">        ShareSecurityCheck signatureCheck = new ShareSecurityCheck(context);</div><div class="line">        //检查tinkerid和签名是否正确，后面我们会分析这个检查的执行</div><div class="line">        int returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);</div><div class="line">        if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:onPatchPackageCheckFail&quot;);</div><div class="line">            manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //获取相对应的md5值</div><div class="line">        String patchMd5 = SharePatchFileUtil.getMD5(patchFile);</div><div class="line">        if (patchMd5 == null) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:patch md5 is null, just return&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        TinkerLog.i(TAG, &quot;UpgradePatch tryPatch:patchMd5:%s&quot;, patchMd5);</div><div class="line"></div><div class="line">        //上面的检查都正确了，那么可以开始进行修复了</div><div class="line">        final String patchDirectory = manager.getPatchDirectory().getAbsolutePath();</div><div class="line"></div><div class="line">        //获取Patchinfo的解锁文件和正式文件</div><div class="line">        File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);</div><div class="line">        File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);</div><div class="line"></div><div class="line">        //获取先前的patchInfo</div><div class="line">        SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</div><div class="line"></div><div class="line">        //it is a new patch, so we should not find a exist</div><div class="line">        SharePatchInfo newInfo;</div><div class="line"></div><div class="line">        //已经patch文件了</div><div class="line">        if (oldInfo != null) &#123;</div><div class="line">            if (oldInfo.oldVersion == null || oldInfo.newVersion == null || oldInfo.oatDir == null) &#123;</div><div class="line">                TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:onPatchInfoCorrupted&quot;);</div><div class="line">                manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            //md5不合法</div><div class="line">            if (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) &#123;</div><div class="line">                TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid&quot;, patchMd5);</div><div class="line">                manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            // 生成新的PatchInfo</div><div class="line">            final String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)</div><div class="line">                ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;</div><div class="line">            newInfo = new SharePatchInfo(oldInfo.oldVersion, patchMd5, Build.FINGERPRINT, finalOatDir);</div><div class="line">        &#125; else &#123;</div><div class="line">            newInfo = new SharePatchInfo(&quot;&quot;, patchMd5, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">      </div><div class="line">        final String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);</div><div class="line"></div><div class="line">        final String patchVersionDirectory = patchDirectory + &quot;/&quot; + patchName;</div><div class="line"></div><div class="line">        TinkerLog.i(TAG, &quot;UpgradePatch tryPatch:patchVersionDirectory:%s&quot;, patchVersionDirectory);</div><div class="line"></div><div class="line">        //复制文件</div><div class="line">        File destPatchFile = new File(patchVersionDirectory + &quot;/&quot; + SharePatchFileUtil.getPatchVersionFile(patchMd5));</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 再次检查md5</div><div class="line">            if (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) &#123;</div><div class="line">                SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);</div><div class="line">                TinkerLog.w(TAG, &quot;UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d&quot;, patchFile.getAbsolutePath(), patchFile.length(),</div><div class="line">                    destPatchFile.getAbsolutePath(), destPatchFile.length());</div><div class="line">            &#125;</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:copy patch file fail from %s to %s&quot;, patchFile.getPath(), destPatchFile.getPath());</div><div class="line">            manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //尝试修复dex</div><div class="line">        if (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch dex failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch library failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, try patch resource failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted</div><div class="line">        if (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, check dex opt file failed&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) &#123;</div><div class="line">            TinkerLog.e(TAG, &quot;UpgradePatch tryPatch:new patch recover, rewrite patch info failed&quot;);</div><div class="line">            manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TinkerLog.w(TAG, &quot;UpgradePatch tryPatch: done, it is ok&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>在上面我们主要关注dex的修复，因为目前仅仅用于dex修复。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">protected static boolean tryRecoverDexFiles(Tinker manager, ShareSecurityCheck checker, Context context,</div><div class="line">                                                String patchVersionDirectory, File patchFile) &#123;</div><div class="line">        if (!manager.isEnabledForDex()) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;patch recover, dex is not enabled&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        //获取dex文件</div><div class="line">        String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE);</div><div class="line"></div><div class="line">        if (dexMeta == null) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;patch recover, dex is not contained&quot;);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        long begin = SystemClock.elapsedRealtime();</div><div class="line">        //在这里进行dex解压和处理</div><div class="line">        boolean result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</div><div class="line">        long cost = SystemClock.elapsedRealtime() - begin;</div><div class="line">        TinkerLog.i(TAG, &quot;recover dex result:%b, cost:%d&quot;, result, cost);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure><br>我们看看patchDexExtractViaDexDiff的解压操作：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">private static boolean patchDexExtractViaDexDiff(Context context, String patchVersionDirectory, String meta, final File patchFile) &#123;</div><div class="line">        String dir = patchVersionDirectory + &quot;/&quot; + DEX_PATH + &quot;/&quot;;</div><div class="line">        </div><div class="line">        //对patch文件解压和检查</div><div class="line">        if (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) &#123;</div><div class="line">            TinkerLog.w(TAG, &quot;patch recover, extractDiffInternals fail&quot;);</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final Tinker manager = Tinker.with(context);</div><div class="line"></div><div class="line">        File dexFiles = new File(dir);</div><div class="line">        File[] files = dexFiles.listFiles();</div><div class="line">        optFiles.clear();</div><div class="line"></div><div class="line">        if (files != null) &#123;</div><div class="line">            final String optimizeDexDirectory = patchVersionDirectory + &quot;/&quot; + DEX_OPTIMIZE_PATH + &quot;/&quot;;</div><div class="line">            File optimizeDexDirectoryFile = new File(optimizeDexDirectory);</div><div class="line"></div><div class="line">            if (!optimizeDexDirectoryFile.exists() &amp;&amp; !optimizeDexDirectoryFile.mkdirs()) &#123;</div><div class="line">                TinkerLog.w(TAG, &quot;patch recover, make optimizeDexDirectoryFile fail&quot;);</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            //添加opt文件</div><div class="line">            for (File file : files) &#123;</div><div class="line">                String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);</div><div class="line">                optFiles.add(new File(outputPathName));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            TinkerLog.i(TAG, &quot;patch recover, try to optimize dex file count:%d, optimizeDexDirectory:%s&quot;, files.length, optimizeDexDirectory);</div><div class="line">            //针对于art虚拟机使用parallel dex optimizer</div><div class="line">            if (ShareTinkerInternals.isVmArt()) &#123;</div><div class="line">                final List&lt;File&gt; failOptDexFile = new Vector&lt;&gt;();</div><div class="line">                final Throwable[] throwable = new Throwable[1];</div><div class="line"></div><div class="line">                // try parallel dex optimizer</div><div class="line">                TinkerParallelDexOptimizer.optimizeAll(</div><div class="line">                    Arrays.asList(files), optimizeDexDirectoryFile,</div><div class="line">                    new TinkerParallelDexOptimizer.ResultCallback() &#123;</div><div class="line">                        long startTime;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        public void onStart(File dexFile, File optimizedDir) &#123;</div><div class="line">                            startTime = System.currentTimeMillis();</div><div class="line">                            TinkerLog.i(TAG, &quot;start to parallel optimize dex %s, size: %d&quot;, dexFile.getPath(), dexFile.length());</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        public void onSuccess(File dexFile, File optimizedDir, File optimizedFile) &#123;</div><div class="line">                            // Do nothing.</div><div class="line">                            TinkerLog.i(TAG, &quot;success to parallel optimize dex %s, opt file size: %d, use time %d&quot;,</div><div class="line">                                dexFile.getPath(), optimizedFile.length(), (System.currentTimeMillis() - startTime));</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        @Override</div><div class="line">                        public void onFailed(File dexFile, File optimizedDir, Throwable thr) &#123;</div><div class="line">                            TinkerLog.i(TAG, &quot;fail to parallel optimize dex %s use time %d&quot;,</div><div class="line">                                dexFile.getPath(), (System.currentTimeMillis() - startTime));</div><div class="line">                            failOptDexFile.add(dexFile);</div><div class="line">                            throwable[0] = thr;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                );</div><div class="line"></div><div class="line">                if (!failOptDexFile.isEmpty()) &#123;</div><div class="line">                    manager.getPatchReporter().onPatchDexOptFail(patchFile, failOptDexFile, throwable[0]);</div><div class="line">                    return false;</div><div class="line">                &#125;</div><div class="line">            // 对于davik虚拟机</div><div class="line">            &#125; else &#123;</div><div class="line">                for (File file : files) &#123;</div><div class="line">                    try &#123;</div><div class="line">                        String outputPathName = SharePatchFileUtil.optimizedPathFor(file, optimizeDexDirectoryFile);</div><div class="line">                        long start = System.currentTimeMillis();</div><div class="line">                        //加载dex文件</div><div class="line">                        DexFile.loadDex(file.getAbsolutePath(), outputPathName, 0);</div><div class="line">                        TinkerLog.i(TAG, &quot;success single dex optimize file, path: %s, opt file size: %d, use time: %d&quot;, file.getPath(), new File(outputPathName).length(),</div><div class="line">                            (System.currentTimeMillis() - start));</div><div class="line">                    &#125; catch (Throwable e) &#123;</div><div class="line">                        TinkerLog.e(TAG, &quot;single dex optimize or load failed, path:&quot; + file.getPath());</div><div class="line">                        List&lt;File&gt; failedList = new ArrayList&lt;&gt;();</div><div class="line">                        failedList.add(file);</div><div class="line">                        manager.getPatchReporter().onPatchDexOptFail(patchFile, failedList, e);</div><div class="line">                        return false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"> </div></pre></td></tr></table></figure></p>
<h2 id="tinker生成patch原理"><a href="#tinker生成patch原理" class="headerlink" title="tinker生成patch原理"></a>tinker生成patch原理</h2><h3 id="dex文件格式"><a href="#dex文件格式" class="headerlink" title="dex文件格式"></a>dex文件格式</h3><p>在了解tinker生成patch文件之前，我们必须先了解一下dex文件的格式。dex文件是davilk虚拟机的文件格式。详细的可以查看<a href="https://source.android.com/devices/tech/dalvik/dex-format详细文档的信息。在这里，我们主要关注dex的文件格式" target="_blank" rel="external">https://source.android.com/devices/tech/dalvik/dex-format详细文档的信息。在这里，我们主要关注dex的文件格式</a></p>
<ul>
<li><p>header:这个是最重要的属性。标识了该文件的格式,并且记录了当前文件的数据类型的偏移量和数量。</p>
</li>
<li><p>string_ids：字符串数据索引，这个内容必须排序，且不能重复。</p>
</li>
<li><p>type_ids: ： 类型的字符串索引，按照stringId的索引进行排序，也不能有重复</p>
</li>
<li><p>proto_ids:  原形数据索引，这个列表必须要按照typeid索引进行主要顺序排序，参数列表按照字典排序</p>
</li>
<li><p>field_ids: 字段数据索引，定义的类型按照typeid排序，名称爱照stringid排序，这个字段不能重复</p>
</li>
<li><p>method_ids: 方法索引，dex文件中所有方法的标识符，必须进行排序，不能重复</p>
</li>
<li><p>class_defs: 类索引，必须进行排序，超类或者引用类必须更早出现，重复的重名类无效。</p>
</li>
<li><p>call_site_ids: 调用站点标识符列表</p>
</li>
<li><p>method_handles: 方法引用。</p>
</li>
<li><p>data: 数据区</p>
</li>
<li><p>link_data: 链接数据区</p>
</li>
</ul>
<p>如下所示，这个是一个dex文件的数据解析。<br><img src="http://onu21exz8.bkt.clouddn.com/dex_total.jpeg" alt=""><br>我们可以看到dex文件的起始的三个字符就是dex，这个字符用来标识这是一个dex格式的文件。</p>
<p>下面我们针对于上面几个比较重要的元素来进行分析。<br><img src="http://onu21exz8.bkt.clouddn.com/header.jpeg" alt=""><br>首先是header里面的信息，首先magic会包含struct dex_magic magic结构，这个就是标识文件格式的结构，内部dex的编码。然后会是sha1签名的编码。最后是一些内部数据的大小及偏移量。如果我们想要解析这个dex文件，header的信息是我们必须要先解析出来的。</p>
<p><img src="http://onu21exz8.bkt.clouddn.com/stringid.jpeg" alt=""><br>stringId项会将所有的string类型数据进行存储<br><img src="http://onu21exz8.bkt.clouddn.com/typeid.jpeg" alt=""><br>typeId为文件中使用的数据类型和对象类型<br><img src="http://onu21exz8.bkt.clouddn.com/fileid.jpeg" alt=""><br>filedId为定义的字段名称<br><img src="http://onu21exz8.bkt.clouddn.com/protoid.jpeg" alt=""><br>protoId为原型数据类型<br><img src="http://onu21exz8.bkt.clouddn.com/methodid.jpeg" alt=""><br>methodId为dex文件中涉及的所有方法<br><img src="http://onu21exz8.bkt.clouddn.com/classid.jpeg" alt=""><br>classId表示在dex文件中涉及的所有类，超类必须比子类早出现，内部包含类名，标识位，超类。。</p>
<h3 id="tinker-dex文件的生成"><a href="#tinker-dex文件的生成" class="headerlink" title="tinker dex文件的生成"></a>tinker dex文件的生成</h3><p>tinker通过全量的apk打包，然后进行与旧包进行对比，通过差异化生成patch的dex文件。下面我们来看看它是如何生成patch的。<br>gradle定义task有几种方式，我们可以定义一个task继承于DefaultTask，然后通过@TaskAction注解声明gradle的task执行时会调用的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">@TaskAction</div><div class="line">   def tinkerPatch() &#123;</div><div class="line">       configuration.checkParameter()</div><div class="line">       configuration.buildConfig.checkParameter()</div><div class="line">       configuration.res.checkParameter()</div><div class="line">       configuration.dex.checkDexMode()</div><div class="line">       configuration.sevenZip.resolveZipFinalPath()</div><div class="line"></div><div class="line">       InputParam.Builder builder = new InputParam.Builder()</div><div class="line">       if (configuration.useSign) &#123;</div><div class="line">           if (signConfig == null) &#123;</div><div class="line">               throw new GradleException(&quot;can&apos;t the get signConfig for this build&quot;)</div><div class="line">           &#125;</div><div class="line">           builder.setSignFile(signConfig.storeFile)</div><div class="line">                   .setKeypass(signConfig.keyPassword)</div><div class="line">                   .setStorealias(signConfig.keyAlias)</div><div class="line">                   .setStorepass(signConfig.storePassword)</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       builder.setOldApk(configuration.oldApk)</div><div class="line">              .setNewApk(buildApkPath)</div><div class="line">              .setOutBuilder(outputFolder)</div><div class="line">              .setIgnoreWarning(configuration.ignoreWarning)</div><div class="line">              .setDexFilePattern(new ArrayList&lt;String&gt;(configuration.dex.pattern))</div><div class="line">              .setIsProtectedApp(configuration.buildConfig.isProtectedApp)</div><div class="line">              .setDexLoaderPattern(new ArrayList&lt;String&gt;(configuration.dex.loader))</div><div class="line">              .setDexIgnoreWarningLoaderPattern(new ArrayList&lt;String&gt;(configuration.dex.ignoreWarningLoader))</div><div class="line">              .setDexMode(configuration.dex.dexMode)</div><div class="line">              .setSoFilePattern(new ArrayList&lt;String&gt;(configuration.lib.pattern))</div><div class="line">              .setResourceFilePattern(new ArrayList&lt;String&gt;(configuration.res.pattern))</div><div class="line">              .setResourceIgnoreChangePattern(new ArrayList&lt;String&gt;(configuration.res.ignoreChange))</div><div class="line">              .setResourceLargeModSize(configuration.res.largeModSize)</div><div class="line">              .setUseApplyResource(configuration.buildConfig.usingResourceMapping)</div><div class="line">              .setConfigFields(new HashMap&lt;String, String&gt;(configuration.packageConfig.getFields()))</div><div class="line">              .setSevenZipPath(configuration.sevenZip.path)</div><div class="line">              .setUseSign(configuration.useSign)</div><div class="line"></div><div class="line">       InputParam inputParam = builder.create()</div><div class="line">       Runner.gradleRun(inputParam);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在gradle编译完成最新的apk之后，会调用调用这个task的方法，注入一些配置的必要参数，然后调用Runner.gradleRun方法执行run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public static void gradleRun(InputParam inputParam) &#123;</div><div class="line">        mBeginTime = System.currentTimeMillis();</div><div class="line">        Runner m = new Runner();</div><div class="line">        m.run(inputParam);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=====&gt;run</div><div class="line">private void run(InputParam inputParam) &#123;</div><div class="line">	//在这里将会读取gradle的各种配置信息到config中。</div><div class="line">        loadConfigFromGradle(inputParam);</div><div class="line">        try &#123;</div><div class="line">            Logger.initLogger(config);</div><div class="line">            tinkerPatch();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            goToError();</div><div class="line">        &#125; finally &#123;</div><div class="line">            Logger.closeLogger();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>会在run方法中调用tinkerPatch，这个是生成patch包的入口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">protected void tinkerPatch() &#123;</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch begin-----------------------&quot;);</div><div class="line"></div><div class="line">        Logger.d(config.toString());</div><div class="line">        try &#123;</div><div class="line">            //初始化APKDecoder，内部会初始化UniqueDexDiffDecoder、BsDiffDecoder、ResDiffDecoder,分别对应dex、so、res的patch生成</div><div class="line">            ApkDecoder decoder = new ApkDecoder(config);</div><div class="line">	    //patch开始前的预处理方法，目前为空实现</div><div class="line">            decoder.onAllPatchesStart();</div><div class="line">	    //对比新旧apk，生成patch</div><div class="line">            decoder.patch(config.mOldApkFile, config.mNewApkFile);</div><div class="line">            decoder.onAllPatchesEnd();</div><div class="line"></div><div class="line">            //gen meta file and version file</div><div class="line">            PatchInfo info = new PatchInfo(config);</div><div class="line">            info.gen();</div><div class="line"></div><div class="line">            //build patch</div><div class="line">            PatchBuilder builder = new PatchBuilder(config);</div><div class="line">            builder.buildPatch();</div><div class="line"></div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            goToError();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Logger.d(&quot;Tinker patch done, total time cost: %fs&quot;, diffTimeFromBegin());</div><div class="line">        Logger.d(&quot;Tinker patch done, you can go to file to find the output %s&quot;, config.mOutFolder);</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch end-------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=========&gt;在这里执行patch方法：</div><div class="line"></div><div class="line">public boolean patch(File oldFile, File newFile) throws Exception &#123;</div><div class="line">        writeToLogFile(oldFile, newFile);</div><div class="line">        //先对manifest进行patch处理，先检测miniSdk的修改与是否新增component</div><div class="line">        manifestDecoder.patch(oldFile, newFile);</div><div class="line">	//将apk文件读取成输出流</div><div class="line">        unzipApkFiles(oldFile, newFile);</div><div class="line">	//在这里会调用visitFile方法，生成各个patch文件</div><div class="line">        Files.walkFileTree(mNewApkDir.toPath(), new ApkFilesVisitor(config, mNewApkDir.toPath(), mOldApkDir.toPath(), dexPatchDecoder, soPatchDecoder, resPatchDecoder));</div><div class="line"></div><div class="line">        //get all duplicate resource file</div><div class="line">        for (File duplicateRes : resDuplicateFiles) &#123;</div><div class="line">//            resPatchDecoder.patch(duplicateRes, null);</div><div class="line">            Logger.e(&quot;Warning: res file %s is also match at dex or library pattern, &quot;</div><div class="line">                + &quot;we treat it as unchanged in the new resource_out.zip&quot;, getRelativePathStringToOldFile(duplicateRes));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	//在patch file完成之后，会执行一些patch完成后的操作</div><div class="line">        soPatchDecoder.onAllPatchesEnd();</div><div class="line">        dexPatchDecoder.onAllPatchesEnd();</div><div class="line">        manifestDecoder.onAllPatchesEnd();</div><div class="line">        resPatchDecoder.onAllPatchesEnd();</div><div class="line"></div><div class="line">        //clean resources</div><div class="line">        dexPatchDecoder.clean();</div><div class="line">        soPatchDecoder.clean();</div><div class="line">        resPatchDecoder.clean();</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在walkFileTree中会执行visitFile方法,在这里面分别会执行dex的patch方法，so的patch方法还有res的patch方法，我们主要关注dex的patch方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line">        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;	</div><div class="line">             dexDecoder.patch(oldFile, file.toFile());</div><div class="line">             return FileVisitResult.CONTINUE;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=====&gt; UniqueDexDiffDecoder.patch，这个类表示dex不能重复</div><div class="line"></div><div class="line"> @Override</div><div class="line">    public boolean patch(File oldFile, File newFile) throws IOException, TinkerPatchException &#123;</div><div class="line">        boolean added = super.patch(oldFile, newFile);</div><div class="line">        if (added) &#123;</div><div class="line">            String name = newFile.getName();</div><div class="line">            if (addedDexFiles.contains(name)) &#123;</div><div class="line">                throw new TinkerPatchException(&quot;illegal dex name, dex name should be unique, dex:&quot; + name);</div><div class="line">            &#125; else &#123;</div><div class="line">                addedDexFiles.add(name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return added;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=========&gt; super.patch也就是DexDiffDecoder.patch方法</div><div class="line"></div><div class="line">  public boolean patch(final File oldFile, final File newFile) throws IOException, TinkerPatchException &#123;</div><div class="line">        //获取相关的dex name</div><div class="line">        final String dexName = getRelativeDexName(oldFile, newFile);</div><div class="line"></div><div class="line">	//检测这个dex是否发生改变。</div><div class="line">        excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex(oldFile, newFile);</div><div class="line">        if (newFile == null || !newFile.exists() || newFile.length() == 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">	</div><div class="line">       </div><div class="line">        File dexDiffOut = getOutputPath(newFile).toFile();</div><div class="line"></div><div class="line">        final String newMd5 = getRawOrWrappedDexMD5(newFile);</div><div class="line"></div><div class="line">        //new add file</div><div class="line">        if (oldFile == null || !oldFile.exists() || oldFile.length() == 0) &#123;</div><div class="line">            hasDexChanged = true;</div><div class="line">            copyNewDexAndLogToDexMeta(newFile, newMd5, dexDiffOut);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final String oldMd5 = getRawOrWrappedDexMD5(oldFile);</div><div class="line"></div><div class="line">        if ((oldMd5 != null &amp;&amp; !oldMd5.equals(newMd5)) || (oldMd5 == null &amp;&amp; newMd5 != null)) &#123;</div><div class="line">            hasDexChanged = true;</div><div class="line">            if (oldMd5 != null) &#123;</div><div class="line">		//计算出来的md5不同，表示有类发生改变，那么收集增加或者删除的类</div><div class="line">                collectAddedOrDeletedClasses(oldFile, newFile);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        RelatedInfo relatedInfo = new RelatedInfo();</div><div class="line">        relatedInfo.oldMd5 = oldMd5;</div><div class="line">        relatedInfo.newMd5 = newMd5;</div><div class="line"></div><div class="line">        oldAndNewDexFilePairList.add(new AbstractMap.SimpleEntry&lt;&gt;(oldFile, newFile));</div><div class="line"></div><div class="line">        dexNameToRelatedInfoMap.put(dexName, relatedInfo);</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div></pre></td></tr></table></figure><br>上面的excludedClassModifiedChecker.checkIfExcludedClassWasModifiedInNewDex非常重要，这个类可以用来判断两个dex是否发生变化了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">public void checkIfExcludedClassWasModifiedInNewDex(File oldFile, File newFile) &#123;</div><div class="line">	    oldDex = (oldFile != null ? new Dex(oldFile) : null);</div><div class="line">             newDex = (newFile != null ? new Dex(newFile) : null);</div><div class="line">		/**</div><div class="line">                 * Check rule:</div><div class="line">                 * 新的dex和老的dex中的loader class必须一致</div><div class="line">                 *</div><div class="line">                 * An error is announced when any of these conditions below is fit:</div><div class="line">                 * 1. 老的dex文件有缺失</div><div class="line">                 * 2. 新的dex文件有缺失</div><div class="line">                 * 3. 老的dex文件中缺失某些loader类</div><div class="line">                 * 4. 新的dex文件中添加了某些老的dex文件中没有的loader类.</div><div class="line">                 * 5. 某些老的dex的loader 类发生了改变，然而却在新类中删除</div><div class="line">                 * 6. loader类在老的dex文件中重复定义</div><div class="line">                 * 7. Loader类在新的dex文件中重复定义</div><div class="line">                 */</div><div class="line">		 ....</div><div class="line"> 		 dexCmptor.startCheck(oldDex, newDex);</div><div class="line">                 deletedClassInfos = dexCmptor.getDeletedClassInfos()</div><div class="line">                 addedClassInfos = dexCmptor.getAddedClassInfos();</div><div class="line">                 changedClassInfosMap = new HashMap&lt;&gt;(dexCmptor.getChangedClassDescToInfosMap());</div><div class="line">		 ....</div><div class="line">&#125;</div><div class="line"></div><div class="line">======&gt;最主要的check方法</div><div class="line"> public void startCheck(Dex oldDex, Dex newDex) &#123;</div><div class="line">        startCheck(DexGroup.wrap(oldDex), DexGroup.wrap(newDex));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void startCheck(DexGroup oldDexGroup, DexGroup newDexGroup) &#123;</div><div class="line">        //</div><div class="line">        addedClassInfoList.clear();</div><div class="line">        deletedClassInfoList.clear();</div><div class="line">        changedClassDescToClassInfosMap.clear();</div><div class="line">        oldDescriptorOfClassesToCheck.clear();</div><div class="line">        newDescriptorOfClassesToCheck.clear();</div><div class="line">        oldClassDescriptorToClassInfoMap.clear();</div><div class="line">        newClassDescriptorToClassInfoMap.clear();</div><div class="line">        refAffectedClassDescs.clear();</div><div class="line"></div><div class="line">	//遍历Old dex，查看old dex文件中的classId items是否发生改变，</div><div class="line">        for (Dex oldDex : oldDexGroup.dexes) &#123;</div><div class="line">            int classDefIndex = 0;</div><div class="line">            for (ClassDef oldClassDef : oldDex.classDefs()) &#123;</div><div class="line">		//typeIndex是dex文件中的Class item的类型描述</div><div class="line">                String desc = oldDex.typeNames().get(oldClassDef.typeIndex);</div><div class="line">                if (Utils.isStringMatchesPatterns(desc, patternsOfClassDescToCheck)) &#123;</div><div class="line">               	     //如果类型匹配且不重复，则添加进oldDescriptorOfClassesToCheck中</div><div class="line">		     if (!oldDescriptorOfClassesToCheck.add(desc)) &#123;</div><div class="line">                        throw new IllegalStateException(</div><div class="line">                                String.format(</div><div class="line">                                        &quot;duplicate class descriptor [%s] in different old dexes.&quot;,</div><div class="line">                                        desc</div><div class="line">                                )</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//创建出dexClassInfo，并添加到oldClassDescriptorToClassInfoMap.put中。</div><div class="line">                DexClassInfo classInfo = new DexClassInfo(desc, classDefIndex, oldClassDef, oldDex);</div><div class="line">                ++classDefIndex;</div><div class="line">                oldClassDescriptorToClassInfoMap.put(desc, classInfo);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 遍历new dex，获取出new dex的class类型和对应的classInfo</div><div class="line">        for (Dex newDex : newDexGroup.dexes) &#123;</div><div class="line">            int classDefIndex = 0;</div><div class="line">            for (ClassDef newClassDef : newDex.classDefs()) &#123;</div><div class="line">                String desc = newDex.typeNames().get(newClassDef.typeIndex);</div><div class="line">                if (Utils.isStringMatchesPatterns(desc, patternsOfClassDescToCheck)) &#123;</div><div class="line">                    if (!newDescriptorOfClassesToCheck.add(desc)) &#123;</div><div class="line">                        throw new IllegalStateException(</div><div class="line">                                String.format(</div><div class="line">                                        &quot;duplicate class descriptor [%s] in different new dexes.&quot;,</div><div class="line">                                        desc</div><div class="line">                                )</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                DexClassInfo classInfo = new DexClassInfo(desc, classDefIndex, newClassDef, newDex);</div><div class="line">                ++classDefIndex;</div><div class="line">                newClassDescriptorToClassInfoMap.put(desc, classInfo);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //比较old和new中的class描述，deletedClassDescs剩余的成员就是需要移除的class。</div><div class="line">        Set&lt;String&gt; deletedClassDescs = new HashSet&lt;&gt;(oldDescriptorOfClassesToCheck);</div><div class="line">        deletedClassDescs.removeAll(newDescriptorOfClassesToCheck);</div><div class="line"></div><div class="line">        for (String desc : deletedClassDescs) &#123;</div><div class="line">            if (Utils.isStringMatchesPatterns(desc, patternsOfIgnoredRemovedClassDesc)) &#123;</div><div class="line">                logger.i(TAG, &quot;Ignored deleted class: %s&quot;, desc);</div><div class="line">                continue;</div><div class="line">            &#125; else &#123;</div><div class="line">                logger.i(TAG, &quot;Deleted class: %s&quot;, desc);</div><div class="line">            &#125;</div><div class="line">	    //如果不是忽略的，那么就要移除，保证两个dexList一致</div><div class="line">            deletedClassInfoList.add(oldClassDescriptorToClassInfoMap.get(desc));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	//比较old和new中的class描述， addedClassDescs中剩余的成员就是新增的类</div><div class="line">        Set&lt;String&gt; addedClassDescs = new HashSet&lt;&gt;(newDescriptorOfClassesToCheck);</div><div class="line">        addedClassDescs.removeAll(oldDescriptorOfClassesToCheck);</div><div class="line"></div><div class="line">        for (String desc : addedClassDescs) &#123;</div><div class="line">            logger.i(TAG, &quot;Added class: %s&quot;, desc);</div><div class="line">	    //增加新类</div><div class="line">            addedClassInfoList.add(newClassDescriptorToClassInfoMap.get(desc));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">	//通过oldDescriptorOfClassesToCheck和newDescriptorOfClassesToCheck，添加到同一个set中，这个set的成员就是可能发生改变的类</div><div class="line">        Set&lt;String&gt; mayBeChangedClassDescs = new HashSet&lt;&gt;(oldDescriptorOfClassesToCheck);</div><div class="line">        mayBeChangedClassDescs.retainAll(newDescriptorOfClassesToCheck);</div><div class="line"></div><div class="line">        for (String desc : mayBeChangedClassDescs) &#123;</div><div class="line">            DexClassInfo oldClassInfo = oldClassDescriptorToClassInfoMap.get(desc);</div><div class="line">            DexClassInfo newClassInfo = newClassDescriptorToClassInfoMap.get(desc);</div><div class="line">            switch (compareMode) &#123;</div><div class="line">                case COMPARE_MODE_NORMAL: &#123;</div><div class="line">		    //比较是否是同一个类，会比较类中的所有成员、方法及变量。</div><div class="line">                    if (!isSameClass(</div><div class="line">                            oldClassInfo.owner,</div><div class="line">                            newClassInfo.owner,</div><div class="line">                            oldClassInfo.classDef,</div><div class="line">                            newClassInfo.classDef</div><div class="line">                    )) &#123;</div><div class="line">                        logger.i(TAG, &quot;Changed class: %s&quot;, desc);</div><div class="line">			//假如类发生过改变，那么添加到changedClassDescToClassInfosMap中</div><div class="line">                        changedClassDescToClassInfosMap.put(</div><div class="line">                                desc, new DexClassInfo[]&#123;oldClassInfo, newClassInfo&#125;</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY: &#123;</div><div class="line">                    if (isClassChangeAffectedToReferrer(</div><div class="line">                            oldClassInfo.owner,</div><div class="line">                            newClassInfo.owner,</div><div class="line">                            oldClassInfo.classDef,</div><div class="line">                            newClassInfo.classDef</div><div class="line">                    )) &#123;</div><div class="line">                        logger.i(TAG, &quot;Ref-changed class: %s&quot;, desc);</div><div class="line">                        changedClassDescToClassInfosMap.put(</div><div class="line">                                desc, new DexClassInfo[]&#123;oldClassInfo, newClassInfo&#125;</div><div class="line">                        );</div><div class="line">                    &#125;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>那么tinker是如何判断类是否发生了改变呢，其实也是基本dex的文件的格式去判断的。上面也简单的截了张classItem的图了。现在我们来详细介绍下class里面的内部成员。</p>
<ul>
<li>unit class_idx:也就是类的类型，被称为类的typeId</li>
<li>enum ACCESS_FLAGS access_flags： 也就是类的访问权限</li>
<li>uint superclass_idx： 超类的类型， 也就是超类的typeId</li>
<li>uint interfaces_idx： 类中的接口列表，</li>
<li>uint source_file_idx： 类的名称</li>
<li>uint annotations_idx： 注解的列表</li>
<li>struct class_data_item class_data： class里面的内部数据。包括了static field， instance field，direct method，virtual methods等。</li>
</ul>
<p>那么isSameClass就是基于这些数据定义去进行比较的。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">private boolean isSameClass(Dex oldDex,Dex newDex,ClassDef oldClassDef,</div><div class="line">           ClassDef newClassDef) &#123;</div><div class="line">       //首先判断类的标识位是否一致</div><div class="line">       if (oldClassDef.accessFlags != newClassDef.accessFlags) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断类的desc是否一致，也就是类型的定义是否一致</div><div class="line">       if (!isSameClassDesc(</div><div class="line">               oldDex, newDex, oldClassDef.supertypeIndex, newClassDef.supertypeIndex</div><div class="line">       )) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       short[] oldInterfaceIndices = oldDex.interfaceTypeIndicesFromClassDef(oldClassDef);</div><div class="line">       short[] newInterfaceIndices = newDex.interfaceTypeIndicesFromClassDef(newClassDef);</div><div class="line">      	//判断接口是否一致</div><div class="line"> if (oldInterfaceIndices.length != newInterfaceIndices.length) &#123;</div><div class="line">           return false;</div><div class="line">       &#125; else &#123;</div><div class="line">           for (int i = 0; i &lt; oldInterfaceIndices.length; ++i) &#123;</div><div class="line">               if (!isSameClassDesc(oldDex, newDex, oldInterfaceIndices[i], newInterfaceIndices[i])) &#123;</div><div class="line">                   return false;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断源文件的java名称是否一致</div><div class="line">       if (!isSameName(oldDex, newDex, oldClassDef.sourceFileIndex, newClassDef.sourceFileIndex)) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断是否是同样的注解</div><div class="line">       if (!isSameAnnotationDirectory(</div><div class="line">               oldDex,</div><div class="line">               newDex,</div><div class="line">               oldClassDef.annotationsOffset,</div><div class="line">               newClassDef.annotationsOffset</div><div class="line">       )) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">//判断是否是同样的classData，内部遍历定义的field和method</div><div class="line">       if (!isSameClassData(</div><div class="line">               oldDex,</div><div class="line">               newDex,</div><div class="line">               oldClassDef.classDataOffset,</div><div class="line">               newClassDef.classDataOffset</div><div class="line">       )) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       return isSameStaticValue(</div><div class="line">               oldDex,</div><div class="line">               newDex,</div><div class="line">               oldClassDef.staticValuesOffset,</div><div class="line">               newClassDef.staticValuesOffset</div><div class="line">       );</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在ApkDecoder执行patch完毕之后，将会调用onAllPatchEnd表示patch执行完毕最后需要进行的操作。<br>现在我们来看看dexPatchDecoder的onAllPatchEnd方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void onAllPatchesEnd() throws Exception &#123;</div><div class="line">        //假如patch过程中没有检测到dex改变的话，直接返回。</div><div class="line">        if (!hasDexChanged) &#123;</div><div class="line">            Logger.d(&quot;No dexes were changed, nothing needs to be done next.&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">	//是否使用加固模式，这里我们仅仅阅读不使用加固模式的方式。</div><div class="line">        if (config.mIsProtectedApp) &#123;</div><div class="line">            generateChangedClassesDexFile();</div><div class="line">        &#125; else &#123;</div><div class="line">	    //在这里生成patch文件到file。</div><div class="line">            generatePatchInfoFile();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        addTestDex();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">======》 generatePatchInfoFile</div><div class="line"></div><div class="line"> private void generatePatchInfoFile() throws IOException &#123;</div><div class="line">     	//生成dexfile</div><div class="line">        generatePatchedDexInfoFile();</div><div class="line">	</div><div class="line">	//因为generateSmallPatchedDexInfoFile可能会发生阻塞而导致art虚拟机出现异常崩溃</div><div class="line">	//generateSmallPatchedDexInfoFile();</div><div class="line">        logDexesToDexMeta();</div><div class="line"></div><div class="line">        checkCrossDexMovingClasses();</div><div class="line">    &#125;</div><div class="line">======》</div><div class="line"> private void generatePatchedDexInfoFile() &#123;</div><div class="line">        for (AbstractMap.SimpleEntry&lt;File, File&gt; oldAndNewDexFilePair : oldAndNewDexFilePairList) &#123;</div><div class="line">            File oldFile = oldAndNewDexFilePair.getKey();</div><div class="line">            File newFile = oldAndNewDexFilePair.getValue();</div><div class="line">            final String dexName = getRelativeDexName(oldFile, newFile);</div><div class="line">            RelatedInfo relatedInfo = dexNameToRelatedInfoMap.get(dexName);</div><div class="line">            if (!relatedInfo.oldMd5.equals(relatedInfo.newMd5)) &#123;</div><div class="line">		//md5不同，所以需要生成dex文件</div><div class="line">                diffDexPairAndFillRelatedInfo(oldFile, newFile, relatedInfo);</div><div class="line">            &#125; else &#123;</div><div class="line">		//在这种情况下，两个dex的文件是一致的，但是我们也需要将它当成一个更新的dex，这样SmallPatchGenerator才能够分析这个dex中的哪个类需要保存在small patch中</div><div class="line">                relatedInfo.newOrFullPatchedFile = newFile;</div><div class="line">                relatedInfo.newOrFullPatchedMd5 = relatedInfo.newMd5;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>一旦两个文件的md5值不同，就需要生成patch文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">private void diffDexPairAndFillRelatedInfo(File oldDexFile, File newDexFile, RelatedInfo relatedInfo) &#123;</div><div class="line">        File tempFullPatchDexPath = new File(config.mOutFolder + File.separator + TypedValue.DEX_TEMP_PATCH_DIR);</div><div class="line">        final String dexName = getRelativeDexName(oldDexFile, newDexFile);</div><div class="line"></div><div class="line">        File dexDiffOut = getOutputPath(newDexFile).toFile();</div><div class="line">        ensureDirectoryExist(dexDiffOut.getParentFile());</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">	    //初始化dexPatch生成器</div><div class="line">            DexPatchGenerator dexPatchGen = new DexPatchGenerator(oldDexFile, newDexFile);</div><div class="line">            dexPatchGen.setAdditionalRemovingClassPatterns(config.mDexLoaderPattern);</div><div class="line"></div><div class="line">            logWriter.writeLineToInfoFile(</div><div class="line">                    String.format(</div><div class="line">                            &quot;Start diff between [%s] as old and [%s] as new:&quot;,</div><div class="line">                            getRelativeStringBy(oldDexFile, config.mTempUnzipOldDir),</div><div class="line">                            getRelativeStringBy(newDexFile, config.mTempUnzipNewDir)</div><div class="line">                    )</div><div class="line">            );</div><div class="line">	    //执行dexPatch并保存到dexDiffOut文件。</div><div class="line">            dexPatchGen.executeAndSaveTo(dexDiffOut);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw new TinkerPatchException(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!dexDiffOut.exists()) &#123;</div><div class="line">            throw new TinkerPatchException(&quot;can not find the diff file:&quot; + dexDiffOut.getAbsolutePath());</div><div class="line">        &#125;</div><div class="line">	//将输出文件的信息添加到relatedINfo中。</div><div class="line">        relatedInfo.dexDiffFile = dexDiffOut;</div><div class="line">        relatedInfo.dexDiffMd5 = MD5.getMD5(dexDiffOut);</div><div class="line">        Logger.d(&quot;\nGen %s patch file:%s, size:%d, md5:%s&quot;, dexName, relatedInfo.dexDiffFile.getAbsolutePath(), relatedInfo.dexDiffFile.length(), relatedInfo.dexDiffMd5);</div><div class="line"></div><div class="line">        File tempFullPatchedDexFile = new File(tempFullPatchDexPath, dexName);</div><div class="line">        if (!tempFullPatchedDexFile.exists()) &#123;</div><div class="line">            ensureDirectoryExist(tempFullPatchedDexFile.getParentFile());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            new DexPatchApplier(oldDexFile, dexDiffOut).executeAndSaveTo(tempFullPatchedDexFile);</div><div class="line"></div><div class="line">            Logger.d(</div><div class="line">                    String.format(&quot;Verifying if patched new dex is logically the same as original new dex: %s ...&quot;, getRelativeStringBy(newDexFile, config.mTempUnzipNewDir))</div><div class="line">            );</div><div class="line"></div><div class="line">            Dex origNewDex = new Dex(newDexFile);</div><div class="line">            Dex patchedNewDex = new Dex(tempFullPatchedDexFile);</div><div class="line">            //检查这个新的patch文件是否真的有更新</div><div class="line">	    checkDexChange(origNewDex, patchedNewDex);</div><div class="line">		</div><div class="line">            relatedInfo.newOrFullPatchedFile = tempFullPatchedDexFile;</div><div class="line">            relatedInfo.newOrFullPatchedMd5 = MD5.getMD5(tempFullPatchedDexFile);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            throw new TinkerPatchException(</div><div class="line">                    &quot;Failed to generate temporary patched dex, which makes MD5 generating procedure of new dex failed, either.&quot;, e</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!tempFullPatchedDexFile.exists()) &#123;</div><div class="line">            throw new TinkerPatchException(&quot;can not find the temporary full patched dex file:&quot; + tempFullPatchedDexFile.getAbsolutePath());</div><div class="line">        &#125;</div><div class="line">        Logger.d(&quot;\nGen %s for dalvik full dex file:%s, size:%d, md5:%s&quot;, dexName, tempFullPatchedDexFile.getAbsolutePath(), tempFullPatchedDexFile.length(), relatedInfo.newOrFullPatchedMd5);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>上面的方法非常重要，我们必须要知道这个文件内每一种Patch生成器的类型。这个就是tinker计算patch的算法所在。其实也是依据dex文件的格式去生成patch。</p>
<ul>
<li>StringDataSectionDiffAlgorithm</li>
<li>TypeIdSectionDiffAlgorithm</li>
<li>ProtoIdSectionDiffAlgorithm</li>
<li>FieldIdSectionDiffAlgorithm</li>
<li>MethodIdSectionDiffAlgorithm</li>
<li>ClassDefSectionDiffAlgorithm</li>
<li>TypeListSectionDiffAlgorithm</li>
<li>AnnotationSetRefListSectionDiffAlgorithm</li>
<li>AnnotationSetSectionDiffAlgorithm</li>
<li>ClassDataSectionDiffAlgorithm</li>
<li>CodeSectionDiffAlgorithm</li>
<li>DebugInfoItemSectionDiffAlgorithm</li>
<li>StaticValueSectionDiffAlgorithm</li>
<li>AnnotationsDirectorySectionDiffAlgorithm</li>
</ul>
<p>这些算法都是子类的实现，他们标注了自身的类型，并且从DexCOntent中去进行对比，我们在这里选择CodeSectionDiff去分析。实际上所有的父类的实现都是一致的。DexSectionDiffAlgorithm的excute方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line">public void execute() &#123;</div><div class="line">        this.patchOperationList.clear();</div><div class="line">	//收集oldDex中指定格式的item</div><div class="line">        this.adjustedOldIndexedItemsWithOrigOrder = collectSectionItems(this.oldDex, true);</div><div class="line">        this.oldItemCount = this.adjustedOldIndexedItemsWithOrigOrder.length;</div><div class="line"></div><div class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedOldIndexedItems = new AbstractMap.SimpleEntry[this.oldItemCount];</div><div class="line">        System.arraycopy(this.adjustedOldIndexedItemsWithOrigOrder, 0, adjustedOldIndexedItems, 0, this.oldItemCount);</div><div class="line">        //进行排序</div><div class="line">	Arrays.sort(adjustedOldIndexedItems, this.comparatorForItemDiff);</div><div class="line">	//收集newDex中指定格式的item并排序</div><div class="line">        AbstractMap.SimpleEntry&lt;Integer, T&gt;[] adjustedNewIndexedItems = collectSectionItems(this.newDex, false);</div><div class="line">        this.newItemCount = adjustedNewIndexedItems.length;</div><div class="line">        Arrays.sort(adjustedNewIndexedItems, this.comparatorForItemDiff);</div><div class="line"></div><div class="line">        int oldCursor = 0;</div><div class="line">        int newCursor = 0;</div><div class="line">     　   while (oldCursor &lt; this.oldItemCount || newCursor &lt; this.newItemCount) &#123;</div><div class="line">            if (oldCursor &gt;= this.oldItemCount) &#123;</div><div class="line">                // 表示oldDex中内容已经比较完毕了，剩下的就是newDex里面的item，此时里面的item就都是新增加的.</div><div class="line">                while (newCursor &lt; this.newItemCount) &#123;</div><div class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor++];</div><div class="line">		    //将新添加的item添加的patchOperationlist中</div><div class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</div><div class="line">                &#125;</div><div class="line">            &#125; else if (newCursor &gt;= newItemCount) &#123;</div><div class="line">                // 这种情况下表示newDex的item已经比较完毕，oldDex剩余的item就是需要删除的item</div><div class="line">                while (oldCursor &lt; oldItemCount) &#123;</div><div class="line">                    AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor++];</div><div class="line">                    int deletedIndex = oldIndexedItem.getKey();</div><div class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</div><div class="line">                   //将删除的dex添加到patchOperationList中，并且记录偏移量 </div><div class="line">		   this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</div><div class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">		//两个dex中item都存在，</div><div class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; oldIndexedItem = adjustedOldIndexedItems[oldCursor];</div><div class="line">                AbstractMap.SimpleEntry&lt;Integer, T&gt; newIndexedItem = adjustedNewIndexedItems[newCursor];</div><div class="line">                //比较新老item</div><div class="line">		int cmpRes = oldIndexedItem.getValue().compareTo(newIndexedItem.getValue());</div><div class="line">		//这个比较仅仅只是比较指针所对应的item的值，即名称的ASIC码大小，</div><div class="line">                if (cmpRes &lt; 0) &#123;</div><div class="line">		    //cmp&lt;0,将old标记为del</div><div class="line">                    int deletedIndex = oldIndexedItem.getKey();</div><div class="line">                    int deletedOffset = getItemOffsetOrIndex(deletedIndex, oldIndexedItem.getValue());</div><div class="line">                    this.patchOperationList.add(new PatchOperation&lt;T&gt;(PatchOperation.OP_DEL, deletedIndex));</div><div class="line">                    markDeletedIndexOrOffset(this.oldToPatchedIndexMap, deletedIndex, deletedOffset);</div><div class="line">                    ++oldCursor;</div><div class="line">                &#125; else</div><div class="line">                if (cmpRes &gt; 0) &#123;</div><div class="line">		    //cmp&gt;0，将这个item标记为add</div><div class="line">                    this.patchOperationList.add(new PatchOperation&lt;&gt;(PatchOperation.OP_ADD, newIndexedItem.getKey(), newIndexedItem.getValue()));</div><div class="line">                    ++newCursor;</div><div class="line">                &#125; else &#123;</div><div class="line">		    //如果两个item一致，需要判断index是否一致，offset是否一致</div><div class="line">                    int oldIndex = oldIndexedItem.getKey();</div><div class="line">                    int newIndex = newIndexedItem.getKey();</div><div class="line">                    int oldOffset = getItemOffsetOrIndex(oldIndexedItem.getKey(), oldIndexedItem.getValue());</div><div class="line">                    int newOffset = getItemOffsetOrIndex(newIndexedItem.getKey(), newIndexedItem.getValue());</div><div class="line"></div><div class="line">                    if (oldIndex != newIndex) &#123;</div><div class="line">                        this.oldIndexToNewIndexMap.put(oldIndex, newIndex);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (oldOffset != newOffset) &#123;</div><div class="line">                        this.oldOffsetToNewOffsetMap.put(oldOffset, newOffset);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    ++oldCursor;</div><div class="line">                    ++newCursor;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	</div><div class="line">	//遍历完成之后，此时所有的diff都已经完成，现在需要判断del和add是否需要替换成replace</div><div class="line">        Collections.sort(this.patchOperationList, comparatorForPatchOperationOpt);</div><div class="line">		</div><div class="line">        Iterator&lt;PatchOperation&lt;T&gt;&gt; patchOperationIt = this.patchOperationList.iterator();</div><div class="line">        PatchOperation&lt;T&gt; prevPatchOperation = null;</div><div class="line">        while (patchOperationIt.hasNext()) &#123;</div><div class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</div><div class="line">           //如果index相同，且前一个与后一个分别是del和add，那么替换成replace </div><div class="line">	   if (prevPatchOperation != null</div><div class="line">                &amp;&amp; prevPatchOperation.op == PatchOperation.OP_DEL</div><div class="line">                &amp;&amp; patchOperation.op == PatchOperation.OP_ADD</div><div class="line">            ) &#123;</div><div class="line">                if (prevPatchOperation.index == patchOperation.index) &#123;</div><div class="line">                    prevPatchOperation.op = PatchOperation.OP_REPLACE;</div><div class="line">                    prevPatchOperation.newItem = patchOperation.newItem;</div><div class="line">                    patchOperationIt.remove();</div><div class="line">                    prevPatchOperation = null;</div><div class="line">                &#125; else &#123;</div><div class="line">                    prevPatchOperation = patchOperation;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                prevPatchOperation = patchOperation;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 最后记录我们的结果。</div><div class="line">        patchOperationIt = this.patchOperationList.iterator();</div><div class="line">        while (patchOperationIt.hasNext()) &#123;</div><div class="line">            PatchOperation&lt;T&gt; patchOperation = patchOperationIt.next();</div><div class="line">            switch (patchOperation.op) &#123;</div><div class="line">                case PatchOperation.OP_DEL: &#123;</div><div class="line">                    indexToDelOperationMap.put(patchOperation.index, patchOperation);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case PatchOperation.OP_ADD: &#123;</div><div class="line">                    indexToAddOperationMap.put(patchOperation.index, patchOperation);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                case PatchOperation.OP_REPLACE: &#123;</div><div class="line">                    indexToReplaceOperationMap.put(patchOperation.index, patchOperation);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在我们生成了patch的List之后，那么需要将各个类别的patch添加到一个生成的新dex文件中。按照dex文件格式，及计算出来的各个类别的offse，进行写入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">private void writeResultToStream(OutputStream os) throws IOException &#123;</div><div class="line">        DexDataBuffer buffer = new DexDataBuffer();</div><div class="line">        buffer.write(DexPatchFile.MAGIC);</div><div class="line">        buffer.writeShort(DexPatchFile.CURRENT_VERSION);</div><div class="line">        buffer.writeInt(this.patchedDexSize);</div><div class="line">        // we will return here to write firstChunkOffset later.</div><div class="line">        int posOfFirstChunkOffsetField = buffer.position();</div><div class="line">        buffer.writeInt(0);</div><div class="line">        buffer.writeInt(this.patchedStringIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedTypeIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedProtoIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedFieldIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedMethodIdsOffset);</div><div class="line">        buffer.writeInt(this.patchedClassDefsOffset);</div><div class="line">        buffer.writeInt(this.patchedMapListOffset);</div><div class="line">        buffer.writeInt(this.patchedTypeListsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationSetRefListItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationSetItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedClassDataItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedCodeItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedStringDataItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedDebugInfoItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedEncodedArrayItemsOffset);</div><div class="line">        buffer.writeInt(this.patchedAnnotationsDirectoryItemsOffset);</div><div class="line">        buffer.write(this.oldDex.computeSignature(false));</div><div class="line">        int firstChunkOffset = buffer.position();</div><div class="line">        buffer.position(posOfFirstChunkOffsetField);</div><div class="line">        buffer.writeInt(firstChunkOffset);</div><div class="line">        buffer.position(firstChunkOffset);</div><div class="line"></div><div class="line">        writePatchOperations(buffer, this.stringDataSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.typeIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.typeListSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.protoIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.fieldIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.methodIdSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationSetSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationSetRefListSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.annotationsDirectorySectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.debugInfoSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.codeSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.classDataSectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.encodedArraySectionDiffAlg.getPatchOperationList());</div><div class="line">        writePatchOperations(buffer, this.classDefSectionDiffAlg.getPatchOperationList());</div><div class="line"></div><div class="line">        byte[] bufferData = buffer.array();</div><div class="line">        os.write(bufferData);</div><div class="line">        os.flush();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>现在patch文件已经生成，但是这个生成的仅仅只是一个临时的patch文件。名称为我们的输出目录/tempPatchedDexes,这个dex文件并不能够被传统的dex解析器解析出来，因为tinker在生成时添加的MAGIC标识为public static final byte[] MAGIC = {0x44, 0x58, 0x44, 0x49, 0x46, 0x46}，对应的dex文件内容为DXDIFF，这个是用来标识这个dex是一个diff过的dex，需要进行替换或添加。在patch进行更新的时候需要对这个MAGIC进行替换。现在回到tinkerPatch，看看tinker是如何从临时文件，生成patch成功的apk文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> protected void tinkerPatch() &#123;</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch begin-----------------------&quot;);</div><div class="line"></div><div class="line">        Logger.d(config.toString());</div><div class="line">        try &#123;</div><div class="line">            //gen patch</div><div class="line">            ApkDecoder decoder = new ApkDecoder(config);</div><div class="line">            decoder.onAllPatchesStart();</div><div class="line">            decoder.patch(config.mOldApkFile, config.mNewApkFile);</div><div class="line">            decoder.onAllPatchesEnd();</div><div class="line"></div><div class="line">            //gen meta file and version file</div><div class="line">            PatchInfo info = new PatchInfo(config);</div><div class="line">            info.gen();</div><div class="line"></div><div class="line">            //重新生成patch文件。</div><div class="line">            PatchBuilder builder = new PatchBuilder(config);</div><div class="line">            builder.buildPatch();</div><div class="line"></div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">            goToError();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Logger.d(&quot;Tinker patch done, total time cost: %fs&quot;, diffTimeFromBegin());</div><div class="line">        Logger.d(&quot;Tinker patch done, you can go to file to find the output %s&quot;, config.mOutFolder);</div><div class="line">        Logger.d(&quot;-----------------------Tinker patch end-------------------------&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=========》</div><div class="line"> public PatchBuilder(Configuration config) &#123;</div><div class="line">        this.config = config;</div><div class="line">        this.unSignedApk = new File(config.mOutFolder, PATCH_NAME + &quot;_unsigned.apk&quot;);</div><div class="line">        this.signedApk = new File(config.mOutFolder, PATCH_NAME + &quot;_signed.apk&quot;);</div><div class="line">        this.signedWith7ZipApk = new File(config.mOutFolder, PATCH_NAME + &quot;_signed_7zip.apk&quot;);</div><div class="line">        this.sevenZipOutPutDir = new File(config.mOutFolder, TypedValue.OUT_7ZIP_FILE_PATH);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">======》</div><div class="line">public void buildPatch() throws Exception &#123;</div><div class="line">	....</div><div class="line">        generateUnsignedApk(unSignedApk);</div><div class="line">        signApk(unSignedApk, signedApk);</div><div class="line">        use7zApk(signedApk, signedWith7ZipApk, sevenZipOutPutDir);</div><div class="line">	....</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>上面的几个apk文件名都是在tinker patch执行完毕之后会生成的几个文件。在buildPatch中，只要的过程就三个，受限生成unSignedApk，然后对生成的unsignedApk进行签名，最后对生成signedApk利用7zip压缩，生成7zip apk包。这个就是tinker生成patch的全过程。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/xiejl.github.io/2017/08/13/0813DataBinding的实现原理/" rel="next" title="Android DataBinding的实现原理">
                <i class="fa fa-chevron-left"></i> Android DataBinding的实现原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/xiejl.github.io/2017/09/13/0914IntentService使用/" rel="prev" title="intentService实现原理">
                intentService实现原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/xiejl.github.io/images/avatar.gif"
               alt="phiCoo" />
          <p class="site-author-name" itemprop="name">phiCoo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/xiejl.github.io/archives">
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#gradle修改"><span class="nav-number">1.</span> <span class="nav-text">gradle修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gradle引入依赖修改"><span class="nav-number">1.1.</span> <span class="nav-text">gradle引入依赖修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gradle添加生成patch文件的task任务"><span class="nav-number">1.2.</span> <span class="nav-text">gradle添加生成patch文件的task任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application文件修改"><span class="nav-number">2.</span> <span class="nav-text">Application文件修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行更新"><span class="nav-number">3.</span> <span class="nav-text">执行更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tinker修复过程"><span class="nav-number">4.</span> <span class="nav-text">tinker修复过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tinker生成patch原理"><span class="nav-number">5.</span> <span class="nav-text">tinker生成patch原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dex文件格式"><span class="nav-number">5.1.</span> <span class="nav-text">dex文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tinker-dex文件的生成"><span class="nav-number">5.2.</span> <span class="nav-text">tinker dex文件的生成</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">phiCoo</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/xiejl.github.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/xiejl.github.io/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/xiejl.github.io/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/xiejl.github.io/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/xiejl.github.io/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
