<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/xiejl.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/xiejl.github.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/xiejl.github.io/favicon.ico?v=5.1.0" />






<meta name="description" content="recyclerView简介自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：1A flexible view for providing a limit">
<meta property="og:type" content="article">
<meta property="og:title" content="recyclerView源码解析">
<meta property="og:url" content="https://xiejinlong.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/index.html">
<meta property="og:site_name" content="沉迷学习却日渐发福">
<meta property="og:description" content="recyclerView简介自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：1A flexible view for providing a limit">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png">
<meta property="og:updated_time" content="2017-07-02T04:30:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="recyclerView源码解析">
<meta name="twitter:description" content="recyclerView简介自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：1A flexible view for providing a limit">
<meta name="twitter:image" content="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/xiejl.github.io/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiejinlong.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/"/>





  <title> recyclerView源码解析 | 沉迷学习却日渐发福 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/xiejl.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沉迷学习却日渐发福</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我会笑着迎接每一天</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/xiejl.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/xiejl.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/xiejl.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="phiCoo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沉迷学习却日渐发福">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                recyclerView源码解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T13:14:52+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="recyclerView简介"><a href="#recyclerView简介" class="headerlink" title="recyclerView简介"></a>recyclerView简介</h1><p>自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A flexible view for providing a limited window into a large data set。</div></pre></td></tr></table></figure><br>即，在一个有限的窗口显示大量的数据集的一个复杂的View，简单的说，就是可以通过这个RecyclerView以列表的形式将大量的数据显示出来。</p>
<h1 id="recyclerView简单相关"><a href="#recyclerView简单相关" class="headerlink" title="recyclerView简单相关"></a>recyclerView简单相关</h1><h1 id="recyclerView的简单用法"><a href="#recyclerView的简单用法" class="headerlink" title="recyclerView的简单用法"></a>recyclerView的简单用法</h1><p>其实recylerview使用起来也很方便，主要分成了以下几个组件：</p>
<ul>
<li>Adapter：对于数据集的处理都是在adapter中去完成。</li>
<li>ViewHolder：对于每一个列表项的表现形式，利用viewHolder来减少findViewById的次数，是recyclerView操作的基本单位</li>
<li>LayoutManager：recyclerView对于每一个Item的排列，显示，回收大部分都是通过layoutmanager来处理的。</li>
</ul>
<ol>
<li>在代码中设置布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//recyclerView布局</div><div class="line">&lt;android.support.v7.widget.RecyclerView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:id=&quot;@+id/recycler_id&quot;&gt;</div><div class="line"></div><div class="line">    &lt;/android.support.v7.widget.RecyclerView&gt;</div><div class="line"></div><div class="line">//RecyclerView的每一项的布局</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;xiexie&quot;</div><div class="line">        android:id=&quot;@+id/test_item&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></li>
<li>自定义adapter，里面必须包含ViewHolder实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class AdapterTest extends RecyclerView.Adapter&lt;AdapterTest.Holds&gt; &#123;</div><div class="line"></div><div class="line">    private LayoutInflater layoutInflater;</div><div class="line">    private List&lt;String&gt; userNames = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public AdapterTest(LayoutInflater layoutInflater, List&lt;String&gt; userNames) &#123;</div><div class="line">        this.layoutInflater = layoutInflater;</div><div class="line">        this.userNames = userNames;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public AdapterTest.Holds onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        return new Holds(layoutInflater.inflate(R.layout.username_list, null));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(Holds holder, int position) &#123;</div><div class="line">        holder.textView.setText(userNames.get(position));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return userNames.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class Holds extends RecyclerView.ViewHolder &#123;</div><div class="line">        public TextView textView;</div><div class="line"></div><div class="line">        public Holds(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            textView = (TextView) itemView.findViewById(R.id.test_item);</div><div class="line">            textView.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(View v) &#123;</div><div class="line">                    Log.d(&quot;XJL&quot;, &quot;hahaha&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>最后，只要在初始化recyclerView的地方相应的设置adapter和layoutManager就可以了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">     recyclerView = (RecyclerView)findViewById(R.id.recycler_id);</div><div class="line">        layoutManager = new LinearLayoutManager(this);</div><div class="line">        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);</div><div class="line">        initData();</div><div class="line">        recyclerView.setAdapter(new AdapterTest(getLayoutInflater(), userNames));</div><div class="line">        recyclerView.setLayoutManager(layoutManager);</div><div class="line">        </div><div class="line">        </div><div class="line">private void initData() &#123;</div><div class="line">        userNames = new ArrayList&lt;&gt;();</div><div class="line">        userNames.add(&quot;xiexie1&quot;);</div><div class="line">        userNames.add(&quot;xiexie2&quot;);</div><div class="line">        userNames.add(&quot;xiexie3&quot;);</div><div class="line">        userNames.add(&quot;xiexie4&quot;);</div><div class="line">        userNames.add(&quot;xiexie5&quot;);</div></pre></td></tr></table></figure>
这样，一个可见的列表就构建出来了。</li>
</ol>
<h2 id="recylerView简单流程"><a href="#recylerView简单流程" class="headerlink" title="recylerView简单流程"></a>recylerView简单流程</h2><p>对于一个recyclerView的显示过程，在不通过源码时，我们应该也要有一个直观的认识，也就是对于我们的adapter，我们需要实现哪几个方法？为什么我们需要实现那几个方法？<br>我们下面来看看这几个方法以及相应的流程。</p>
<p>当一个RecyclerView显示时，其中的每一个Item项，也就是ViewHolder，在有多个不同的item类型时，几个方法调用的顺序是这样的:<br>getItemViewType()—–&gt;onCreateViewHolder()——&gt;onBindViewHolder()—-&gt;<br>首先，在getItemViewType中会通过position来获取这个item的类型，然后会通过onCreateViewHolder，来创建相应的ViewHolder，这里仅仅只是创建出这个ViewHolder，里面的数据仍然是空的。最后在onBindViewHolder中进行position数据绑定。对于一个已经创建过的Viewholder，这个类型会被缓存，用来下次的复用。所以，在我们的滑动过程中，基本上每个类型的ViewHolder只会相应的调用一次，在滑动时只需要调用onBindViewHolder。</p>
<h2 id="recyclerView源码入口"><a href="#recyclerView源码入口" class="headerlink" title="recyclerView源码入口:"></a>recyclerView源码入口:</h2><p>我们先来看看recyclerView的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class RecyclerView </div><div class="line">extends ViewGroup implements ScrollingView, NestedScrollingChild</div></pre></td></tr></table></figure><br>通过这个类的定义，我们可以知道对于recyclerView来说，我们并不需要自己去处理滑动冲突，recyclerView已经为我们处理好了。</p>
<h3 id="一些recyclerView的相关定义"><a href="#一些recyclerView的相关定义" class="headerlink" title="一些recyclerView的相关定义"></a>一些recyclerView的相关定义</h3><ul>
<li>Adapter：是RecyclerView.Adapter的子类，用来放置显示的数据集，必须实现。</li>
<li>Position：数据项在Adapter中的位置</li>
<li>Index：可见的子View的位置项</li>
<li>Bingding：用来处理正在准备显示的子View的数据对应于adapter的位置</li>
<li>Recycler：是recyclerview的一个缓冲区，这个缓冲区里面缓存的view加入需要重用的话，必须要利用adapter重新绑定数据。</li>
<li>scrap：是recyclerview的一个缓存区，是指里面缓存的view是接下来需要用到的，里面绑定的数据无需更改，可以直接拿过来使用。是一个轻量级的缓存集合。</li>
<li>dirty：一个被认为是脏的视图，即数据进行修改过，之后如果需要显示必须重新绑定数据。</li>
</ul>
<p>我们直接从调用的过程来阅读,也就是recyclerView的创建和setAdapter这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void setAdapter(Adapter adapter) &#123;</div><div class="line">        // bail out if layout is frozen</div><div class="line">        setLayoutFrozen(false);</div><div class="line">        setAdapterInternal(adapter, false, true);</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在这个方法里面，首先会调用setLayoutFrozen(false)，setLayoutFrozen这个方法主要是layout和scroll滑动的使能开关，一旦设置为true之后，layout将不能更新也不能滑动，同样也不能响应点击事件。置为false，开启使能开关。<br>然后调用setAdapterInternal方法区进行adapter替换，同时开启监听。<br>然后调用setAdapterInternal():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</div><div class="line">           boolean removeAndRecycleViews) &#123;</div><div class="line">       if (mAdapter != null) &#123;</div><div class="line">           mAdapter.unregisterAdapterDataObserver(mObserver);</div><div class="line">           mAdapter.onDetachedFromRecyclerView(this);</div><div class="line">       &#125;</div><div class="line">       if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</div><div class="line">           if (mItemAnimator != null) &#123;</div><div class="line">               mItemAnimator.endAnimations();</div><div class="line">           &#125;</div><div class="line">           if (mLayout != null) &#123;</div><div class="line">               mLayout.removeAndRecycleAllViews(mRecycler);</div><div class="line">               mLayout.removeAndRecycleScrapInt(mRecycler);</div><div class="line">           &#125;</div><div class="line">           // we should clear it here before adapters are swapped to ensure correct callbacks.</div><div class="line">           mRecycler.clear();</div><div class="line">       &#125;</div><div class="line">       mAdapterHelper.reset();</div><div class="line">       final Adapter oldAdapter = mAdapter;</div><div class="line">       mAdapter = adapter;</div><div class="line">       if (adapter != null) &#123;</div><div class="line">           adapter.registerAdapterDataObserver(mObserver);</div><div class="line">           adapter.onAttachedToRecyclerView(this);</div><div class="line">       &#125;</div><div class="line">       if (mLayout != null) &#123;</div><div class="line">           mLayout.onAdapterChanged(oldAdapter, mAdapter);</div><div class="line">       &#125;</div><div class="line">       mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</div><div class="line">       mState.mStructureChanged = true;</div><div class="line">       markKnownViewsInvalid();</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在这个方法里面，首先会进行一系列的清空操作。然后重置adapterHelper，再进行一系列的初始化绑定操作。onAdapterChange这个方法这个会清除缓冲区，重新绘制数据和view类型。<br>后面调用mReycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious)方法，会创建出一个新的recyclerPool并且绑定上新的adapter。我们在这里可以看看里面做的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> void onAdapterChanged(Adapter oldAdapter, Adapter newAdapter,</div><div class="line">                boolean compatibleWithPrevious) &#123;</div><div class="line">            clear();</div><div class="line">            getRecycledViewPool().onAdapterChanged(oldAdapter, newAdapter, compatibleWithPrevious);</div><div class="line">        &#125;</div><div class="line">====&gt;clear()</div><div class="line">public void clear() &#123;</div><div class="line">	    //清空当前屏幕显示的view</div><div class="line">            mAttachedScrap.clear();</div><div class="line">	   //回收缓存的ViewHolder</div><div class="line">            recycleAndClearCachedViews();</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>所以，这里做了一系列的缓存清空操作。那么这些缓存都是什么呢？在这里，我们先来看看这些缓存的结构定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;ViewHolder&gt;();</div><div class="line">private ArrayList&lt;ViewHolder&gt; mChangedScrap = null;</div><div class="line">final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();</div><div class="line">private RecycledViewPool mRecyclerPool；</div></pre></td></tr></table></figure></p>
<ul>
<li>mAttachedScrap：用于屏幕内itemview的快速重用，即该ViewHolder列表仍未与RecyclerView分离,仍然处于显示的状态</li>
<li>mChangedScrap：与RecyclerView分离的ViewHolder列表，表示这个Viewholder仍然处于显示状态，但是已经被标记为需要重新绑定数据了</li>
<li>mCachedViews： 用于缓存屏幕外的两个itemview，最近刚被抛弃的两个Viewholder，即刚不显示的ViewHolder，默认缓存个数，上下各一个。</li>
<li>mRecyclerPool:提供复用的ViewHolder池，默认上限为5个</li>
<li>mViewCacheExtension：让开发者自主控制ViewHolder缓存。</li>
</ul>
<p>我们先来了解下这几个缓存的区别，<br>如果这个ViewHolder仍然在RecyclerView的可视范围内，而且是可以重用的，合法的，没有被移除的，那么这个ViewHolder会被加入到mAttachedScrap这个列表中。<br>如果这个ViewHolder项已经被标记更新过了，比如说我们在代码中notifyItem()，而且这个item是在屏幕内的，那么这个ViewHolder就被标记了需要被更新。<br>如果一个ViewHolder刚刚被移除出可见范围，那么将会被添加到mCacheView中，这个默认会缓存屏幕之外的两个ViewHolder。<br>如果mCacheView已经满了，当再添加一个新的移除的ViewHolder，那么会以lru的方式，将最早添加到这个列表的ViewHolder移除，并添加到RecyclerPool缓存。<br>mViewCacheExtension是recycler提供给我们们的自定义缓存机制，这个是第三级缓存，在recyclerPool之前，在mcacheView之后，默认的是空实现。</p>
<p>在recyclerView中，所谓的大部分的复用机制，几乎都是通过ViewHolder的type复用，然后在再次显示的时候重新绑定数据，最简单的说，就是跳过了onCreateViewHolder这一个步骤，只调用了onBindViewHolder。</p>
<p>我们再来看看另外一个基本可以调用到的方法，setLayoutManager:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void setLayoutManager(LayoutManager layout) &#123;</div><div class="line">        if (layout == mLayout) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">	//做一系列的清空操作，如果之前有layoutManager，则移除，然后更新为当前的layoutManager</div><div class="line">        if (mLayout != null) &#123;</div><div class="line">            if (mIsAttached) &#123;</div><div class="line">                mLayout.dispatchDetachedFromWindow(this, mRecycler);</div><div class="line">            &#125;</div><div class="line">            mLayout.setRecyclerView(null);</div><div class="line">        &#125;</div><div class="line">        mRecycler.clear();</div><div class="line">        mChildHelper.removeAllViewsUnfiltered();</div><div class="line">        mLayout = layout;</div><div class="line">        if (layout != null) &#123;</div><div class="line">            if (layout.mRecyclerView != null) &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +</div><div class="line">                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);</div><div class="line">            &#125;</div><div class="line">            mLayout.setRecyclerView(this);</div><div class="line">            if (mIsAttached) &#123;</div><div class="line">                mLayout.dispatchAttachedToWindow(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>虽然这个方法也没做什么实质性的东西，但是我们必须先有一个清楚的认识，recyclerView对于子item的排列管理，显示回收都是通过layoutManager来处理的。</p>
<h2 id="RecyclerView源码2"><a href="#RecyclerView源码2" class="headerlink" title="RecyclerView源码2"></a>RecyclerView源码2</h2><p>在这里，我们再通过recyclerView的构造函数入手：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public RecyclerView(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RecyclerView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>我们先看下这个三个构造函数，最早接触自定义view的时候，我并不知道为什么每个自定义view都要实现3个构造函数，你是不是也不清楚呢？其实吧，自定义view的每个构造函数都对应一个创建这个view的方式。</p>
<ul>
<li>RecyclerView(Context context): 这种方式以context作为参数，主要是用在代码中初始化的。像我们在代码中以new的方式创建出一个view对象时，只需要传入一个context。</li>
<li>RecyclerView(Context context, @Nullable AttributeSet attrs)：这种方式主要是用来在xml文件中初始化的，attrs参数便是我们在xml所设置的一些属性参数。</li>
<li>RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) : 同样也是在xml里面使用，不过多了一个style设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</div><div class="line">       super(context, attrs, defStyle);</div><div class="line">       setScrollContainer(true);</div><div class="line">       setFocusableInTouchMode(true);</div><div class="line">       final int version = Build.VERSION.SDK_INT;</div><div class="line">       mPostUpdatesOnAnimation = version &gt;= 16;</div><div class="line"></div><div class="line">       final ViewConfiguration vc = ViewConfiguration.get(context);</div><div class="line">       mTouchSlop = vc.getScaledTouchSlop();</div><div class="line">       mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();</div><div class="line">       mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();</div><div class="line">       setWillNotDraw(ViewCompat.getOverScrollMode(this) == ViewCompat.OVER_SCROLL_NEVER);</div><div class="line"></div><div class="line">       mItemAnimator.setListener(mItemAnimatorListener);</div><div class="line">       initAdapterManager();</div><div class="line">       initChildrenHelper();</div><div class="line">       // If not explicitly specified this view is important for accessibility.</div><div class="line">       if (ViewCompat.getImportantForAccessibility(this)</div><div class="line">               == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</div><div class="line">           ViewCompat.setImportantForAccessibility(this,</div><div class="line">                   ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</div><div class="line">       &#125;</div><div class="line">       mAccessibilityManager = (AccessibilityManager) getContext()</div><div class="line">               .getSystemService(Context.ACCESSIBILITY_SERVICE);</div><div class="line">       setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));</div><div class="line">       // Create the layoutManager if specified.</div><div class="line">       if (attrs != null) &#123;</div><div class="line">           int defStyleRes = 0;</div><div class="line">           TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</div><div class="line">                   defStyle, defStyleRes);</div><div class="line">           String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);</div><div class="line">           a.recycle();</div><div class="line">           createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       mScrollingChildHelper = new NestedScrollingChildHelper(this);</div><div class="line">       setNestedScrollingEnabled(true);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
在这个构造函数里面，recyclerView也只是做了一些基本的设置，并没有做实际的操作，recyclerView就相当于一个自定义View，它的实际的操作正是在自定义View的三大步骤中去做的，也就是onMeasure-&gt;onLayout-&gt;onDraw，下面我们就通过这个三个函数来了解recyclerView<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</div><div class="line">        //如果在measure时更新了Adapter</div><div class="line">	if (mAdapterUpdateDuringMeasure) &#123;</div><div class="line">            eatRequestLayout();</div><div class="line">            processAdapterUpdatesAndSetAnimationFlags();</div><div class="line"></div><div class="line">            if (mState.mRunPredictiveAnimations) &#123;</div><div class="line">                mState.mInPreLayout = true;</div><div class="line">            &#125; else &#123;</div><div class="line">                mAdapterHelper.consumeUpdatesInOnePass();</div><div class="line">                mState.mInPreLayout = false;</div><div class="line">            &#125;</div><div class="line">            mAdapterUpdateDuringMeasure = false;</div><div class="line">            resumeRequestLayout(false);</div><div class="line">        &#125;</div><div class="line">        if (mAdapter != null) &#123;</div><div class="line">            mState.mItemCount = mAdapter.getItemCount();</div><div class="line">        &#125; else &#123;</div><div class="line">            mState.mItemCount = 0;</div><div class="line">        &#125;</div><div class="line">        if (mLayout == null) &#123;</div><div class="line">            defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">        &#125; else &#123;</div><div class="line">	    //对于onmeasure托管给了LayoutManager去计算</div><div class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mState.mInPreLayout = false; // clear</div><div class="line">    &#125;</div><div class="line">====&gt;mlayout.onMeasure</div><div class="line"> public void onMeasure(Recycler recycler, State state, int widthSpec, int heightSpec) &#123;</div><div class="line">            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">        &#125;</div><div class="line">=====&gt;mRecyclerView.defaultOnmeasure</div><div class="line"> private void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</div><div class="line">        final int widthMode = MeasureSpec.getMode(widthSpec);</div><div class="line">        final int heightMode = MeasureSpec.getMode(heightSpec);</div><div class="line">        final int widthSize = MeasureSpec.getSize(widthSpec);</div><div class="line">        final int heightSize = MeasureSpec.getSize(heightSpec);</div><div class="line"></div><div class="line">        int width = 0;</div><div class="line">        int height = 0;</div><div class="line">	//对宽高的模式进行计算</div><div class="line">        switch (widthMode) &#123;</div><div class="line">            case MeasureSpec.EXACTLY:</div><div class="line">            case MeasureSpec.AT_MOST:</div><div class="line">                width = widthSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.UNSPECIFIED:</div><div class="line">            default:</div><div class="line">                width = ViewCompat.getMinimumWidth(this);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (heightMode) &#123;</div><div class="line">            case MeasureSpec.EXACTLY:</div><div class="line">            case MeasureSpec.AT_MOST:</div><div class="line">                height = heightSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.UNSPECIFIED:</div><div class="line">            default:</div><div class="line">                height = ViewCompat.getMinimumHeight(this);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line">====&gt;</div><div class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        //计算实际的宽高，通过set的宽高和marging</div><div class="line">	boolean optical = isLayoutModeOptical(this);</div><div class="line">        if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            int opticalWidth  = insets.left + insets.right;</div><div class="line">            int opticalHeight = insets.top  + insets.bottom;</div><div class="line"></div><div class="line">            measuredWidth  += optical ? opticalWidth  : -opticalWidth;</div><div class="line">            measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class="line">        &#125;</div><div class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line"> private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        mMeasuredWidth = measuredWidth;</div><div class="line">        mMeasuredHeight = measuredHeight;</div><div class="line"></div><div class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
上面就是onMeasure的整个计算过程，现在我们来看看onLayout这个方法的处理，这个方法会比较复杂，因为onLayout的计算不仅仅只是要计算整个RecyclerView的位置，而且需要去计算每个子item的位置。我们详细的看看这段代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"> protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        eatRequestLayout();</div><div class="line">	//traceCompat是用来跟踪系统性能的，beginsection和endsection需要成对出现</div><div class="line">        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</div><div class="line">        dispatchLayout();</div><div class="line">        TraceCompat.endSection();</div><div class="line">        resumeRequestLayout(false);</div><div class="line">        mFirstLayoutComplete = true;</div><div class="line">    &#125;</div><div class="line">====&gt;下面来看看dispatchLayout，这个是最主要的方法</div><div class="line">void dispatchLayout() &#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    //获取当前layout计算时，item的最小和最大的position</div><div class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</div><div class="line">    step0:寻找所有的未移除的item</div><div class="line">    int count = mChildHelper.getChildCount();</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</div><div class="line">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</div><div class="line">                	//如果这个item需要被忽略或者是不合法的，则直接跳过   </div><div class="line">			 continue;</div><div class="line">                &#125;</div><div class="line">                final ItemHolderInfo animationInfo = mItemAnimator</div><div class="line">                        .recordPreLayoutInformation(mState, holder,</div><div class="line">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</div><div class="line">                                holder.getUnmodifiedPayloads());</div><div class="line">                mViewInfoStore.addToPreLayout(holder, animationInfo);</div><div class="line">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</div><div class="line">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</div><div class="line">                    long key = getChangedHolderKey(holder);</div><div class="line">                    //满足下面条件的holder将会被添加到oldChangeHoder里面</div><div class="line">                    //1.处于隐藏状态但是仍未删除的vh</div><div class="line">                    //2.隐藏的vh但是数据已经修改过了</div><div class="line">                    //3.layoutmanager想在pre-layout中进行layout计算的item</div><div class="line">                    mViewInfoStore.addToOldChangeHolders(key, holder);</div><div class="line">                    </div><div class="line">    step1:执行预布局，利用先前position所对应的item，layoutmanager想要布局所有东西，甚至是已经移除的item。会返回pre-layout位置所对应的APPEARING view，这种标记的view是相当于真正的layout的一部分。</div><div class="line">	    //保存这个ViewHolder之前的位置</div><div class="line">            saveOldPositions();</div><div class="line">            final boolean didStructureChange = mState.mStructureChanged;</div><div class="line">            mState.mStructureChanged = false;</div><div class="line">            //在这里对子元素去进行预布局的计算，这里就需要依据LayoutManager的具体实现类来进行计算，因为是预布局，我们需要将mStructureChanged设置为false</div><div class="line">	    mLayout.onLayoutChildren(mRecycler, mState);</div><div class="line">            mState.mStructureChanged = didStructureChange;</div><div class="line">		</div><div class="line">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</div><div class="line">                final View child = mChildHelper.getChildAt(i);</div><div class="line">                final ViewHolder viewHolder = getChildViewHolderInt(child);</div><div class="line">                if (viewHolder.shouldIgnore()) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</div><div class="line">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</div><div class="line">                    boolean wasHidden = viewHolder</div><div class="line">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</div><div class="line">                    if (!wasHidden) &#123;</div><div class="line">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</div><div class="line">                    &#125;</div><div class="line">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</div><div class="line">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</div><div class="line">                    if (wasHidden) &#123;</div><div class="line">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            clearOldPositions();</div><div class="line">            mAdapterHelper.consumePostponedUpdates();</div><div class="line">        &#125; else &#123;</div><div class="line">            clearOldPositions();</div><div class="line">        &#125;</div><div class="line">        mState.mItemCount = mAdapter.getItemCount();</div><div class="line">        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</div><div class="line"> 	//step2:pre-layout计算已经执行完毕,真正的进行layout计算</div><div class="line">	mState.mInPreLayout = false;</div><div class="line">        mLayout.onLayoutChildren(mRecycler, mState);</div><div class="line"></div><div class="line">        mState.mStructureChanged = false;</div><div class="line">        mPendingSavedState = null;</div><div class="line"></div><div class="line">        if (mState.mRunSimpleAnimations) &#123;</div><div class="line">            // Step 3: 计算viewHolder所在的位置</div><div class="line">            int count = mChildHelper.getChildCount();</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</div><div class="line">                if (holder.shouldIgnore()) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">		//获取当前这个holder的position</div><div class="line">                long key = getChangedHolderKey(holder);</div><div class="line">                //获取当前viewHolder所对应的animation</div><div class="line">		final ItemHolderInfo animationInfo = mItemAnimator</div><div class="line">                        .recordPostLayoutInformation(mState, holder);</div><div class="line">		//获取这个position之前对应的viewholder</div><div class="line">                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</div><div class="line">                if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</div><div class="line">                    //执行切换动画</div><div class="line">                    final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</div><div class="line">                            oldChangeViewHolder);</div><div class="line">                    animateChange(oldChangeViewHolder, holder, preInfo, animationInfo);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Step 4: 执行Viewinfo和监听animation</div><div class="line">            mViewInfoStore.process(mViewInfoProcessCallback);</div><div class="line">        &#125;</div><div class="line">        resumeRequestLayout(false);</div><div class="line">	//对mRecycler做一次清空操作</div><div class="line">        mLayout.removeAndRecycleScrapInt(mRecycler);</div><div class="line">        mState.mPreviousLayoutItemCount = mState.mItemCount;</div><div class="line">        mDataSetHasChangedAfterLayout = false;</div><div class="line">        mState.mRunSimpleAnimations = false;</div><div class="line"></div><div class="line">        mState.mRunPredictiveAnimations = false;</div><div class="line">        onExitLayoutOrScroll();</div><div class="line">        mLayout.mRequestedSimpleAnimations = false;</div><div class="line">        if (mRecycler.mChangedScrap != null) &#123;</div><div class="line">            mRecycler.mChangedScrap.clear();</div><div class="line">        &#125;</div><div class="line">        mViewInfoStore.clear();</div><div class="line">        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</div><div class="line">           //如果这个recyclerView的position区间是正确的，那么移动到当前的第一个位置 </div><div class="line">	   dispatchOnScrolled(0, 0);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
recyclerView的onLayout仅仅只是做了部分计算，对于其子item的计算托管给了layoutManager，下面我们来看看这个LayoutManager的计算，我们必须先了解一下这个layoutManager，它是一个抽象类，对于不同的实现类会有不同的实现，对于LinearLayoutManager和GridLayoutManager的实现就有很多不一样了。这里我们查看的是linearLayoutManager的源码，在看这个源码时我们先了解下其中的layout计算算法。这个源码中给我们标注出来的：</li>
</ul>
<ol>
<li>检查子item和其他变量，找到其中的anchor，anchor算是一个计算的锚点，指定的从哪个一个position开始进行计算。</li>
<li>从start方向开始填充，item从bottom开始出栈</li>
<li>从end方向开始填充，item从start开始出栈</li>
<li>通过滑动去满足要求。<br>下面我们来看看下面这张图的表示，这个图并非原创，在网上看到了，感觉画得还行<br><img src="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt=""><br>下面就是这个算法所对应的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"> public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">       //确认Layout方向，即orientation设置的方向</div><div class="line">ensureLayoutState();</div><div class="line">       mLayoutState.mRecycle = false;</div><div class="line">       // 真正的加载方向，因为linearLayoutManager有一个setReverse方法，这个会让整个recyclerView反向加载，所以需要通过设置的方向和这个方法值共同来判断</div><div class="line">       resolveShouldLayoutReverse();</div><div class="line">//初始化Anchor信息</div><div class="line">       mAnchorInfo.reset();</div><div class="line">//anchor方向</div><div class="line">       mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</div><div class="line">       // 计算anchor位置</div><div class="line">       updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</div><div class="line">       //LLM会有一个extra空间用来缓存item，可以用来进行预加载</div><div class="line">int extraForStart;</div><div class="line">       int extraForEnd;</div><div class="line">//我们可以重写getExtraLayoutSpac这个方法用来进行额外的显示空间，默认为0</div><div class="line">       final int extra = getExtraLayoutSpace(state);</div><div class="line">       //最近一次滑动的距离，大于0，表示向下滑动</div><div class="line">if (mLayoutState.mLastScrollDelta &gt;= 0) &#123;</div><div class="line">           extraForEnd = extra;</div><div class="line">           extraForStart = 0;</div><div class="line">       &#125; else &#123;</div><div class="line">           extraForStart = extra;</div><div class="line">           extraForEnd = 0;</div><div class="line">       &#125;</div><div class="line">       extraForStart += mOrientationHelper.getStartAfterPadding();</div><div class="line">       extraForEnd += mOrientationHelper.getEndPadding();</div><div class="line">       if (state.isPreLayout() &amp;&amp; mPendingScrollPosition != NO_POSITION &amp;&amp;</div><div class="line">               mPendingScrollPositionOffset != INVALID_OFFSET) &#123;</div><div class="line">    //如果是在预布局中，需要执行下面</div><div class="line">           final View existing = findViewByPosition(mPendingScrollPosition);</div><div class="line">           if (existing != null) &#123;</div><div class="line">               final int current;</div><div class="line">               final int upcomingOffset;</div><div class="line">               if (mShouldReverseLayout) &#123;</div><div class="line">                   current = mOrientationHelper.getEndAfterPadding() -</div><div class="line">                           mOrientationHelper.getDecoratedEnd(existing);</div><div class="line">                   upcomingOffset = current - mPendingScrollPositionOffset;</div><div class="line">               &#125; else &#123;</div><div class="line">                   current = mOrientationHelper.getDecoratedStart(existing)</div><div class="line">                           - mOrientationHelper.getStartAfterPadding();</div><div class="line">                   upcomingOffset = mPendingScrollPositionOffset - current;</div><div class="line">               &#125;</div><div class="line">               if (upcomingOffset &gt; 0) &#123;</div><div class="line">	    //额外滑动距离大于0，额外的空间需要加上计算之后的滑动距离</div><div class="line">                   extraForStart += upcomingOffset;</div><div class="line">               &#125; else &#123;</div><div class="line">                   extraForEnd -= upcomingOffset;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       int startOffset;</div><div class="line">       int endOffset;</div><div class="line">//判断这个锚点是否已经准备完毕。默认为空实现，只有在gridLayoutManager才需要复写</div><div class="line">       onAnchorReady(recycler, state, mAnchorInfo);</div><div class="line">//这个是关于layout的过程中缓存的计算，我们后面会详细的讲解这个函数</div><div class="line">       detachAndScrapAttachedViews(recycler);</div><div class="line">       mLayoutState.mIsPreLayout = state.isPreLayout();</div><div class="line">       if (mAnchorInfo.mLayoutFromEnd) &#123;</div><div class="line">    //如果是从start方向开始填充，更新LayoutState信息，这个是一个辅助layoutManager来管理滑动的类</div><div class="line">           updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForStart;</div><div class="line">    //在这个方法里面填充item</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           startOffset = mLayoutState.mOffset;</div><div class="line">           final int firstElement = mLayoutState.mCurrentPosition;</div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForEnd += mLayoutState.mAvailable;</div><div class="line">           &#125;</div><div class="line">           // 从end方向开始填充</div><div class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForEnd;</div><div class="line">           mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">           //在这个方法里面填充item</div><div class="line">    fill(recycler, mLayoutState, state, false);</div><div class="line">           endOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">	//底部没有足够的item用于填充满整个布局，此时再从顶部添加item进行填充	</div><div class="line">               extraForStart = mLayoutState.mAvailable;</div><div class="line">               updateLayoutStateToFillStart(firstElement, startOffset);</div><div class="line">               mLayoutState.mExtra = extraForStart;</div><div class="line">	fill(recycler, mLayoutState, state, false);</div><div class="line">               startOffset = mLayoutState.mOffset;</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">    //与上面的基本一致，只是因为start和end方向反了而已</div><div class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForEnd;</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           endOffset = mLayoutState.mOffset;</div><div class="line">           final int lastElement = mLayoutState.mCurrentPosition;</div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForStart += mLayoutState.mAvailable;</div><div class="line">           &#125;</div><div class="line">           // fill towards start</div><div class="line">           updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForStart;</div><div class="line">           mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           startOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForEnd = mLayoutState.mAvailable;</div><div class="line">               updateLayoutStateToFillEnd(lastElement, endOffset);</div><div class="line">               mLayoutState.mExtra = extraForEnd;</div><div class="line">               fill(recycler, mLayoutState, state, false);</div><div class="line">               endOffset = mLayoutState.mOffset;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (getChildCount() &gt; 0) &#123;</div><div class="line">    //对于不同的加载方向，计算偏移量</div><div class="line">           if (mShouldReverseLayout ^ mStackFromEnd) &#123;</div><div class="line">	startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">               fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">           &#125; else &#123;</div><div class="line">               int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">               fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</div><div class="line">       if (!state.isPreLayout()) &#123;</div><div class="line">           mPendingScrollPosition = NO_POSITION;</div><div class="line">           mPendingScrollPositionOffset = INVALID_OFFSET;</div><div class="line">           mOrientationHelper.onLayoutComplete();</div><div class="line">       &#125;</div><div class="line">       mLastStackFromEnd = mStackFromEnd;</div><div class="line">       mPendingSavedState = null;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
上面就是LinearLayoutManager的layout计算，我们来看看这个填充函数fill的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</div><div class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</div><div class="line">	 final int start = layoutState.mAvailable;</div><div class="line">	//最大偏移量就是scroll距离加上可达的距离</div><div class="line">        if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">            if (layoutState.mAvailable &lt; 0) &#123;</div><div class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</div><div class="line">            &#125;</div><div class="line">	    //在这里回收缓存不可见的item</div><div class="line">            recycleByLayoutState(recycler, layoutState);</div><div class="line">        &#125;</div><div class="line">	//剩余空间计算，可见的加上设置的extra空间再加上滑动所生成offset</div><div class="line">        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;</div><div class="line">        LayoutChunkResult layoutChunkResult = new LayoutChunkResult();</div><div class="line">        while (remainingSpace &gt; 0 &amp;&amp; layoutState.hasMore(state)) &#123;</div><div class="line">            layoutChunkResult.resetInternal();</div><div class="line">	    //通过layoutChunk计算大小距离，下面我们会简单的看下这个函数</div><div class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</div><div class="line">            if (layoutChunkResult.mFinished) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</div><div class="line">            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null</div><div class="line">                    || !state.isPreLayout()) &#123;</div><div class="line">               	//计算剩下的可用空间， </div><div class="line">		layoutState.mAvailable -= layoutChunkResult.mConsumed;</div><div class="line">                remainingSpace -= layoutChunkResult.mConsumed;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</div><div class="line">                if (layoutState.mAvailable &lt; 0) &#123;</div><div class="line">                    layoutState.mScrollingOffset += layoutState.mAvailable;</div><div class="line">                &#125;</div><div class="line">                recycleByLayoutState(recycler, layoutState);</div><div class="line">            &#125;</div><div class="line">            if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return start - layoutState.mAvailable;</div></pre></td></tr></table></figure>
我们可以看到在这个fill函数中，它将计算又交给了layoutChunk，我们现在看看layoutChunk这个函数的具体计算<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</div><div class="line">            LayoutState layoutState, LayoutChunkResult result) &#123;</div><div class="line">        //首先会尝试从scraplist里面获取view，如果这个position与我们当前需要显示的position一致，那么直接返回,否则，将会从几个缓存区中获取，获取缓存的view我们后面讲解</div><div class="line">	View view = layoutState.next(recycler);</div><div class="line">        if (view == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        LayoutParams params = (LayoutParams) view.getLayoutParams();</div><div class="line">        if (layoutState.mScrapList == null) &#123;</div><div class="line">	    //如果这个scraplist为空，那么这个view是需要显示的</div><div class="line">            if (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">                    == LayoutState.LAYOUT_START)) &#123;</div><div class="line">                addView(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                addView(view, 0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">	    //这个view是标记为invisible的</div><div class="line">            if (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">                    == LayoutState.LAYOUT_START)) &#123;</div><div class="line">                addDisappearingView(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                addDisappearingView(view, 0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	//计算margin值，用来进行排列</div><div class="line">        measureChildWithMargins(view, 0, 0);</div><div class="line">	//这个会计算当前view的decoration占用的位置和margin总值</div><div class="line">        result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</div><div class="line">        int left, top, right, bottom;</div><div class="line">        if (mOrientation == VERTICAL) &#123;</div><div class="line">            if (isLayoutRTL()) &#123;</div><div class="line">                right = getWidth() - getPaddingRight();</div><div class="line">                left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                left = getPaddingLeft();</div><div class="line">                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">            &#125;</div><div class="line">            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">	        bottom = layoutState.mOffset;</div><div class="line">                top = layoutState.mOffset - result.mConsumed;</div><div class="line">            &#125; else &#123;</div><div class="line">		//我们只分析垂直摆放，而且方向是初始从上至下的，那么top高度为当前的offset，bottom值为当前的offset加上前面计算的占用大小</div><div class="line">                top = layoutState.mOffset;</div><div class="line">                bottom = layoutState.mOffset + result.mConsumed;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            top = getPaddingTop();</div><div class="line">            bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line"></div><div class="line">            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">                right = layoutState.mOffset;</div><div class="line">                left = layoutState.mOffset - result.mConsumed;</div><div class="line">            &#125; else &#123;</div><div class="line">                left = layoutState.mOffset;</div><div class="line">                right = layoutState.mOffset + result.mConsumed;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	//为了能够正确的计算，我们还需要对子view进行layout计算。</div><div class="line">        layoutDecorated(view, left + params.leftMargin, top + params.topMargin,</div><div class="line">                right - params.rightMargin, bottom - params.bottomMargin);</div><div class="line">        &#125;</div><div class="line">        result.mFocusable = view.isFocusable();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
这就完成layout计算。</li>
</ol>
<h2 id="recyclerView滑动处理"><a href="#recyclerView滑动处理" class="headerlink" title="recyclerView滑动处理"></a>recyclerView滑动处理</h2><p>对于recyclerView的滑动，肯定是从我们的屏幕滑动去进行处理的。首先我们必须了解一下滑动事件的分发机制，对于这个分发机制，首先是从onDispatchTouchEvent传递，然后通过onInterceptTouchEvent判断是否拦截，如果拦截，这个事件就不会向下传递，而会传递的给自身的onTouchEvent去进行处理，如果想要了解详细的分发过程，google上有很多这个blog。我们直接通过其onInterceptTouchEvent阅读。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">public boolean onInterceptTouchEvent(MotionEvent e) &#123;</div><div class="line">       if (mLayoutFrozen) &#123;</div><div class="line">           	//如果layout处于frozen状态，那么这个recyclerView是不会拦截处理事件的。</div><div class="line">	return false;</div><div class="line">       &#125;</div><div class="line">       if (dispatchOnItemTouchIntercept(e)) &#123;</div><div class="line">           //这里会判断是否有子item监听这个事件，如果有，则直接将事件让子item去进行处理</div><div class="line">    cancelTouch();</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (mLayout == null) &#123;</div><div class="line">           return false;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       final boolean canScrollHorizontally = mLayout.canScrollHorizontally();</div><div class="line">       final boolean canScrollVertically = mLayout.canScrollVertically();</div><div class="line"></div><div class="line">       if (mVelocityTracker == null) &#123;</div><div class="line">          //初始化速度检测器 </div><div class="line">   mVelocityTracker = VelocityTracker.obtain();</div><div class="line">       &#125;</div><div class="line">       mVelocityTracker.addMovement(e);</div><div class="line"></div><div class="line">       final int action = MotionEventCompat.getActionMasked(e);</div><div class="line">       final int actionIndex = MotionEventCompat.getActionIndex(e);</div><div class="line"></div><div class="line">       switch (action) &#123;</div><div class="line">           case MotionEvent.ACTION_DOWN:</div><div class="line">               if (mIgnoreMotionEventTillDown) &#123;</div><div class="line">                   mIgnoreMotionEventTillDown = false;</div><div class="line">               &#125;</div><div class="line">               mScrollPointerId = e.getPointerId(0);</div><div class="line">               mInitialTouchX = mLastTouchX = (int) (e.getX() + 0.5f);</div><div class="line">               mInitialTouchY = mLastTouchY = (int) (e.getY() + 0.5f);</div><div class="line">	</div><div class="line">	//SCROLL_STATE_SETTLING是处于自动滚动的状态</div><div class="line">               if (mScrollState == SCROLL_STATE_SETTLING) &#123;</div><div class="line">	   //下面这个方法是解决滑动冲突最经常用的一个方法，也就是requestDisallowInterceptTouchEvent，这个方法可以禁止父控件去拦截这个方法</div><div class="line">                   getParent().requestDisallowInterceptTouchEvent(true);</div><div class="line">	    //因为现在是actionDown事件，所以，scroll状态要开始变为dragging事件</div><div class="line">                   setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               //mark: 清空nested的偏移量</div><div class="line">               mNestedOffsets[0] = mNestedOffsets[1] = 0;</div><div class="line"></div><div class="line">	//初始化nestScroll方向</div><div class="line">               int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</div><div class="line">               if (canScrollHorizontally) &#123;</div><div class="line">                   nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</div><div class="line">               &#125;</div><div class="line">               if (canScrollVertically) &#123;</div><div class="line">                   nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</div><div class="line">               &#125;</div><div class="line">	//在这里开启nest滑动</div><div class="line">               startNestedScroll(nestedScrollAxis);</div><div class="line">               break;</div><div class="line"></div><div class="line">           case MotionEventCompat.ACTION_POINTER_DOWN:</div><div class="line">               mScrollPointerId = e.getPointerId(actionIndex);</div><div class="line">               mInitialTouchX = mLastTouchX = (int) (e.getX(actionIndex) + 0.5f);</div><div class="line">               mInitialTouchY = mLastTouchY = (int) (e.getY(actionIndex) + 0.5f);</div><div class="line">               break;</div><div class="line"></div><div class="line">          case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">               final int index = e.findPointerIndex(mScrollPointerId);</div><div class="line">	//获取滑动的point</div><div class="line">               if (index &lt; 0) &#123;</div><div class="line">                   Log.e(TAG, &quot;Error processing scroll; pointer index for id &quot; +</div><div class="line">                           mScrollPointerId + &quot; not found. Did any MotionEvents get skipped?&quot;);</div><div class="line">                   return false;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">               final int x = (int) (e.getX(index) + 0.5f);</div><div class="line">               final int y = (int) (e.getY(index) + 0.5f);</div><div class="line">               if (mScrollState != SCROLL_STATE_DRAGGING) &#123;</div><div class="line">    		    //如果Move事件不是Dragging状态，那么down时一定处于idle状态</div><div class="line">                   final int dx = x - mInitialTouchX;</div><div class="line">                   final int dy = y - mInitialTouchY;</div><div class="line">                   boolean startScroll = false;</div><div class="line">                   if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</div><div class="line">                       mLastTouchX = mInitialTouchX + mTouchSlop * (dx &lt; 0 ? -1 : 1);</div><div class="line">                       startScroll = true;</div><div class="line">                   &#125;</div><div class="line">                   if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">                       mLastTouchY = mInitialTouchY + mTouchSlop * (dy &lt; 0 ? -1 : 1);</div><div class="line">                       startScroll = true;</div><div class="line">                   &#125;</div><div class="line">                   if (startScroll) &#123;</div><div class="line">                       setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125; break;</div><div class="line"></div><div class="line">           case MotionEventCompat.ACTION_POINTER_UP: &#123;</div><div class="line">               onPointerUp(e);</div><div class="line">           &#125; break;</div><div class="line"></div><div class="line">           case MotionEvent.ACTION_UP: &#123;</div><div class="line">               mVelocityTracker.clear();</div><div class="line">	//关掉nestScroll</div><div class="line">               stopNestedScroll();</div><div class="line">           &#125; break;</div><div class="line"></div><div class="line">           case MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">               cancelTouch();</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return mScrollState == SCROLL_STATE_DRAGGING;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>从上面的代码段中，我们可以看到，在InterceptTouchEvent中只是做了一些Scroll状态的切换，真正的事件处理是在onTouchEvent中处理.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public boolean onTouchEvent(MotionEvent e) &#123;</div><div class="line">	...</div><div class="line">        final boolean canScrollHorizontally = mLayout.canScrollHorizontally();</div><div class="line">        final boolean canScrollVertically = mLayout.canScrollVertically();</div><div class="line"></div><div class="line">        if (mVelocityTracker == null) &#123;</div><div class="line">            mVelocityTracker = VelocityTracker.obtain();</div><div class="line">        &#125;</div><div class="line">        boolean eventAddedToVelocityTracker = false;</div><div class="line">	//复制一个事件，用于处理速度的处理</div><div class="line">        final MotionEvent vtev = MotionEvent.obtain(e);</div><div class="line">        final int action = MotionEventCompat.getActionMasked(e);</div><div class="line">        final int actionIndex = MotionEventCompat.getActionIndex(e);</div><div class="line"></div><div class="line">        if (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">             如果是Down事件，则将nest偏移量清空</div><div class="line">	     mNestedOffsets[0] = mNestedOffsets[1] = 0;</div><div class="line">        &#125;</div><div class="line">	/／对速度相关的处理事件进行设置起始位置</div><div class="line">        vtev.offsetLocation(mNestedOffsets[0], mNestedOffsets[1]);</div><div class="line"></div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                //这一部分操作基本和onInterceptTouchEvent中的一致</div><div class="line">		mScrollPointerId = e.getPointerId(0);</div><div class="line">                mInitialTouchX = mLastTouchX = (int) (e.getX() + 0.5f);</div><div class="line">                mInitialTouchY = mLastTouchY = (int) (e.getY() + 0.5f);</div><div class="line"></div><div class="line">                int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</div><div class="line">                if (canScrollHorizontally) &#123;</div><div class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</div><div class="line">                &#125;</div><div class="line">                if (canScrollVertically) &#123;</div><div class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</div><div class="line">                &#125;</div><div class="line">                startNestedScroll(nestedScrollAxis);</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEventCompat.ACTION_POINTER_DOWN: &#123;</div><div class="line">                mScrollPointerId = e.getPointerId(actionIndex);</div><div class="line">                mInitialTouchX = mLastTouchX = (int) (e.getX(actionIndex) + 0.5f);</div><div class="line">                mInitialTouchY = mLastTouchY = (int) (e.getY(actionIndex) + 0.5f);</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                final int index = e.findPointerIndex(mScrollPointerId);</div><div class="line">                if (index &lt; 0) &#123;</div><div class="line">                    Log.e(TAG, &quot;Error processing scroll; pointer index for id &quot; +</div><div class="line">                            mScrollPointerId + &quot; not found. Did any MotionEvents get skipped?&quot;);</div><div class="line">                    return false;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                final int x = (int) (e.getX(index) + 0.5f);</div><div class="line">                final int y = (int) (e.getY(index) + 0.5f);</div><div class="line">                //dy和dy就是我们计算的move事件的偏移量</div><div class="line">	        int dx = mLastTouchX - x;</div><div class="line">                int dy = mLastTouchY - y;</div><div class="line">		//dispatchNestedPreScroll，这个方法会计算parent，也就是这个recycler是否在nest滑动中需也要消费空间,也就是recyclerView也会移动，为true表示需要消费空间，消费值存放在mScrollConsumed和mScroollOffset中</div><div class="line">                if (dispatchNestedPreScroll(dx, dy, mScrollConsumed, mScrollOffset)) &#123;</div><div class="line">                    dx -= mScrollConsumed[0];</div><div class="line">                    dy -= mScrollConsumed[1];</div><div class="line">                    vtev.offsetLocation(mScrollOffset[0], mScrollOffset[1]);</div><div class="line">                    // 更新nest滑动的offset</div><div class="line">                    mNestedOffsets[0] += mScrollOffset[0];</div><div class="line">                    mNestedOffsets[1] += mScrollOffset[1];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (mScrollState != SCROLL_STATE_DRAGGING) &#123;</div><div class="line">                    //如果滑动状态不是Dragging，那么down时的状态一定是idle</div><div class="line">		    boolean startScroll = false;</div><div class="line">		    //计算真实的偏移量</div><div class="line">                    if (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</div><div class="line">                        if (dx &gt; 0) &#123;</div><div class="line">                            dx -= mTouchSlop;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            dx += mTouchSlop;</div><div class="line">                        &#125;</div><div class="line">                        startScroll = true;</div><div class="line">                    &#125;</div><div class="line">                    if (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</div><div class="line">                        if (dy &gt; 0) &#123;</div><div class="line">                            dy -= mTouchSlop;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            dy += mTouchSlop;</div><div class="line">                        &#125;</div><div class="line">                        startScroll = true;</div><div class="line">                    &#125;</div><div class="line">                    if (startScroll) &#123;</div><div class="line">                        setScrollState(SCROLL_STATE_DRAGGING);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//如果此时已经是拖动状态</div><div class="line">                if (mScrollState == SCROLL_STATE_DRAGGING) &#123;</div><div class="line">                    //标记最后一次点击坐标为当前坐标减去nest滑动的偏移量</div><div class="line">		    mLastTouchX = x - mScrollOffset[0];</div><div class="line">                    mLastTouchY = y - mScrollOffset[1];</div><div class="line">		    //在这里进行内部item的滑动处理，这个方法后面我们会详细的阅读</div><div class="line">                    if (scrollByInternal(</div><div class="line">                            canScrollHorizontally ? dx : 0,</div><div class="line">                            canScrollVertically ? dy : 0,</div><div class="line">                            vtev)) &#123;</div><div class="line">                        getParent().requestDisallowInterceptTouchEvent(true);</div><div class="line">                    &#125;</div><div class="line">                    if (mGapWorker != null &amp;&amp; (dx != 0 || dy != 0)) &#123;</div><div class="line">                        mGapWorker.postFromTraversal(this, dx, dy);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEventCompat.ACTION_POINTER_UP: &#123;</div><div class="line">                onPointerUp(e);</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_UP: &#123;</div><div class="line">		//手指离开屏幕时，触发这个事件，</div><div class="line">                mVelocityTracker.addMovement(vtev);</div><div class="line">                eventAddedToVelocityTracker = true;</div><div class="line">		//计算当前的速度，1000速度的单位，mMaxFlingVelocity是速度的最大值</div><div class="line">                mVelocityTracker.computeCurrentVelocity(1000, mMaxFlingVelocity);</div><div class="line">                final float xvel = canScrollHorizontally ?</div><div class="line">                        -VelocityTrackerCompat.getXVelocity(mVelocityTracker, mScrollPointerId) : 0;</div><div class="line">                final float yvel = canScrollVertically ?</div><div class="line">                        -VelocityTrackerCompat.getYVelocity(mVelocityTracker, mScrollPointerId) : 0;</div><div class="line">        	//如果存在自滑动的速度，就进行fling操作，否则直接设置当前状态为idle状态，这个fling方法后面我们也会详细的阅读。       </div><div class="line">        	 if (!((xvel != 0 || yvel != 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</div><div class="line">                    setScrollState(SCROLL_STATE_IDLE);</div><div class="line">                &#125;</div><div class="line">                resetTouch();</div><div class="line">            &#125; break;</div><div class="line"></div><div class="line">            case MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">                cancelTouch();</div><div class="line">            &#125; break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!eventAddedToVelocityTracker) &#123;</div><div class="line">            mVelocityTracker.addMovement(vtev);</div><div class="line">        &#125;</div><div class="line">        vtev.recycle();</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>实际上，在这个onTouchEvent里面滑动处理主要就做了两件事情，也就是scrollByInternal和fling这两个操作，scrollByInternal是在我们的move事件去实时处理的，而fling事件是在我们的up事件时，如果存在自滑动的速度，那么就会执行这个方法。下面我们先看看scrollByInternal这个item的滑动处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">boolean scrollByInternal(int x, int y, MotionEvent ev) &#123;</div><div class="line">       int unconsumedX = 0, unconsumedY = 0;</div><div class="line">       int consumedX = 0, consumedY = 0;</div><div class="line">//在这里会判断layout操作是否执行完毕，否则需要等待。</div><div class="line">       consumePendingUpdateOperations();</div><div class="line">//adapter不为空，在里面真正的执行滑动</div><div class="line">       if (mAdapter != null) &#123;</div><div class="line">           eatRequestLayout();</div><div class="line">           onEnterLayoutOrScroll();</div><div class="line">           TraceCompat.beginSection(TRACE_SCROLL_TAG);</div><div class="line">    //内部实际上调用了mLayout的滑动方法，会返回滑动消耗的距离</div><div class="line">           if (x != 0) &#123;</div><div class="line">               consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</div><div class="line">               unconsumedX = x - consumedX;</div><div class="line">           &#125;</div><div class="line">           if (y != 0) &#123;</div><div class="line">               consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</div><div class="line">               unconsumedY = y - consumedY;</div><div class="line">           &#125;</div><div class="line">           TraceCompat.endSection();</div><div class="line">           repositionShadowingViews();</div><div class="line">           onExitLayoutOrScroll();</div><div class="line">           resumeRequestLayout(false);</div><div class="line">       &#125;</div><div class="line">       if (!mItemDecorations.isEmpty()) &#123;</div><div class="line">           invalidate();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</div><div class="line">           // 通过滑动消耗的距离和未消耗完的距离进行更新最后一次点击的位置</div><div class="line">           mLastTouchX -= mScrollOffset[0];</div><div class="line">           mLastTouchY -= mScrollOffset[1];</div><div class="line">           if (ev != null) &#123;</div><div class="line">               ev.offsetLocation(mScrollOffset[0], mScrollOffset[1]);</div><div class="line">           &#125;</div><div class="line">           mNestedOffsets[0] += mScrollOffset[0];</div><div class="line">           mNestedOffsets[1] += mScrollOffset[1];</div><div class="line">       &#125; else if (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</div><div class="line">           if (ev != null) &#123;</div><div class="line">               pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);</div><div class="line">           &#125;</div><div class="line">           considerReleasingGlowsOnScroll(x, y);</div><div class="line">       &#125;</div><div class="line">       if (consumedX != 0 || consumedY != 0) &#123;</div><div class="line">            //通知滑动事件，也就是我们所监听的onscrollChangeListener</div><div class="line">     dispatchOnScrolled(consumedX, consumedY);</div><div class="line">       &#125;</div><div class="line">//在这里进行重新绘制</div><div class="line">       if (!awakenScrollBars()) &#123;</div><div class="line">           invalidate();</div><div class="line">       &#125;</div><div class="line">       return consumedX != 0 || consumedY != 0;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在这里，我们又要重申一句话，recyclerView并不负责子item的摆放，这也就是为什么在滑动处理事件里面又将滑动处理交给了对应的layoutManager去计算，我们来看看LinearLayoutManager的scrollVerticalBy方法的调用链<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,</div><div class="line">            RecyclerView.State state) &#123;</div><div class="line">        if (mOrientation == HORIZONTAL) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        return scrollBy(dy, recycler, state);</div><div class="line">    &#125;</div><div class="line">=======&gt;调用到了scrollBy</div><div class="line">int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">        if (getChildCount() == 0 || dy == 0) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mRecycle = true;</div><div class="line">	//确保LayoutSate存在，不存在就新建一个</div><div class="line">        ensureLayoutState();</div><div class="line">	//在这里计算填充方向</div><div class="line">        final int layoutDirection = dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</div><div class="line">        final int absDy = Math.abs(dy);</div><div class="line">	//更新layoutState的状态，这个实际上就是进行计算滑动距离	</div><div class="line">        updateLayoutState(layoutDirection, absDy, true, state);</div><div class="line">	//计算消费的空间</div><div class="line">        final int consumed = mLayoutState.mScrollingOffset</div><div class="line">                + fill(recycler, mLayoutState, state, false);</div><div class="line">        if (consumed &lt; 0) &#123;</div><div class="line">            if (DEBUG) &#123;</div><div class="line">                Log.d(TAG, &quot;Don&apos;t have any more elements to scroll&quot;);</div><div class="line">            &#125;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">	//计算真正的滑动距离</div><div class="line">        final int scrolled = absDy &gt; consumed ? layoutDirection * consumed : dy;</div><div class="line">        mOrientationHelper.offsetChildren(-scrolled);</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            Log.d(TAG, &quot;scroll req: &quot; + dy + &quot; scrolled: &quot; + scrolled);</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mLastScrollDelta = scrolled;</div><div class="line">        return scrolled;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>真正的填充函数fill我们之前已经介绍过了，忘记的可以往前翻。我们在看看updateLayoutState这个函数，这个函数用于更新当前的layoutState状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">private void updateLayoutState(int layoutDirection, int requiredSpace,</div><div class="line">            boolean canUseExistingSpace, RecyclerView.State state) &#123;</div><div class="line">        mLayoutState.mInfinite = resolveIsInfinite();</div><div class="line">	//计算额外的缓存空间</div><div class="line">        mLayoutState.mExtra = getExtraLayoutSpace(state);</div><div class="line">        mLayoutState.mLayoutDirection = layoutDirection;</div><div class="line">        int scrollingOffset;</div><div class="line">	//下面是重点计算的scroll偏移量</div><div class="line">        if (layoutDirection == LayoutState.LAYOUT_END) &#123;</div><div class="line">            //如果是向上滑动，则要从底部填充</div><div class="line">	    //额外的缓存空间也要加上padding值</div><div class="line">	    mLayoutState.mExtra += mOrientationHelper.getEndPadding();</div><div class="line">	    //获取当前最靠近底部的一个子item</div><div class="line">            final View child = getChildClosestToEnd();</div><div class="line">	    //这里计算当前的添加方向，如果没有设置reverseLayout的话，默认添加到Tail，也就是尾部，值为1</div><div class="line">            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD</div><div class="line">                    : LayoutState.ITEM_DIRECTION_TAIL;</div><div class="line">	    //计算当前要显示的位置，也就是前面最靠近底部的item加上前面的itemDirection，也就是当前position了。</div><div class="line">            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;</div><div class="line">            //计算最后一个item的距离底部的偏移量</div><div class="line">	    mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);</div><div class="line">            //计算在没有添加子item的时候，我们可以滑动的偏移量</div><div class="line">	    scrollingOffset = mOrientationHelper.getDecoratedEnd(child)</div><div class="line">                    - mOrientationHelper.getEndAfterPadding();</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line">	    //这个计算和上面的类似</div><div class="line">            final View child = getChildClosestToStart();</div><div class="line">            mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();</div><div class="line">            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL</div><div class="line">                    : LayoutState.ITEM_DIRECTION_HEAD;</div><div class="line">            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;</div><div class="line">            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);</div><div class="line">            scrollingOffset = -mOrientationHelper.getDecoratedStart(child)</div><div class="line">                    + mOrientationHelper.getStartAfterPadding();</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mAvailable = requiredSpace;</div><div class="line">        if (canUseExistingSpace) &#123;</div><div class="line">     	      //计算生剩余的可用空间</div><div class="line">	      mLayoutState.mAvailable -= scrollingOffset;</div><div class="line">        &#125;</div><div class="line">        mLayoutState.mScrollingOffset = scrollingOffset;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>通过这个方法计算了大部分需要的值之后，然后通过fill函数去进行填充新view和回收旧的view，这样，一个move操作就完成啦。下面看看另外一个处理自滑动的fling函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">public boolean fling(int velocityX, int velocityY) &#123;</div><div class="line">	...</div><div class="line">        if (velocityX == 0 &amp;&amp; velocityY == 0) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (!dispatchNestedPreFling(velocityX, velocityY)) &#123;</div><div class="line">	    //如果parent不消费这个fling事件，那么就需要子item来处理</div><div class="line">            final boolean canScroll = canScrollHorizontal || canScrollVertical;</div><div class="line">            dispatchNestedFling(velocityX, velocityY, canScroll);</div><div class="line">	    //onFlingListener是24.2版本添加的</div><div class="line">            if (mOnFlingListener != null &amp;&amp; mOnFlingListener.onFling(velocityX, velocityY)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (canScroll) &#123;</div><div class="line">		//如果可以滑动，进行滑动处理</div><div class="line">                velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity));</div><div class="line">                velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity));</div><div class="line">                mViewFlinger.fling(velocityX, velocityY);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">=====》mViewFLinger.fling</div><div class="line">public void fling(int velocityX, int velocityY) &#123;</div><div class="line">	    //标记为settling状态，也就是自动滚动状态</div><div class="line">            setScrollState(SCROLL_STATE_SETTLING);</div><div class="line">            mLastFlingX = mLastFlingY = 0;</div><div class="line">            mScroller.fling(0, 0, velocityX, velocityY,</div><div class="line">                    Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE);</div><div class="line">	  //计算完自滑动距离之后，通过post方法去执行移动。  </div><div class="line">          postOnAnimation();</div><div class="line">&#125;</div><div class="line">=====&gt; mScroller.fling</div><div class="line">public void fling(int startX, int startY, int velocityX, int velocityY,</div><div class="line">            int minX, int maxX, int minY, int maxY) &#123;</div><div class="line">        mScroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY);</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line">public void fling(int startX, int startY, int velocityX, int velocityY,</div><div class="line">            int minX, int maxX, int minY, int maxY) &#123;</div><div class="line">        fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY, 0, 0);</div><div class="line">    &#125;</div><div class="line">====&gt;</div><div class="line">public void fling(int startX, int startY, int velocityX, int velocityY,</div><div class="line">            int minX, int maxX, int minY, int maxY, int overX, int overY) &#123;</div><div class="line">        // 滚动处理</div><div class="line">        if (mFlywheel &amp;&amp; !isFinished()) &#123;</div><div class="line">            float oldVelocityX = mScrollerX.mCurrVelocity;</div><div class="line">            float oldVelocityY = mScrollerY.mCurrVelocity;</div><div class="line">	    //速度不为0时，速度就要进行变化</div><div class="line">	    //signum函数就是一个分段函数，等于0，返回0，大于0，返回1，小于0，返回-1</div><div class="line">            if (Math.signum(velocityX) == Math.signum(oldVelocityX) &amp;&amp;</div><div class="line">                    Math.signum(velocityY) == Math.signum(oldVelocityY)) &#123;</div><div class="line">                velocityX += oldVelocityX;</div><div class="line">                velocityY += oldVelocityY;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mMode = FLING_MODE;</div><div class="line">	//在这里进行滑动</div><div class="line">        mScrollerX.fling(startX, velocityX, minX, maxX, overX);</div><div class="line">        mScrollerY.fling(startY, velocityY, minY, maxY, overY);</div><div class="line">    &#125;</div><div class="line">======&gt;我们只看Y方向的滑动</div><div class="line">void fling(int start, int velocity, int min, int max, int over) &#123;</div><div class="line">            mOver = over;</div><div class="line">            mFinished = false;</div><div class="line">            mCurrVelocity = mVelocity = velocity;</div><div class="line">            mDuration = mSplineDuration = 0;</div><div class="line">            mStartTime = AnimationUtils.currentAnimationTimeMillis();</div><div class="line">            mCurrentPosition = mStart = start;</div><div class="line"></div><div class="line">            if (start &gt; max || start &lt; min) &#123;</div><div class="line">                startAfterEdge(start, min, max, velocity);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">	</div><div class="line">            mState = SPLINE;</div><div class="line">            double totalDistance = 0.0;</div><div class="line"></div><div class="line">            if (velocity != 0) &#123;</div><div class="line">		//计算曲线速度下降到0的时间，是一个对数函数</div><div class="line">                mDuration = mSplineDuration = getSplineFlingDuration(velocity);</div><div class="line">		//计算速度将为0的总距离</div><div class="line">                totalDistance = getSplineFlingDistance(velocity);</div><div class="line">            &#125;</div><div class="line">	    //总距离有正负方向</div><div class="line">            mSplineDistance = (int) (totalDistance * Math.signum(velocity));</div><div class="line">            //mFinal为终点位置</div><div class="line">	    mFinal = start + mSplineDistance;</div><div class="line"></div><div class="line">            // 如果终点位置最小的距离，那么调整终点位置为最小的距离</div><div class="line">            if (mFinal &lt; min) &#123;</div><div class="line">                adjustDuration(mStart, mFinal, min);</div><div class="line">                mFinal = min;</div><div class="line">            &#125;</div><div class="line">		</div><div class="line">            if (mFinal &gt; max) &#123;</div><div class="line">                adjustDuration(mStart, mFinal, max);</div><div class="line">                mFinal = max;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>在这个fling调用链中，其实最终的这个方法也只是进行计算而已，实际上这个相当于时一个动画，计算出速度降为0的时间就是动画执行的时间，速度降为0的时需要移动的总距离就是动画移动的总距离，SplineOverScroller就是这个动画的实体，它里面包含了执行动画所需的参数，动画的执行就和属性动画ValueAnimator十分类似，在每次调用computerScrollOffset方法时，就会调用update方法去更新动画的实时参数。我们看看最开始的postOnAmation，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void postOnAnimation() &#123;</div><div class="line">            if (mEatRunOnAnimationRequest) &#123;</div><div class="line">                mReSchedulePostAnimationCallback = true;</div><div class="line">            &#125; else &#123;</div><div class="line">                removeCallbacks(this);</div><div class="line">                ViewCompat.postOnAnimation(RecyclerView.this, this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>在默认的延迟时间到了之后，就会执行自身的run方法，我们来看看这个run方法的复杂处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line">public void run() &#123;</div><div class="line">            if (mLayout == null) &#123;</div><div class="line">                stop();</div><div class="line">                return; // no layout, cannot scroll.</div><div class="line">            &#125;</div><div class="line">	    //此时正在执行自动滚动动画，关掉其他自滚动的请求</div><div class="line">            disableRunOnAnimationRequests();</div><div class="line">	    //等待layout操作</div><div class="line">            consumePendingUpdateOperations();</div><div class="line">            // 将这个scroller存储为局部变量，以防它后面有变化</div><div class="line">            final ScrollerCompat scroller = mScroller;</div><div class="line">            final SmoothScroller smoothScroller = mLayout.mSmoothScroller;</div><div class="line">            if (scroller.computeScrollOffset()) &#123;</div><div class="line">		//计算滑动的偏移量</div><div class="line">                final int x = scroller.getCurrX();</div><div class="line">                final int y = scroller.getCurrY();</div><div class="line">                final int dx = x - mLastFlingX;</div><div class="line">                final int dy = y - mLastFlingY;</div><div class="line">                int hresult = 0;</div><div class="line">                int vresult = 0;</div><div class="line">                mLastFlingX = x;</div><div class="line">                mLastFlingY = y;</div><div class="line">                int overscrollX = 0, overscrollY = 0;</div><div class="line">                if (mAdapter != null) &#123;</div><div class="line">                    eatRequestLayout();</div><div class="line">                    onEnterLayoutOrScroll();</div><div class="line">                    TraceCompat.beginSection(TRACE_SCROLL_TAG);</div><div class="line">		    //滑动item处理交给layout执行,通过计算offset处理添加View和回收View</div><div class="line">                    if (dx != 0) &#123;</div><div class="line">                        hresult = mLayout.scrollHorizontallyBy(dx, mRecycler, mState);</div><div class="line">                        overscrollX = dx - hresult;</div><div class="line">                    &#125;</div><div class="line">                    if (dy != 0) &#123;</div><div class="line">                        vresult = mLayout.scrollVerticallyBy(dy, mRecycler, mState);</div><div class="line">                        overscrollY = dy - vresult;</div><div class="line">                    &#125;</div><div class="line">                    TraceCompat.endSection();</div><div class="line">                    repositionShadowingViews();</div><div class="line"></div><div class="line">                    onExitLayoutOrScroll();</div><div class="line">                    resumeRequestLayout(false);</div><div class="line">		    //smoothScroller来执行滚动动画</div><div class="line">                    if (smoothScroller != null &amp;&amp; !smoothScroller.isPendingInitialRun() &amp;&amp;</div><div class="line">                            smoothScroller.isRunning()) &#123;</div><div class="line">                        final int adapterSize = mState.getItemCount();</div><div class="line">                        if (adapterSize == 0) &#123;</div><div class="line">                            smoothScroller.stop();</div><div class="line">                        &#125; else if (smoothScroller.getTargetPosition() &gt;= adapterSize) &#123;</div><div class="line">                            smoothScroller.setTargetPosition(adapterSize - 1);</div><div class="line">                            smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</div><div class="line">                        &#125; else &#123;</div><div class="line">			    //在onAnimation会开启scroll动画</div><div class="line">                            smoothScroller.onAnimation(dx - overscrollX, dy - overscrollY);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//刷新ui</div><div class="line">                if (!mItemDecorations.isEmpty()) &#123;</div><div class="line">                    invalidate();</div><div class="line">                &#125;</div><div class="line">                if (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</div><div class="line">                    considerReleasingGlowsOnScroll(dx, dy);</div><div class="line">                &#125;</div><div class="line">                if (overscrollX != 0 || overscrollY != 0) &#123;</div><div class="line">             	    //获取当前的速度</div><div class="line">	            final int vel = (int) scroller.getCurrVelocity();</div><div class="line"></div><div class="line">                    int velX = 0;</div><div class="line">                    if (overscrollX != x) &#123;</div><div class="line">                        velX = overscrollX &lt; 0 ? -vel : overscrollX &gt; 0 ? vel : 0;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    int velY = 0;</div><div class="line">                    if (overscrollY != y) &#123;</div><div class="line">                        velY = overscrollY &lt; 0 ? -vel : overscrollY &gt; 0 ? vel : 0;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (getOverScrollMode() != View.OVER_SCROLL_NEVER) &#123;</div><div class="line">                        absorbGlows(velX, velY);</div><div class="line">                    &#125;</div><div class="line">                    if ((velX != 0 || overscrollX == x || scroller.getFinalX() == 0) &amp;&amp;</div><div class="line">                            (velY != 0 || overscrollY == y || scroller.getFinalY() == 0)) &#123;</div><div class="line">               		 //如果终点坐标为0，那么停止animation</div><div class="line">		         scroller.abortAnimation();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (hresult != 0 || vresult != 0) &#123;</div><div class="line">                    dispatchOnScrolled(hresult, vresult);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!awakenScrollBars()) &#123;</div><div class="line">                    invalidate();</div><div class="line">                &#125;</div><div class="line">		</div><div class="line">		//是否占用空间</div><div class="line">                final boolean fullyConsumedVertical = dy != 0 &amp;&amp; mLayout.canScrollVertically()</div><div class="line">                        &amp;&amp; vresult == dy;</div><div class="line">                final boolean fullyConsumedHorizontal = dx != 0 &amp;&amp; mLayout.canScrollHorizontally()</div><div class="line">                        &amp;&amp; hresult == dx;</div><div class="line">                final boolean fullyConsumedAny = (dx == 0 &amp;&amp; dy == 0) || fullyConsumedHorizontal</div><div class="line">                        || fullyConsumedVertical;</div><div class="line">		</div><div class="line">		//如果没有占用空间，而且滑动已经结束了</div><div class="line">                if (scroller.isFinished() || !fullyConsumedAny) &#123;</div><div class="line">                    setScrollState(SCROLL_STATE_IDLE);</div><div class="line">                    if (ALLOW_THREAD_GAP_WORK) &#123;</div><div class="line">                        mPrefetchRegistry.clearPrefetchPositions();</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    postOnAnimation();</div><div class="line">                    if (mGapWorker != null) &#123;</div><div class="line">                        mGapWorker.postFromTraversal(RecyclerView.this, dx, dy);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (smoothScroller != null) &#123;</div><div class="line">                if (smoothScroller.isPendingInitialRun()) &#123;</div><div class="line">                    smoothScroller.onAnimation(0, 0);</div><div class="line">                &#125;</div><div class="line">                if (!mReSchedulePostAnimationCallback) &#123;</div><div class="line">                    smoothScroller.stop(); //stop if it does not trigger any scroll</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    //执行结束后开启处理animation请求</div><div class="line">            enableRunOnAnimationRequests();</div><div class="line">        &#125;</div><div class="line">=====&gt;onAnimation</div><div class="line">private void onAnimation(int dx, int dy) &#123;</div><div class="line">            final RecyclerView recyclerView = mRecyclerView;</div><div class="line">            if (!mRunning || mTargetPosition == RecyclerView.NO_POSITION || recyclerView == null) &#123;</div><div class="line">                stop();</div><div class="line">            &#125;</div><div class="line">            mPendingInitialRun = false;</div><div class="line">            if (mTargetView != null) &#123;</div><div class="line">                if (getChildPosition(mTargetView) == mTargetPosition) &#123;</div><div class="line">                    onTargetFound(mTargetView, recyclerView.mState, mRecyclingAction);</div><div class="line">                    mRecyclingAction.runIfNecessary(recyclerView);</div><div class="line">                    stop();</div><div class="line">                &#125; else &#123;</div><div class="line">                    Log.e(TAG, &quot;Passed over target position while smooth scrolling.&quot;);</div><div class="line">                    mTargetView = null;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (mRunning) &#123;</div><div class="line">                onSeekTargetStep(dx, dy, recyclerView.mState, mRecyclingAction);</div><div class="line">                boolean hadJumpTarget = mRecyclingAction.hasJumpTarget();</div><div class="line">                //通过下面这个方法开启startScroll,内部会调用postAnimation循环调用动画，直到移动到目标位置或速度为0	</div><div class="line">	        mRecyclingAction.runIfNecessary(recyclerView);</div><div class="line">                if (hadJumpTarget) &#123;</div><div class="line">                    //判断是否移动到目标位置</div><div class="line">		    if (mRunning) &#123;</div><div class="line">                        mPendingInitialRun = true;</div><div class="line">                        recyclerView.mViewFlinger.postOnAnimation();</div><div class="line">                    &#125; else &#123;</div><div class="line">                        stop(); // done</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>对于smoothScroller和scroller这两种滚动方式，我们必须要有区分，scroller的移动是没有渐变过程的，对于一个移动，就是直接从start位置变化到我们设置的终点位置，而smoothScroller是不一样的，它对于移动会用一个变化的过程，例如linearLayoutmanager所用的scroll就用了Linearinterpolator，做一个匀速的变化过程。上面就是一个recyclerView的滚动全过程.</p>
<h2 id="recyclerView-缓存处理"><a href="#recyclerView-缓存处理" class="headerlink" title="recyclerView 缓存处理"></a>recyclerView 缓存处理</h2><p>在了解了recyclerView的滚动全过程之后，我们最后来阅读下recyclerView的缓存机制，也就是为什么recyclerView会优于listView的最主要原因。首先通过上一部分的滑动处理来进行阅读，即在scrollBy函数中调用fill函数，里面通过recycleByLayoutState回收不显示的View，通过layoutChunk从缓存中读取即将显示的View。那么回收和复用的过程究竟是如何呢？我们从源码中阅读，当然，首先应该从回收的地方阅读起，没有回收，哪里能复用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) &#123;</div><div class="line">        if (!layoutState.mRecycle || layoutState.mInfinite) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">	//通过判读现在加载的方向来确定回收的方向，如果从start方向加载，那么就应该从end方向回收，否则相反</div><div class="line">        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);</div><div class="line">        &#125; else &#123;</div><div class="line">            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=====&gt; recycleViewsFromEnd</div><div class="line">private void recycleViewsFromEnd(RecyclerView.Recycler recycler, int dt) &#123;</div><div class="line">     	//geChildCount获取的仅仅只是界面显示的子item数量</div><div class="line">        final int childCount = getChildCount();</div><div class="line">        ...</div><div class="line">	//计算最后一个item距离底部的距离减去需要滑动的距离，就是此时回收的总距离</div><div class="line">	final int limit = mOrientationHelper.getEnd() - dt;</div><div class="line">        if (mShouldReverseLayout) &#123;</div><div class="line">	    //通常不会设置reverse，所以我们从下面的else阅读</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                View child = getChildAt(i);</div><div class="line">                if (mOrientationHelper.getDecoratedStart(child) &lt; limit</div><div class="line">                        || mOrientationHelper.getTransformedStartWithDecoration(child) &lt; limit) &#123;</div><div class="line">                    // stop here</div><div class="line">                    recycleChildren(recycler, 0, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">	    //从最后一个子item开始进行回收</div><div class="line">            for (int i = childCount - 1; i &gt;= 0; i--) &#123;</div><div class="line">                View child = getChildAt(i);</div><div class="line">		//计算回收区间</div><div class="line">                if (mOrientationHelper.getDecoratedStart(child) &lt; limit</div><div class="line">                        || mOrientationHelper.getTransformedStartWithDecoration(child) &lt; limit) &#123;</div><div class="line">                    // 进行回收</div><div class="line">                    recycleChildren(recycler, childCount - 1, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=====&gt;recyclerChildren</div><div class="line">private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) &#123;</div><div class="line">        if (startIndex == endIndex) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (DEBUG) &#123;</div><div class="line">            Log.d(TAG, &quot;Recycling &quot; + Math.abs(startIndex - endIndex) + &quot; items&quot;);</div><div class="line">        &#125;</div><div class="line">        if (endIndex &gt; startIndex) &#123;</div><div class="line">	    //逐一回收</div><div class="line">            for (int i = endIndex - 1; i &gt;= startIndex; i--) &#123;</div><div class="line">                removeAndRecycleViewAt(i, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int i = startIndex; i &gt; endIndex; i--) &#123;</div><div class="line">                removeAndRecycleViewAt(i, recycler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">=====&gt;removeAndRecycleViewAt</div><div class="line">public void removeAndRecycleViewAt(int index, Recycler recycler) &#123;</div><div class="line">            final View view = getChildAt(index);</div><div class="line">            //移除这个View</div><div class="line">	    removeViewAt(index);</div><div class="line">	    //回收View</div><div class="line">            recycler.recycleView(view);</div><div class="line">        &#125;</div><div class="line">=====&gt;recycleView</div><div class="line"> public void recycleView(View view) &#123;</div><div class="line">            //获取这个View对应的ViewHolder</div><div class="line">	    ViewHolder holder = getChildViewHolderInt(view);</div><div class="line">            if (holder.isTmpDetached()) &#123;</div><div class="line">	        //如果这个holder被被标记为临时移除，那么首先从DetachedView中移除</div><div class="line">                removeDetachedView(view, false);</div><div class="line">            &#125;</div><div class="line">            if (holder.isScrap()) &#123;</div><div class="line">		//如果这个holder已经在scrap缓存里面了，那么从scrap列表中移除，scrap</div><div class="line">                holder.unScrap();</div><div class="line">            &#125; else if (holder.wasReturnedFromScrap())&#123;</div><div class="line">		//如果这个Viewholder标记为将会在scrap中重用，在移除时应该清除这个标记</div><div class="line">                holder.clearReturnedFromScrapFlag();</div><div class="line">            &#125;</div><div class="line">            recycleViewHolderInternal(holder);</div><div class="line">        &#125;</div><div class="line">=====&gt;recycleViewHolderInternal</div><div class="line">void recycleViewHolderInternal(ViewHolder holder) &#123;</div><div class="line">            ...</div><div class="line">            boolean cached = false;</div><div class="line">            boolean recycled = false;</div><div class="line">            ...</div><div class="line">	    if (forceRecycle || holder.isRecyclable()) &#123;</div><div class="line">                if (mViewCacheMax &gt; 0</div><div class="line">                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID</div><div class="line">                                | ViewHolder.FLAG_REMOVED</div><div class="line">                                | ViewHolder.FLAG_UPDATE</div><div class="line">                                | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123;</div><div class="line">		    //先移除最老的mcacheView，默认大小为2</div><div class="line">                    int cachedViewSize = mCachedViews.size();</div><div class="line">                    if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123;</div><div class="line">                        recycleCachedViewAt(0);</div><div class="line">                        cachedViewSize--;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    int targetCacheIndex = cachedViewSize;</div><div class="line">                    if (ALLOW_THREAD_GAP_WORK</div><div class="line">                            &amp;&amp; cachedViewSize &gt; 0</div><div class="line">                            &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123;</div><div class="line">                        int cacheIndex = cachedViewSize - 1;</div><div class="line">                        while (cacheIndex &gt;= 0) &#123;</div><div class="line">                            int cachedPos = mCachedViews.get(cacheIndex).mPosition;</div><div class="line">                            if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123;</div><div class="line">                     		   //如果有被预加载的position，那么直接添加到这个位置</div><div class="line">			           break;</div><div class="line">                            &#125;</div><div class="line">                            cacheIndex--;</div><div class="line">                        &#125;</div><div class="line">                        targetCacheIndex = cacheIndex + 1;</div><div class="line">                    &#125;</div><div class="line">                    mCachedViews.add(targetCacheIndex, holder);</div><div class="line">                    cached = true;</div><div class="line">                &#125;</div><div class="line">		//如果没有添加到cache里面，那么直接回收到Pool中</div><div class="line">                if (!cached) &#123;</div><div class="line">                    addViewHolderToRecycledViewPool(holder, true);</div><div class="line">                    recycled = true;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">            ...</div><div class="line">	    //在动画没执行完时，我们有可能会出现回收失败的情况，所以需要再进行移除</div><div class="line">	    mViewInfoStore.removeViewHolder(holder);</div><div class="line">            if (!cached &amp;&amp; !recycled &amp;&amp; transientStatePreventsRecycling) &#123;</div><div class="line">                holder.mOwnerRecyclerView = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">======&gt;recycleCachedViewAt</div><div class="line">void recycleCachedViewAt(int cachedViewIndex) &#123;</div><div class="line">            ...</div><div class="line">	    //获取这个cacheView中对应位置的ViewHolder</div><div class="line">	    ViewHolder viewHolder = mCachedViews.get(cachedViewIndex);</div><div class="line">            ...</div><div class="line">	    //添加到RecyclerViewPool</div><div class="line">	    addViewHolderToRecycledViewPool(viewHolder, true);</div><div class="line">            //移除cacheView中的这个ViewHolder</div><div class="line">	    mCachedViews.remove(cachedViewIndex);</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>通过这个回收时的过程，我们可以看到有两个缓存的列表，分别是mCacheViews和recyclerViewHolderPool，首先会缓存到mCacheViews中，然后以lru的方式将最先缓存的Viewholder移到pool中缓存。我们接下来看看复用机制,入口是layoutChunk的next函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line">View next(RecyclerView.Recycler recycler) &#123;</div><div class="line">            if (mScrapList != null) &#123;</div><div class="line">		//如果scrapList非空，直接从scrapList中进行复用</div><div class="line">		//我们必须了解下这个mScrapList的含义,这个并不是一个缓存列表,这个是一个不可以修改的可见的viewHolder列表，只有在onLayoutChild的过程中才会是非空的，在我们普通的滑动并不会非空。</div><div class="line">                return nextViewFromScrapList();</div><div class="line">            &#125;</div><div class="line">	    //真正的从缓存中复用</div><div class="line">            final View view = recycler.getViewForPosition(mCurrentPosition);</div><div class="line">            mCurrentPosition += mItemDirection;</div><div class="line">            return view;</div><div class="line">        &#125;</div><div class="line">======&gt;nextViewFromScrapList</div><div class="line">private View nextViewFromScrapList() &#123;</div><div class="line">            final int size = mScrapList.size();</div><div class="line">            for (int i = 0; i &lt; size; i++) &#123;</div><div class="line">                final View view = mScrapList.get(i).itemView;</div><div class="line">                final LayoutParams lp = (LayoutParams) view.getLayoutParams();</div><div class="line">                if (lp.isItemRemoved()) &#123;</div><div class="line">		    //如果这个view被标记为移除</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">		//如果这个View的position和当前要显示的position是一致的，将这个view返回</div><div class="line">                if (mCurrentPosition == lp.getViewLayoutPosition()) &#123;</div><div class="line">                    assignPositionFromScrapList(view);</div><div class="line">                    return view;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">=======&gt;recycler.getViewForPosition</div><div class="line">public View getViewForPosition(int position) &#123;</div><div class="line">            return getViewForPosition(position, false);</div><div class="line">        &#125;</div><div class="line">=====&gt;getViewForPosition(position, false)</div><div class="line">View getViewForPosition(int position, boolean dryRun) &#123;</div><div class="line">            return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</div><div class="line">        &#125;</div><div class="line">====&gt;tryGetViewHolderForPositionByDeadline</div><div class="line"> ViewHolder tryGetViewHolderForPositionByDeadline(int position,</div><div class="line">                boolean dryRun, long deadlineNs) &#123;</div><div class="line">            boolean fromScrapOrHiddenOrCache = false;</div><div class="line">            ViewHolder holder = null;</div><div class="line">            // 如果是在预布局中，判断这个position对应的Viewholder是否被添加到了changeScrap中,并获取出对应的viewholder</div><div class="line">            if (mState.isPreLayout()) &#123;</div><div class="line">                holder = getChangedScrapViewForPosition(position);</div><div class="line">                fromScrapOrHiddenOrCache = holder != null;</div><div class="line">            &#125;</div><div class="line">            // 按顺序从attachscrap列表，hidden列表，一级缓存列表中获取对应的viewholder</div><div class="line">            if (holder == null) &#123;</div><div class="line">                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</div><div class="line">                if (holder != null) &#123;</div><div class="line">                    if (!validateViewHolderForOffsetPosition(holder)) &#123;</div><div class="line">			//判断这个Viewholder在这个position上是否可用,此时不可用，需要回收</div><div class="line">                        if (!dryRun) &#123;</div><div class="line">                                removeDetachedView(holder.itemView, false);</div><div class="line">                                holder.unScrap();</div><div class="line">                            &#125; else if (holder.wasReturnedFromScrap()) &#123;</div><div class="line">                                holder.clearReturnedFromScrapFlag();</div><div class="line">                            &#125;</div><div class="line">                            recycleViewHolderInternal(holder);</div><div class="line">                        &#125;</div><div class="line">                        holder = null;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        fromScrapOrHiddenOrCache = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">	    //如果在上面没找到可用的Viewholder</div><div class="line">            if (holder == null) &#123;</div><div class="line">                final int offsetPosition = mAdapterHelper.findPositionOffset(position);</div><div class="line">		...</div><div class="line">		//获取这个position对应ViewType</div><div class="line">                final int type = mAdapter.getItemViewType(offsetPosition);</div><div class="line">                //如果这个position有对应的stableId,那么按序从mattachScrap和mCacheViews中寻找</div><div class="line">                if (mAdapter.hasStableIds()) &#123;</div><div class="line">                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</div><div class="line">                            type, dryRun);</div><div class="line">                    if (holder != null) &#123;</div><div class="line">                        // 找到相对应的holder，更新position</div><div class="line">                        holder.mPosition = offsetPosition;</div><div class="line">                        fromScrapOrHiddenOrCache = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//如果还没找到，从自定义的cacheExtension寻找</div><div class="line">                if (holder == null &amp;&amp; mViewCacheExtension != null) &#123;</div><div class="line">                    final View view = mViewCacheExtension</div><div class="line">                            .getViewForPositionAndType(this, position, type);</div><div class="line">                    if (view != null) &#123;</div><div class="line">                        holder = getChildViewHolder(view);</div><div class="line">                        ...</div><div class="line">			&#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">		//最后一级缓存，viewHolderPool</div><div class="line">                if (holder == null) &#123; </div><div class="line">                    holder = getRecycledViewPool().getRecycledView(type);</div><div class="line">                    if (holder != null) &#123;</div><div class="line">			//因为缓存池是公用的，所以需要清除所有状态</div><div class="line">                        holder.resetInternal();</div><div class="line">                        if (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</div><div class="line">                            invalidateDisplayListInt(holder);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (holder == null) &#123;</div><div class="line">		    //所有缓存中都没有这个holder类型</div><div class="line">                    long start = getNanoTime();</div><div class="line">                    if (deadlineNs != FOREVER_NS</div><div class="line">                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</div><div class="line">                        return null;</div><div class="line">                    &#125;</div><div class="line">		    //通过createViewHolder去创建</div><div class="line">                    holder = mAdapter.createViewHolder(RecyclerView.this, type);</div><div class="line">                    if (ALLOW_THREAD_GAP_WORK) &#123;</div><div class="line">                        //只有在支持预加载时才会寻找nextRv</div><div class="line">                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);</div><div class="line">                        if (innerView != null) &#123;</div><div class="line">                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">		   ...</div><div class="line">		if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</div><div class="line">                	holder.mPreLayoutPosition = position;</div><div class="line">            	&#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;	</div><div class="line">	      //如果这个holder的数据需要更新，那么重新绑定数据，在tryBindViewHolderByDeadline中会调用bindViewholder去绑定计算出来的position所对应的数据</div><div class="line">              final int offsetPosition = mAdapterHelper.findPositionOffset(position);</div><div class="line">                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</div><div class="line">            &#125;</div><div class="line">	    ...</div><div class="line">            return holder;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>下面我们来看看getScrapOrHiddenOrCachedHolderForPosition这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123;</div><div class="line">            //mAttachedScrap是当前recyclerView显示的viewholder列表</div><div class="line">	    final int scrapCount = mAttachedScrap.size();</div><div class="line">		</div><div class="line">            for (int i = 0; i &lt; scrapCount; i++) &#123;</div><div class="line">                final ViewHolder holder = mAttachedScrap.get(i);</div><div class="line">                if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position</div><div class="line">                        &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) &#123;</div><div class="line">        	//如果在这个可见列表中找到了这个viewHolder，那么直接返回。    </div><div class="line">	        holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);</div><div class="line">                    return holder;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!dryRun) &#123;</div><div class="line">		//从隐藏的list列表中寻找对应position的View,只有在开启了PredictiveAnimation才有这个列表</div><div class="line">                View view = mChildHelper.findHiddenNonRemovedView(position);</div><div class="line">                if (view != null) &#123;</div><div class="line">		    //不为空，表示可以复用，只需要设置为非隐藏的</div><div class="line">                    final ViewHolder vh = getChildViewHolderInt(view);</div><div class="line">                    mChildHelper.unhide(view);</div><div class="line">                    int layoutIndex = mChildHelper.indexOfChild(view);</div><div class="line">                    if (layoutIndex == RecyclerView.NO_POSITION) &#123;</div><div class="line">                        throw new IllegalStateException(&quot;layout index should not be -1 after &quot;</div><div class="line">                                + &quot;unhiding a view:&quot; + vh);</div><div class="line">                    &#125;</div><div class="line">                    mChildHelper.detachViewFromParent(layoutIndex);</div><div class="line">                    scrapView(view);</div><div class="line">                    vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP</div><div class="line">                            | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</div><div class="line">                    return vh;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 从第一级缓存中读取</div><div class="line">            final int cacheSize = mCachedViews.size();</div><div class="line">            for (int i = 0; i &lt; cacheSize; i++) &#123;</div><div class="line">                final ViewHolder holder = mCachedViews.get(i);</div><div class="line">                if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123;</div><div class="line">                    if (!dryRun) &#123;</div><div class="line">                        mCachedViews.remove(i);</div><div class="line">                    &#125;</div><div class="line">                    if (DEBUG) &#123;</div><div class="line">                        Log.d(TAG, &quot;getScrapOrHiddenOrCachedHolderForPosition(&quot; + position</div><div class="line">                                + &quot;) found match in cache: &quot; + holder);</div><div class="line">                    &#125;</div><div class="line">                    return holder;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>通过上面这一系列的复用机制，我们可以知道复用的流程，首先会从attachScrap,也就是当前已经显示的ViewHolder列表中获取可以复用的ViewHolder，如果存在hidden的Viewholder列表，那么接下来会从这个列表中获取缓存，如果不存在，接下来就是一级缓存mCacheView，二级缓存默认是我们自定义的mExtension，最后一级缓存是ViewholderPool，这个是一个公用的holder池。</p>
<h2 id="一些关于recyclerView相关的应用"><a href="#一些关于recyclerView相关的应用" class="headerlink" title="一些关于recyclerView相关的应用"></a>一些关于recyclerView相关的应用</h2><p>项目中遇到了几个关于recyclerView相关的问题。</p>
<ul>
<li><p>对recyclerView的item项设置预加载处理，对于这个问题，有许多不同的方法来解决。<br>1.在新版本的recyclerView，即25.2.0中开放了一个新的方法，即setInitialItemPrefetchCount()，这个可以用来设置这个recyclerView预加载的数量，他的参数是item的个数，假如说现在这个recyclerView可显示10个item，那么这个设置这个值为15，就会预加载5个item。<br>2.在layoutManager中一直有一个方法，即getExtraLayoutSpace(),它的参数是一个缓存区域的大小，这个在layout时会将这个预设的缓存添加进去，然后进行fill填充。<br>3.其实recyclerView列表滑动最耗时的就是加载图片了，我们可以针对每一个场景提前先把列表所需要的图片进行缓存加载，其实就是只对图片进行预加载。<br>最后用的第二种方法来预加载。</p>
</li>
<li><p>对recyclerView的item项进行滑动分页处理，就是每次滑动都滑动固定的高度。这个处理有两种方式，一种是直接改源码，在Scroller的onFilling操作中添加我们自定义的滑动操作。另外一种是升级recyclerView的版本，升级到24.2.0，就会多一个监听函数，onfilling监听，在这个里面添加我们需要的操作，只要返回true之后，系统就不会处理这个onfling事件了。</p>
</li>
<li><p>在从低版本升级高版本的recyclerView时，如果低版本的recyclerView的Viewholder的item的xml的根结点设置为match_parent，这个时候在新版本里面就会真正的match_parent而出现空白。我估计是老版本有对这个子item的大小的做限制而新版本没有。</p>
</li>
<li><p>可滑动的View内部如果嵌套了recyclerView，如果内部了recyclerView获取了焦点，可能会导致内部的recyclerView移动到首部。此时只需要我们在外部滑动view中随便找一个view添加上 android:focusableInTouchMode=”true”属性就能解决了。<br>以上就是目前所遇到的几个问题，后面有好的绘图软件的添加几张图。<br>mark。</p>
</li>
</ul>
<p><span id="busuanzi_container_page_pv"><br>  本文总阅读量<span id="busuanzi_value_page_pv"></span>次<br></span></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/xiejl.github.io/2017/04/09/0409anotation的基本原理/" rel="next" title="annotation(注解)的基本原理">
                <i class="fa fa-chevron-left"></i> annotation(注解)的基本原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/xiejl.github.io/2017/05/01/0501LeakCanary源码解析/" rel="prev" title="LeakCanary源码解析">
                LeakCanary源码解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/xiejl.github.io/images/avatar.gif"
               alt="phiCoo" />
          <p class="site-author-name" itemprop="name">phiCoo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/xiejl.github.io/archives">
                <span class="site-state-item-count">34</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#recyclerView简介"><span class="nav-number">1.</span> <span class="nav-text">recyclerView简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#recyclerView简单相关"><span class="nav-number">2.</span> <span class="nav-text">recyclerView简单相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#recyclerView的简单用法"><span class="nav-number">3.</span> <span class="nav-text">recyclerView的简单用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#recylerView简单流程"><span class="nav-number">3.1.</span> <span class="nav-text">recylerView简单流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recyclerView源码入口"><span class="nav-number">3.2.</span> <span class="nav-text">recyclerView源码入口:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一些recyclerView的相关定义"><span class="nav-number">3.2.1.</span> <span class="nav-text">一些recyclerView的相关定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RecyclerView源码2"><span class="nav-number">3.3.</span> <span class="nav-text">RecyclerView源码2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recyclerView滑动处理"><span class="nav-number">3.4.</span> <span class="nav-text">recyclerView滑动处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recyclerView-缓存处理"><span class="nav-number">3.5.</span> <span class="nav-text">recyclerView 缓存处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些关于recyclerView相关的应用"><span class="nav-number">3.6.</span> <span class="nav-text">一些关于recyclerView相关的应用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">phiCoo</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/xiejl.github.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/xiejl.github.io/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/xiejl.github.io/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/xiejl.github.io/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/xiejl.github.io/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
