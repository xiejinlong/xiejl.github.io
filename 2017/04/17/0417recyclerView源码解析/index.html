<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/xiejl.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/xiejl.github.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/xiejl.github.io/favicon.ico?v=5.1.0" />






<meta name="description" content="recyclerView简介自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：1A flexible view for providing a limit">
<meta property="og:type" content="article">
<meta property="og:title" content="recyclerView源码解析">
<meta property="og:url" content="https://xiejinlong.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/index.html">
<meta property="og:site_name" content="一个被裁的菜鸟程序员">
<meta property="og:description" content="recyclerView简介自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：1A flexible view for providing a limit">
<meta property="og:image" content="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png">
<meta property="og:updated_time" content="2017-04-20T11:47:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="recyclerView源码解析">
<meta name="twitter:description" content="recyclerView简介自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：1A flexible view for providing a limit">
<meta name="twitter:image" content="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/xiejl.github.io/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xiejinlong.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/"/>





  <title> recyclerView源码解析 | 一个被裁的菜鸟程序员 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/xiejl.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">一个被裁的菜鸟程序员</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我会笑着迎接每一天</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/xiejl.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/xiejl.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/xiejl.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xiejinlong.github.io/xiejl.github.io/xiejl.github.io/2017/04/17/0417recyclerView源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/xiejl.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一个被裁的菜鸟程序员">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                recyclerView源码解析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T13:14:52+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="recyclerView简介"><a href="#recyclerView简介" class="headerlink" title="recyclerView简介"></a>recyclerView简介</h1><p>自从google官方推出了recyclerView这个控件来替代listView之后，就意味着listView要慢慢的退出历史的舞台了。因为recyclerView基本上能实现listView的所有功能，还能实现很多用listView很难实现的功能。我们来看看recyclerView的官方定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A flexible view for providing a limited window into a large data set。</div></pre></td></tr></table></figure><br>即，在一个有限的窗口显示大量的数据集的一个复杂的View，简单的说，就是可以通过这个RecyclerView以列表的形式将大量的数据显示出来。</p>
<h1 id="recyclerView简单相关"><a href="#recyclerView简单相关" class="headerlink" title="recyclerView简单相关"></a>recyclerView简单相关</h1><h1 id="recyclerView的简单用法"><a href="#recyclerView的简单用法" class="headerlink" title="recyclerView的简单用法"></a>recyclerView的简单用法</h1><p>其实recylerview使用起来也很方便，主要分成了以下几个组件：</p>
<ul>
<li>Adapter：对于数据集的处理都是在adapter中去完成。</li>
<li>ViewHolder：对于每一个列表项的表现形式，利用viewHolder来减少findViewById的次数，是recyclerView操作的基本单位</li>
<li>LayoutManager：recyclerView对于每一个Item的排列，显示，回收大部分都是通过layoutmanager来处理的。</li>
</ul>
<ol>
<li>在代码中设置布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//recyclerView布局</div><div class="line">&lt;android.support.v7.widget.RecyclerView</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        android:id=&quot;@+id/recycler_id&quot;&gt;</div><div class="line"></div><div class="line">    &lt;/android.support.v7.widget.RecyclerView&gt;</div><div class="line"></div><div class="line">//RecyclerView的每一项的布局</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:text=&quot;xiexie&quot;</div><div class="line">        android:id=&quot;@+id/test_item&quot;</div><div class="line">        android:layout_gravity=&quot;center&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></li>
<li>自定义adapter，里面必须包含ViewHolder实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">public class AdapterTest extends RecyclerView.Adapter&lt;AdapterTest.Holds&gt; &#123;</div><div class="line"></div><div class="line">    private LayoutInflater layoutInflater;</div><div class="line">    private List&lt;String&gt; userNames = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public AdapterTest(LayoutInflater layoutInflater, List&lt;String&gt; userNames) &#123;</div><div class="line">        this.layoutInflater = layoutInflater;</div><div class="line">        this.userNames = userNames;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public AdapterTest.Holds onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        return new Holds(layoutInflater.inflate(R.layout.username_list, null));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(Holds holder, int position) &#123;</div><div class="line">        holder.textView.setText(userNames.get(position));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return userNames.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class Holds extends RecyclerView.ViewHolder &#123;</div><div class="line">        public TextView textView;</div><div class="line"></div><div class="line">        public Holds(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            textView = (TextView) itemView.findViewById(R.id.test_item);</div><div class="line">            textView.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onClick(View v) &#123;</div><div class="line">                    Log.d(&quot;XJL&quot;, &quot;hahaha&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
<li>最后，只要在初始化recyclerView的地方相应的设置adapter和layoutManager就可以了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">     recyclerView = (RecyclerView)findViewById(R.id.recycler_id);</div><div class="line">        layoutManager = new LinearLayoutManager(this);</div><div class="line">        layoutManager.setOrientation(LinearLayoutManager.VERTICAL);</div><div class="line">        initData();</div><div class="line">        recyclerView.setAdapter(new AdapterTest(getLayoutInflater(), userNames));</div><div class="line">        recyclerView.setLayoutManager(layoutManager);</div><div class="line">        </div><div class="line">        </div><div class="line">private void initData() &#123;</div><div class="line">        userNames = new ArrayList&lt;&gt;();</div><div class="line">        userNames.add(&quot;xiexie1&quot;);</div><div class="line">        userNames.add(&quot;xiexie2&quot;);</div><div class="line">        userNames.add(&quot;xiexie3&quot;);</div><div class="line">        userNames.add(&quot;xiexie4&quot;);</div><div class="line">        userNames.add(&quot;xiexie5&quot;);</div></pre></td></tr></table></figure>
这样，一个可见的列表就构建出来了。</li>
</ol>
<h2 id="recylerView简单流程"><a href="#recylerView简单流程" class="headerlink" title="recylerView简单流程"></a>recylerView简单流程</h2><p>对于一个recyclerView的显示过程，在不通过源码时，我们应该也要有一个直观的认识，也就是对于我们的adapter，我们需要实现哪几个方法？为什么我们需要实现那几个方法？<br>我们下面来看看这几个方法以及相应的流程。</p>
<p>当一个RecyclerView显示时，其中的每一个Item项，也就是ViewHolder，在有多个不同的item类型时，几个方法调用的顺序是这样的:<br>getItemViewType()—–&gt;onCreateViewHolder()——&gt;onBindViewHolder()—-&gt;<br>首先，在getItemViewType中会通过position来获取这个item的类型，然后会通过onCreateViewHolder，来创建相应的ViewHolder，这里仅仅只是创建出这个ViewHolder，里面的数据仍然是空的。最后在onBindViewHolder中进行position数据绑定。对于一个已经创建过的Viewholder，这个类型会被缓存，用来下次的复用。所以，在我们的滑动过程中，基本上每个类型的ViewHolder只会相应的调用一次，在滑动时只需要调用onBindViewHolder。</p>
<h2 id="recyclerView源码入口"><a href="#recyclerView源码入口" class="headerlink" title="recyclerView源码入口:"></a>recyclerView源码入口:</h2><p>我们先来看看recyclerView的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public class RecyclerView </div><div class="line">extends ViewGroup implements ScrollingView, NestedScrollingChild</div></pre></td></tr></table></figure><br>通过这个类的定义，我们可以知道对于recyclerView来说，我们并不需要自己去处理滑动冲突，recyclerView已经为我们处理好了。</p>
<h3 id="一些recyclerView的相关定义"><a href="#一些recyclerView的相关定义" class="headerlink" title="一些recyclerView的相关定义"></a>一些recyclerView的相关定义</h3><ul>
<li>Adapter：是RecyclerView.Adapter的子类，用来放置显示的数据集，必须实现。</li>
<li>Position：数据项在Adapter中的位置</li>
<li>Index：可见的子View的位置项</li>
<li>Bingding：用来处理正在准备显示的子View的数据对应于adapter的位置</li>
<li>Recycler：是recyclerview的一个缓冲区，这个缓冲区里面缓存的view加入需要重用的话，必须要利用adapter重新绑定数据。</li>
<li>scrap：是recyclerview的一个缓存区，是指里面缓存的view是接下来需要用到的，里面绑定的数据无需更改，可以直接拿过来使用。是一个轻量级的缓存集合。</li>
<li>dirty：一个被认为是脏的视图，即数据进行修改过，之后如果需要显示必须重新绑定数据。</li>
</ul>
<p>我们直接从调用的过程来阅读,也就是recyclerView的创建和setAdapter这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void setAdapter(Adapter adapter) &#123;</div><div class="line">        // bail out if layout is frozen</div><div class="line">        setLayoutFrozen(false);</div><div class="line">        setAdapterInternal(adapter, false, true);</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>在这个方法里面，首先会调用setLayoutFrozen(false)，setLayoutFrozen这个方法主要是layout和scroll滑动的使能开关，一旦设置为true之后，layout将不能更新也不能滑动，同样也不能响应点击事件。置为false，开启使能开关。<br>然后调用setAdapterInternal方法区进行adapter替换，同时开启监听。<br>然后调用setAdapterInternal():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,</div><div class="line">           boolean removeAndRecycleViews) &#123;</div><div class="line">       if (mAdapter != null) &#123;</div><div class="line">           mAdapter.unregisterAdapterDataObserver(mObserver);</div><div class="line">           mAdapter.onDetachedFromRecyclerView(this);</div><div class="line">       &#125;</div><div class="line">       if (!compatibleWithPrevious || removeAndRecycleViews) &#123;</div><div class="line">           if (mItemAnimator != null) &#123;</div><div class="line">               mItemAnimator.endAnimations();</div><div class="line">           &#125;</div><div class="line">           if (mLayout != null) &#123;</div><div class="line">               mLayout.removeAndRecycleAllViews(mRecycler);</div><div class="line">               mLayout.removeAndRecycleScrapInt(mRecycler);</div><div class="line">           &#125;</div><div class="line">           // we should clear it here before adapters are swapped to ensure correct callbacks.</div><div class="line">           mRecycler.clear();</div><div class="line">       &#125;</div><div class="line">       mAdapterHelper.reset();</div><div class="line">       final Adapter oldAdapter = mAdapter;</div><div class="line">       mAdapter = adapter;</div><div class="line">       if (adapter != null) &#123;</div><div class="line">           adapter.registerAdapterDataObserver(mObserver);</div><div class="line">           adapter.onAttachedToRecyclerView(this);</div><div class="line">       &#125;</div><div class="line">       if (mLayout != null) &#123;</div><div class="line">           mLayout.onAdapterChanged(oldAdapter, mAdapter);</div><div class="line">       &#125;</div><div class="line">       mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);</div><div class="line">       mState.mStructureChanged = true;</div><div class="line">       markKnownViewsInvalid();</div><div class="line">   &#125;</div></pre></td></tr></table></figure><br>在这个方法里面，首先会进行一系列的清空操作。然后重置adapterHelper，再进行一系列的初始化绑定操作。onAdapterChange这个方法这个会清除缓冲区，重新绘制数据和view类型。<br>后面调用mReycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious)方法，会创建出一个新的recyclerPool并且绑定上新的adapter。我们在这里可以看看里面做的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> void onAdapterChanged(Adapter oldAdapter, Adapter newAdapter,</div><div class="line">                boolean compatibleWithPrevious) &#123;</div><div class="line">            clear();</div><div class="line">            getRecycledViewPool().onAdapterChanged(oldAdapter, newAdapter, compatibleWithPrevious);</div><div class="line">        &#125;</div><div class="line">====&gt;clear()</div><div class="line">public void clear() &#123;</div><div class="line">	    //清空当前屏幕显示的view</div><div class="line">            mAttachedScrap.clear();</div><div class="line">	   //回收缓存的ViewHolder</div><div class="line">            recycleAndClearCachedViews();</div><div class="line">        &#125;</div></pre></td></tr></table></figure><br>所以，这里做了一系列的缓存清空操作。那么这些缓存都是什么呢？在这里，我们先来看看这些缓存的结构定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;ViewHolder&gt;();</div><div class="line">private ArrayList&lt;ViewHolder&gt; mChangedScrap = null;</div><div class="line">final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();</div><div class="line">private RecycledViewPool mRecyclerPool；</div></pre></td></tr></table></figure></p>
<ul>
<li>mAttachedScrap：用于屏幕内itemview的快速重用，即该ViewHolder列表仍未与RecyclerView分离,仍然处于显示的状态</li>
<li>mChangedScrap：与RecyclerView分离的ViewHolder列表，表示这个Viewholder仍然处于显示状态，但是已经被标记为需要重新绑定数据了</li>
<li>mCachedViews： 用于缓存屏幕外的两个itemview，最近刚被抛弃的两个Viewholder，即刚不显示的ViewHolder，默认缓存个数，上下各一个。</li>
<li>mRecyclerPool:提供复用的ViewHolder池，默认上限为5个</li>
<li>mViewCacheExtension：让开发者自主控制ViewHolder缓存。</li>
</ul>
<p>我们先来了解下这几个缓存的区别，<br>如果这个ViewHolder仍然在RecyclerView的可视范围内，而且是可以重用的，合法的，没有被移除的，那么这个ViewHolder会被加入到mAttachedScrap这个列表中。<br>如果这个ViewHolder项已经被标记更新过了，比如说我们在代码中notifyItem()，而且这个item是在屏幕内的，那么这个ViewHolder就被标记了需要被更新。<br>如果一个ViewHolder刚刚被移除出可见范围，那么将会被添加到mCacheView中，这个默认会缓存屏幕之外的两个ViewHolder。<br>如果mCacheView已经满了，当再添加一个新的移除的ViewHolder，那么会以lru的方式，将最早添加到这个列表的ViewHolder移除，并添加到RecyclerPool缓存。<br>mViewCacheExtension是recycler提供给我们们的自定义缓存机制，这个是第三级缓存，在recyclerPool之前，在mcacheView之后，默认的是空实现。</p>
<p>在recyclerView中，所谓的大部分的复用机制，几乎都是通过ViewHolder的type复用，然后在再次显示的时候重新绑定数据，最简单的说，就是跳过了onCreateViewHolder这一个步骤，只调用了onBindViewHolder。</p>
<p>我们再来看看另外一个基本可以调用到的方法，setLayoutManager:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public void setLayoutManager(LayoutManager layout) &#123;</div><div class="line">        if (layout == mLayout) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">	//做一系列的清空操作，如果之前有layoutManager，则移除，然后更新为当前的layoutManager</div><div class="line">        if (mLayout != null) &#123;</div><div class="line">            if (mIsAttached) &#123;</div><div class="line">                mLayout.dispatchDetachedFromWindow(this, mRecycler);</div><div class="line">            &#125;</div><div class="line">            mLayout.setRecyclerView(null);</div><div class="line">        &#125;</div><div class="line">        mRecycler.clear();</div><div class="line">        mChildHelper.removeAllViewsUnfiltered();</div><div class="line">        mLayout = layout;</div><div class="line">        if (layout != null) &#123;</div><div class="line">            if (layout.mRecyclerView != null) &#123;</div><div class="line">                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +</div><div class="line">                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);</div><div class="line">            &#125;</div><div class="line">            mLayout.setRecyclerView(this);</div><div class="line">            if (mIsAttached) &#123;</div><div class="line">                mLayout.dispatchAttachedToWindow(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        requestLayout();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>虽然这个方法也没做什么实质性的东西，但是我们必须先有一个清楚的认识，recyclerView对于子item的排列管理，显示回收都是通过layoutManager来处理的。</p>
<h2 id="RecyclerView源码2"><a href="#RecyclerView源码2" class="headerlink" title="RecyclerView源码2"></a>RecyclerView源码2</h2><p>在这里，我们再通过recyclerView的构造函数入手：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public RecyclerView(Context context) &#123;</div><div class="line">        this(context, null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RecyclerView(Context context, @Nullable AttributeSet attrs) &#123;</div><div class="line">        this(context, attrs, 0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><br>我们先看下这个三个构造函数，最早接触自定义view的时候，我并不知道为什么每个自定义view都要实现3个构造函数，你是不是也不清楚呢？其实吧，自定义view的每个构造函数都对应一个创建这个view的方式。</p>
<ul>
<li>RecyclerView(Context context): 这种方式以context作为参数，主要是用在代码中初始化的。像我们在代码中以new的方式创建出一个view对象时，只需要传入一个context。</li>
<li>RecyclerView(Context context, @Nullable AttributeSet attrs)：这种方式主要是用来在xml文件中初始化的，attrs参数便是我们在xml所设置的一些属性参数。</li>
<li>RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) : 同样也是在xml里面使用，不过多了一个style设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;</div><div class="line">       super(context, attrs, defStyle);</div><div class="line">       setScrollContainer(true);</div><div class="line">       setFocusableInTouchMode(true);</div><div class="line">       final int version = Build.VERSION.SDK_INT;</div><div class="line">       mPostUpdatesOnAnimation = version &gt;= 16;</div><div class="line"></div><div class="line">       final ViewConfiguration vc = ViewConfiguration.get(context);</div><div class="line">       mTouchSlop = vc.getScaledTouchSlop();</div><div class="line">       mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();</div><div class="line">       mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();</div><div class="line">       setWillNotDraw(ViewCompat.getOverScrollMode(this) == ViewCompat.OVER_SCROLL_NEVER);</div><div class="line"></div><div class="line">       mItemAnimator.setListener(mItemAnimatorListener);</div><div class="line">       initAdapterManager();</div><div class="line">       initChildrenHelper();</div><div class="line">       // If not explicitly specified this view is important for accessibility.</div><div class="line">       if (ViewCompat.getImportantForAccessibility(this)</div><div class="line">               == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</div><div class="line">           ViewCompat.setImportantForAccessibility(this,</div><div class="line">                   ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);</div><div class="line">       &#125;</div><div class="line">       mAccessibilityManager = (AccessibilityManager) getContext()</div><div class="line">               .getSystemService(Context.ACCESSIBILITY_SERVICE);</div><div class="line">       setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));</div><div class="line">       // Create the layoutManager if specified.</div><div class="line">       if (attrs != null) &#123;</div><div class="line">           int defStyleRes = 0;</div><div class="line">           TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,</div><div class="line">                   defStyle, defStyleRes);</div><div class="line">           String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);</div><div class="line">           a.recycle();</div><div class="line">           createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       mScrollingChildHelper = new NestedScrollingChildHelper(this);</div><div class="line">       setNestedScrollingEnabled(true);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
在这个构造函数里面，recyclerView也只是做了一些基本的设置，并没有做实际的操作，recyclerView就相当于一个自定义View，它的实际的操作正是在自定义View的三大步骤中去做的，也就是onMeasure-&gt;onLayout-&gt;onDraw，下面我们就通过这个三个函数来了解recyclerView<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">protected void onMeasure(int widthSpec, int heightSpec) &#123;</div><div class="line">        //如果在measure时更新了Adapter</div><div class="line">	if (mAdapterUpdateDuringMeasure) &#123;</div><div class="line">            eatRequestLayout();</div><div class="line">            processAdapterUpdatesAndSetAnimationFlags();</div><div class="line"></div><div class="line">            if (mState.mRunPredictiveAnimations) &#123;</div><div class="line">                mState.mInPreLayout = true;</div><div class="line">            &#125; else &#123;</div><div class="line">                mAdapterHelper.consumeUpdatesInOnePass();</div><div class="line">                mState.mInPreLayout = false;</div><div class="line">            &#125;</div><div class="line">            mAdapterUpdateDuringMeasure = false;</div><div class="line">            resumeRequestLayout(false);</div><div class="line">        &#125;</div><div class="line">        if (mAdapter != null) &#123;</div><div class="line">            mState.mItemCount = mAdapter.getItemCount();</div><div class="line">        &#125; else &#123;</div><div class="line">            mState.mItemCount = 0;</div><div class="line">        &#125;</div><div class="line">        if (mLayout == null) &#123;</div><div class="line">            defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">        &#125; else &#123;</div><div class="line">	    //对于onmeasure托管给了LayoutManager去计算</div><div class="line">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mState.mInPreLayout = false; // clear</div><div class="line">    &#125;</div><div class="line">====&gt;mlayout.onMeasure</div><div class="line"> public void onMeasure(Recycler recycler, State state, int widthSpec, int heightSpec) &#123;</div><div class="line">            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);</div><div class="line">        &#125;</div><div class="line">=====&gt;mRecyclerView.defaultOnmeasure</div><div class="line"> private void defaultOnMeasure(int widthSpec, int heightSpec) &#123;</div><div class="line">        final int widthMode = MeasureSpec.getMode(widthSpec);</div><div class="line">        final int heightMode = MeasureSpec.getMode(heightSpec);</div><div class="line">        final int widthSize = MeasureSpec.getSize(widthSpec);</div><div class="line">        final int heightSize = MeasureSpec.getSize(heightSpec);</div><div class="line"></div><div class="line">        int width = 0;</div><div class="line">        int height = 0;</div><div class="line">	//对宽高的模式进行计算</div><div class="line">        switch (widthMode) &#123;</div><div class="line">            case MeasureSpec.EXACTLY:</div><div class="line">            case MeasureSpec.AT_MOST:</div><div class="line">                width = widthSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.UNSPECIFIED:</div><div class="line">            default:</div><div class="line">                width = ViewCompat.getMinimumWidth(this);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        switch (heightMode) &#123;</div><div class="line">            case MeasureSpec.EXACTLY:</div><div class="line">            case MeasureSpec.AT_MOST:</div><div class="line">                height = heightSize;</div><div class="line">                break;</div><div class="line">            case MeasureSpec.UNSPECIFIED:</div><div class="line">            default:</div><div class="line">                height = ViewCompat.getMinimumHeight(this);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setMeasuredDimension(width, height);</div><div class="line">    &#125;</div><div class="line">====&gt;</div><div class="line">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        //计算实际的宽高，通过set的宽高和marging</div><div class="line">	boolean optical = isLayoutModeOptical(this);</div><div class="line">        if (optical != isLayoutModeOptical(mParent)) &#123;</div><div class="line">            Insets insets = getOpticalInsets();</div><div class="line">            int opticalWidth  = insets.left + insets.right;</div><div class="line">            int opticalHeight = insets.top  + insets.bottom;</div><div class="line"></div><div class="line">            measuredWidth  += optical ? opticalWidth  : -opticalWidth;</div><div class="line">            measuredHeight += optical ? opticalHeight : -opticalHeight;</div><div class="line">        &#125;</div><div class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</div><div class="line">    &#125;</div><div class="line">=====&gt;</div><div class="line"> private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123;</div><div class="line">        mMeasuredWidth = measuredWidth;</div><div class="line">        mMeasuredHeight = measuredHeight;</div><div class="line"></div><div class="line">        mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
上面就是onMeasure的整个计算过程，现在我们来看看onLayout这个方法的处理，这个方法会比较复杂，因为onLayout的计算不仅仅只是要计算整个RecyclerView的位置，而且需要去计算每个子item的位置。我们详细的看看这段代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"> protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</div><div class="line">        eatRequestLayout();</div><div class="line">	//traceCompat是用来跟踪系统性能的，beginsection和endsection需要成对出现</div><div class="line">        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</div><div class="line">        dispatchLayout();</div><div class="line">        TraceCompat.endSection();</div><div class="line">        resumeRequestLayout(false);</div><div class="line">        mFirstLayoutComplete = true;</div><div class="line">    &#125;</div><div class="line">====&gt;下面来看看dispatchLayout，这个是最主要的方法</div><div class="line">void dispatchLayout() &#123;</div><div class="line">    ...</div><div class="line">    ...</div><div class="line">    //获取当前layout计算时，item的最小和最大的position</div><div class="line">    findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);</div><div class="line">    step0:寻找所有的未移除的item</div><div class="line">    int count = mChildHelper.getChildCount();</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</div><div class="line">                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) &#123;</div><div class="line">                	//如果这个item需要被忽略或者是不合法的，则直接跳过   </div><div class="line">			 continue;</div><div class="line">                &#125;</div><div class="line">                final ItemHolderInfo animationInfo = mItemAnimator</div><div class="line">                        .recordPreLayoutInformation(mState, holder,</div><div class="line">                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),</div><div class="line">                                holder.getUnmodifiedPayloads());</div><div class="line">                mViewInfoStore.addToPreLayout(holder, animationInfo);</div><div class="line">                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()</div><div class="line">                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) &#123;</div><div class="line">                    long key = getChangedHolderKey(holder);</div><div class="line">                    //满足下面条件的holder将会被添加到oldChangeHoder里面</div><div class="line">                    //1.处于隐藏状态但是仍未删除的vh</div><div class="line">                    //2.隐藏的vh但是数据已经修改过了</div><div class="line">                    //3.layoutmanager想在pre-layout中进行layout计算的item</div><div class="line">                    mViewInfoStore.addToOldChangeHolders(key, holder);</div><div class="line">                    </div><div class="line">    step1:执行预布局，利用先前position所对应的item，layoutmanager想要布局所有东西，甚至是已经移除的item。会返回pre-layout位置所对应的APPEARING view，这种标记的view是相当于真正的layout的一部分。</div><div class="line">	    //保存这个ViewHolder之前的位置</div><div class="line">            saveOldPositions();</div><div class="line">            final boolean didStructureChange = mState.mStructureChanged;</div><div class="line">            mState.mStructureChanged = false;</div><div class="line">            //在这里对子元素去进行预布局的计算，这里就需要依据LayoutManager的具体实现类来进行计算，因为是预布局，我们需要将mStructureChanged设置为false</div><div class="line">	    mLayout.onLayoutChildren(mRecycler, mState);</div><div class="line">            mState.mStructureChanged = didStructureChange;</div><div class="line">		</div><div class="line">            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) &#123;</div><div class="line">                final View child = mChildHelper.getChildAt(i);</div><div class="line">                final ViewHolder viewHolder = getChildViewHolderInt(child);</div><div class="line">                if (viewHolder.shouldIgnore()) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (!mViewInfoStore.isInPreLayout(viewHolder)) &#123;</div><div class="line">                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);</div><div class="line">                    boolean wasHidden = viewHolder</div><div class="line">                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</div><div class="line">                    if (!wasHidden) &#123;</div><div class="line">                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</div><div class="line">                    &#125;</div><div class="line">                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(</div><div class="line">                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());</div><div class="line">                    if (wasHidden) &#123;</div><div class="line">                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            clearOldPositions();</div><div class="line">            mAdapterHelper.consumePostponedUpdates();</div><div class="line">        &#125; else &#123;</div><div class="line">            clearOldPositions();</div><div class="line">        &#125;</div><div class="line">        mState.mItemCount = mAdapter.getItemCount();</div><div class="line">        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;</div><div class="line"> 	//step2:pre-layout计算已经执行完毕,真正的进行layout计算</div><div class="line">	mState.mInPreLayout = false;</div><div class="line">        mLayout.onLayoutChildren(mRecycler, mState);</div><div class="line"></div><div class="line">        mState.mStructureChanged = false;</div><div class="line">        mPendingSavedState = null;</div><div class="line"></div><div class="line">        if (mState.mRunSimpleAnimations) &#123;</div><div class="line">            // Step 3: 计算viewHolder所在的位置</div><div class="line">            int count = mChildHelper.getChildCount();</div><div class="line">            for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</div><div class="line">                if (holder.shouldIgnore()) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">		//获取当前这个holder的position</div><div class="line">                long key = getChangedHolderKey(holder);</div><div class="line">                //获取当前viewHolder所对应的animation</div><div class="line">		final ItemHolderInfo animationInfo = mItemAnimator</div><div class="line">                        .recordPostLayoutInformation(mState, holder);</div><div class="line">		//获取这个position之前对应的viewholder</div><div class="line">                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);</div><div class="line">                if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</div><div class="line">                    //执行切换动画</div><div class="line">                    final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(</div><div class="line">                            oldChangeViewHolder);</div><div class="line">                    animateChange(oldChangeViewHolder, holder, preInfo, animationInfo);</div><div class="line">                &#125; else &#123;</div><div class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Step 4: 执行Viewinfo和监听animation</div><div class="line">            mViewInfoStore.process(mViewInfoProcessCallback);</div><div class="line">        &#125;</div><div class="line">        resumeRequestLayout(false);</div><div class="line">	//对mRecycler做一次清空操作</div><div class="line">        mLayout.removeAndRecycleScrapInt(mRecycler);</div><div class="line">        mState.mPreviousLayoutItemCount = mState.mItemCount;</div><div class="line">        mDataSetHasChangedAfterLayout = false;</div><div class="line">        mState.mRunSimpleAnimations = false;</div><div class="line"></div><div class="line">        mState.mRunPredictiveAnimations = false;</div><div class="line">        onExitLayoutOrScroll();</div><div class="line">        mLayout.mRequestedSimpleAnimations = false;</div><div class="line">        if (mRecycler.mChangedScrap != null) &#123;</div><div class="line">            mRecycler.mChangedScrap.clear();</div><div class="line">        &#125;</div><div class="line">        mViewInfoStore.clear();</div><div class="line">        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123;</div><div class="line">           //如果这个recyclerView的position区间是正确的，那么移动到当前的第一个位置 </div><div class="line">	   dispatchOnScrolled(0, 0);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
recyclerView的onLayout仅仅只是做了部分计算，对于其子item的计算托管给了layoutManager，下面我们来看看这个LayoutManager的计算，我们必须先了解一下这个layoutManager，它是一个抽象类，对于不同的实现类会有不同的实现，对于LinearLayoutManager和GridLayoutManager的实现就有很多不一样了。这里我们查看的是linearLayoutManager的源码，在看这个源码时我们先了解下其中的layout计算算法。这个源码中给我们标注出来的：</li>
</ul>
<ol>
<li>检查子item和其他变量，找到其中的anchor，anchor算是一个计算的锚点，指定的从哪个一个position开始进行计算。</li>
<li>从start方向开始填充，item从bottom开始出栈</li>
<li>从end方向开始填充，item从start开始出栈</li>
<li>通过滑动去满足要求。<br>下面我们来看看下面这张图的表示，这个图并非原创，在网上看到了，感觉画得还行<br><img src="http://onu21exz8.bkt.clouddn.com/RecyclerView_anchor%E7%9A%84%E5%89%AF%E6%9C%AC.png" alt=""><br>下面就是这个算法所对应的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"> public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123;</div><div class="line">       //确认Layout方向，即orientation设置的方向</div><div class="line">ensureLayoutState();</div><div class="line">       mLayoutState.mRecycle = false;</div><div class="line">       // 真正的加载方向，因为linearLayoutManager有一个setReverse方法，这个会让整个recyclerView反向加载，所以需要通过设置的方向和这个方法值共同来判断</div><div class="line">       resolveShouldLayoutReverse();</div><div class="line">//初始化Anchor信息</div><div class="line">       mAnchorInfo.reset();</div><div class="line">//anchor方向</div><div class="line">       mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;</div><div class="line">       // 计算anchor位置</div><div class="line">       updateAnchorInfoForLayout(recycler, state, mAnchorInfo);</div><div class="line">       //LLM会有一个extra空间用来缓存item，可以用来进行预加载</div><div class="line">int extraForStart;</div><div class="line">       int extraForEnd;</div><div class="line">//我们可以重写getExtraLayoutSpac这个方法用来进行额外的显示空间，默认为0</div><div class="line">       final int extra = getExtraLayoutSpace(state);</div><div class="line">       //最近一次滑动的距离，大于0，表示向下滑动</div><div class="line">if (mLayoutState.mLastScrollDelta &gt;= 0) &#123;</div><div class="line">           extraForEnd = extra;</div><div class="line">           extraForStart = 0;</div><div class="line">       &#125; else &#123;</div><div class="line">           extraForStart = extra;</div><div class="line">           extraForEnd = 0;</div><div class="line">       &#125;</div><div class="line">       extraForStart += mOrientationHelper.getStartAfterPadding();</div><div class="line">       extraForEnd += mOrientationHelper.getEndPadding();</div><div class="line">       if (state.isPreLayout() &amp;&amp; mPendingScrollPosition != NO_POSITION &amp;&amp;</div><div class="line">               mPendingScrollPositionOffset != INVALID_OFFSET) &#123;</div><div class="line">    //如果是在预布局中，需要执行下面</div><div class="line">           final View existing = findViewByPosition(mPendingScrollPosition);</div><div class="line">           if (existing != null) &#123;</div><div class="line">               final int current;</div><div class="line">               final int upcomingOffset;</div><div class="line">               if (mShouldReverseLayout) &#123;</div><div class="line">                   current = mOrientationHelper.getEndAfterPadding() -</div><div class="line">                           mOrientationHelper.getDecoratedEnd(existing);</div><div class="line">                   upcomingOffset = current - mPendingScrollPositionOffset;</div><div class="line">               &#125; else &#123;</div><div class="line">                   current = mOrientationHelper.getDecoratedStart(existing)</div><div class="line">                           - mOrientationHelper.getStartAfterPadding();</div><div class="line">                   upcomingOffset = mPendingScrollPositionOffset - current;</div><div class="line">               &#125;</div><div class="line">               if (upcomingOffset &gt; 0) &#123;</div><div class="line">	    //额外滑动距离大于0，额外的空间需要加上计算之后的滑动距离</div><div class="line">                   extraForStart += upcomingOffset;</div><div class="line">               &#125; else &#123;</div><div class="line">                   extraForEnd -= upcomingOffset;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       int startOffset;</div><div class="line">       int endOffset;</div><div class="line">//判断这个锚点是否已经准备完毕。默认为空实现，只有在gridLayoutManager才需要复写</div><div class="line">       onAnchorReady(recycler, state, mAnchorInfo);</div><div class="line">//这个是关于layout的过程中缓存的计算，我们后面会详细的讲解这个函数</div><div class="line">       detachAndScrapAttachedViews(recycler);</div><div class="line">       mLayoutState.mIsPreLayout = state.isPreLayout();</div><div class="line">       if (mAnchorInfo.mLayoutFromEnd) &#123;</div><div class="line">    //如果是从start方向开始填充，更新LayoutState信息，这个是一个辅助layoutManager来管理滑动的类</div><div class="line">           updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForStart;</div><div class="line">    //在这个方法里面填充item</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           startOffset = mLayoutState.mOffset;</div><div class="line">           final int firstElement = mLayoutState.mCurrentPosition;</div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForEnd += mLayoutState.mAvailable;</div><div class="line">           &#125;</div><div class="line">           // 从end方向开始填充</div><div class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForEnd;</div><div class="line">           mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">           //在这个方法里面填充item</div><div class="line">    fill(recycler, mLayoutState, state, false);</div><div class="line">           endOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">	//底部没有足够的item用于填充满整个布局，此时再从顶部添加item进行填充	</div><div class="line">               extraForStart = mLayoutState.mAvailable;</div><div class="line">               updateLayoutStateToFillStart(firstElement, startOffset);</div><div class="line">               mLayoutState.mExtra = extraForStart;</div><div class="line">	fill(recycler, mLayoutState, state, false);</div><div class="line">               startOffset = mLayoutState.mOffset;</div><div class="line">           &#125;</div><div class="line">       &#125; else &#123;</div><div class="line">    //与上面的基本一致，只是因为start和end方向反了而已</div><div class="line">           updateLayoutStateToFillEnd(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForEnd;</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           endOffset = mLayoutState.mOffset;</div><div class="line">           final int lastElement = mLayoutState.mCurrentPosition;</div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForStart += mLayoutState.mAvailable;</div><div class="line">           &#125;</div><div class="line">           // fill towards start</div><div class="line">           updateLayoutStateToFillStart(mAnchorInfo);</div><div class="line">           mLayoutState.mExtra = extraForStart;</div><div class="line">           mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</div><div class="line">           fill(recycler, mLayoutState, state, false);</div><div class="line">           startOffset = mLayoutState.mOffset;</div><div class="line"></div><div class="line">           if (mLayoutState.mAvailable &gt; 0) &#123;</div><div class="line">               extraForEnd = mLayoutState.mAvailable;</div><div class="line">               updateLayoutStateToFillEnd(lastElement, endOffset);</div><div class="line">               mLayoutState.mExtra = extraForEnd;</div><div class="line">               fill(recycler, mLayoutState, state, false);</div><div class="line">               endOffset = mLayoutState.mOffset;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       if (getChildCount() &gt; 0) &#123;</div><div class="line">    //对于不同的加载方向，计算偏移量</div><div class="line">           if (mShouldReverseLayout ^ mStackFromEnd) &#123;</div><div class="line">	startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">               fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">           &#125; else &#123;</div><div class="line">               int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">               fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);</div><div class="line">               startOffset += fixOffset;</div><div class="line">               endOffset += fixOffset;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</div><div class="line">       if (!state.isPreLayout()) &#123;</div><div class="line">           mPendingScrollPosition = NO_POSITION;</div><div class="line">           mPendingScrollPositionOffset = INVALID_OFFSET;</div><div class="line">           mOrientationHelper.onLayoutComplete();</div><div class="line">       &#125;</div><div class="line">       mLastStackFromEnd = mStackFromEnd;</div><div class="line">       mPendingSavedState = null;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
上面就是LinearLayoutManager的layout计算，我们来看看这个填充函数fill的具体实现：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,</div><div class="line">            RecyclerView.State state, boolean stopOnFocusable) &#123;</div><div class="line">	 final int start = layoutState.mAvailable;</div><div class="line">	//最大偏移量就是scroll距离加上可达的距离</div><div class="line">        if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">            if (layoutState.mAvailable &lt; 0) &#123;</div><div class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</div><div class="line">            &#125;</div><div class="line">	    //在这里回收缓存不可见的item</div><div class="line">            recycleByLayoutState(recycler, layoutState);</div><div class="line">        &#125;</div><div class="line">	//剩余空间计算，可见的加上设置的extra空间再加上滑动所生成offset</div><div class="line">        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;</div><div class="line">        LayoutChunkResult layoutChunkResult = new LayoutChunkResult();</div><div class="line">        while (remainingSpace &gt; 0 &amp;&amp; layoutState.hasMore(state)) &#123;</div><div class="line">            layoutChunkResult.resetInternal();</div><div class="line">	    //通过layoutChunk计算大小距离，下面我们会简单的看下这个函数</div><div class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</div><div class="line">            if (layoutChunkResult.mFinished) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</div><div class="line">            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null</div><div class="line">                    || !state.isPreLayout()) &#123;</div><div class="line">               	//计算剩下的可用空间， </div><div class="line">		layoutState.mAvailable -= layoutChunkResult.mConsumed;</div><div class="line">                remainingSpace -= layoutChunkResult.mConsumed;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (layoutState.mScrollingOffset != LayoutState.SCOLLING_OFFSET_NaN) &#123;</div><div class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</div><div class="line">                if (layoutState.mAvailable &lt; 0) &#123;</div><div class="line">                    layoutState.mScrollingOffset += layoutState.mAvailable;</div><div class="line">                &#125;</div><div class="line">                recycleByLayoutState(recycler, layoutState);</div><div class="line">            &#125;</div><div class="line">            if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return start - layoutState.mAvailable;</div></pre></td></tr></table></figure>
我们可以看到在这个fill函数中，它将计算又交给了layoutChunk，我们现在看看layoutChunk这个函数的具体计算<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,</div><div class="line">            LayoutState layoutState, LayoutChunkResult result) &#123;</div><div class="line">        //首先会尝试从scraplist里面获取view，如果这个position与我们当前需要显示的position一致，那么直接返回,否则，将会从几个缓存区中获取，获取缓存的view我们后面讲解</div><div class="line">	View view = layoutState.next(recycler);</div><div class="line">        if (view == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        LayoutParams params = (LayoutParams) view.getLayoutParams();</div><div class="line">        if (layoutState.mScrapList == null) &#123;</div><div class="line">	    //如果这个scraplist为空，那么这个view是需要显示的</div><div class="line">            if (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">                    == LayoutState.LAYOUT_START)) &#123;</div><div class="line">                addView(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                addView(view, 0);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">	    //这个view是标记为invisible的</div><div class="line">            if (mShouldReverseLayout == (layoutState.mLayoutDirection</div><div class="line">                    == LayoutState.LAYOUT_START)) &#123;</div><div class="line">                addDisappearingView(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                addDisappearingView(view, 0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	//计算margin值，用来进行排列</div><div class="line">        measureChildWithMargins(view, 0, 0);</div><div class="line">	//这个会计算当前view的decoration占用的位置和margin总值</div><div class="line">        result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</div><div class="line">        int left, top, right, bottom;</div><div class="line">        if (mOrientation == VERTICAL) &#123;</div><div class="line">            if (isLayoutRTL()) &#123;</div><div class="line">                right = getWidth() - getPaddingRight();</div><div class="line">                left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">            &#125; else &#123;</div><div class="line">                left = getPaddingLeft();</div><div class="line">                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line">            &#125;</div><div class="line">            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">	        bottom = layoutState.mOffset;</div><div class="line">                top = layoutState.mOffset - result.mConsumed;</div><div class="line">            &#125; else &#123;</div><div class="line">		//我们只分析垂直摆放，而且方向是初始从上至下的，那么top高度为当前的offset，bottom值为当前的offset加上前面计算的占用大小</div><div class="line">                top = layoutState.mOffset;</div><div class="line">                bottom = layoutState.mOffset + result.mConsumed;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            top = getPaddingTop();</div><div class="line">            bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);</div><div class="line"></div><div class="line">            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123;</div><div class="line">                right = layoutState.mOffset;</div><div class="line">                left = layoutState.mOffset - result.mConsumed;</div><div class="line">            &#125; else &#123;</div><div class="line">                left = layoutState.mOffset;</div><div class="line">                right = layoutState.mOffset + result.mConsumed;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">	//为了能够正确的计算，我们还需要对子view进行layout计算。</div><div class="line">        layoutDecorated(view, left + params.leftMargin, top + params.topMargin,</div><div class="line">                right - params.rightMargin, bottom - params.bottomMargin);</div><div class="line">        &#125;</div><div class="line">        result.mFocusable = view.isFocusable();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
这就完成layout计算。</li>
</ol>
<h2 id="recyclerView滑动处理"><a href="#recyclerView滑动处理" class="headerlink" title="recyclerView滑动处理"></a>recyclerView滑动处理</h2><p>a</p>
<h2 id="recyclerView-缓存处理"><a href="#recyclerView-缓存处理" class="headerlink" title="recyclerView 缓存处理"></a>recyclerView 缓存处理</h2><p>b</p>
<h2 id="一些关于recyclerView相关的应用"><a href="#一些关于recyclerView相关的应用" class="headerlink" title="一些关于recyclerView相关的应用"></a>一些关于recyclerView相关的应用</h2><p>c</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/xiejl.github.io/2017/04/09/0409anotation的基本原理/" rel="next" title="annotation(注解)的基本原理">
                <i class="fa fa-chevron-left"></i> annotation(注解)的基本原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/xiejl.github.io/images/avatar.gif"
               alt="xie" />
          <p class="site-author-name" itemprop="name">xie</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/xiejl.github.io/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#recyclerView简介"><span class="nav-number">1.</span> <span class="nav-text">recyclerView简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#recyclerView简单相关"><span class="nav-number">2.</span> <span class="nav-text">recyclerView简单相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#recyclerView的简单用法"><span class="nav-number">3.</span> <span class="nav-text">recyclerView的简单用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#recylerView简单流程"><span class="nav-number">3.1.</span> <span class="nav-text">recylerView简单流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recyclerView源码入口"><span class="nav-number">3.2.</span> <span class="nav-text">recyclerView源码入口:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一些recyclerView的相关定义"><span class="nav-number">3.2.1.</span> <span class="nav-text">一些recyclerView的相关定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RecyclerView源码2"><span class="nav-number">3.3.</span> <span class="nav-text">RecyclerView源码2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recyclerView滑动处理"><span class="nav-number">3.4.</span> <span class="nav-text">recyclerView滑动处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recyclerView-缓存处理"><span class="nav-number">3.5.</span> <span class="nav-text">recyclerView 缓存处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些关于recyclerView相关的应用"><span class="nav-number">3.6.</span> <span class="nav-text">一些关于recyclerView相关的应用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xie</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/xiejl.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/xiejl.github.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/xiejl.github.io/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/xiejl.github.io/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/xiejl.github.io/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/xiejl.github.io/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/xiejl.github.io/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
